
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserRole
 * 
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model Position
 * 
 */
export type Position = $Result.DefaultSelection<Prisma.$PositionPayload>
/**
 * Model MaritalStatus
 * 
 */
export type MaritalStatus = $Result.DefaultSelection<Prisma.$MaritalStatusPayload>
/**
 * Model EmploymentType
 * 
 */
export type EmploymentType = $Result.DefaultSelection<Prisma.$EmploymentTypePayload>
/**
 * Model JobStatus
 * 
 */
export type JobStatus = $Result.DefaultSelection<Prisma.$JobStatusPayload>
/**
 * Model AgreementStatus
 * 
 */
export type AgreementStatus = $Result.DefaultSelection<Prisma.$AgreementStatusPayload>
/**
 * Model Meeting
 * 
 */
export type Meeting = $Result.DefaultSelection<Prisma.$MeetingPayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model Shift
 * 
 */
export type Shift = $Result.DefaultSelection<Prisma.$ShiftPayload>
/**
 * Model EmployeeShift
 * 
 */
export type EmployeeShift = $Result.DefaultSelection<Prisma.$EmployeeShiftPayload>
/**
 * Model SessionDefinition
 * 
 */
export type SessionDefinition = $Result.DefaultSelection<Prisma.$SessionDefinitionPayload>
/**
 * Model AttendanceLog
 * 
 */
export type AttendanceLog = $Result.DefaultSelection<Prisma.$AttendanceLogPayload>
/**
 * Model AttendanceSummary
 * 
 */
export type AttendanceSummary = $Result.DefaultSelection<Prisma.$AttendanceSummaryPayload>
/**
 * Model Leave
 * 
 */
export type Leave = $Result.DefaultSelection<Prisma.$LeavePayload>
/**
 * Model Holiday
 * 
 */
export type Holiday = $Result.DefaultSelection<Prisma.$HolidayPayload>
/**
 * Model OvertimeLog
 * 
 */
export type OvertimeLog = $Result.DefaultSelection<Prisma.$OvertimeLogPayload>
/**
 * Model Salary
 * 
 */
export type Salary = $Result.DefaultSelection<Prisma.$SalaryPayload>
/**
 * Model Complaint
 * 
 */
export type Complaint = $Result.DefaultSelection<Prisma.$ComplaintPayload>
/**
 * Model Interview
 * 
 */
export type Interview = $Result.DefaultSelection<Prisma.$InterviewPayload>
/**
 * Model PerformanceReview
 * 
 */
export type PerformanceReview = $Result.DefaultSelection<Prisma.$PerformanceReviewPayload>
/**
 * Model Termination
 * 
 */
export type Termination = $Result.DefaultSelection<Prisma.$TerminationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Sex: {
  male: 'male',
  female: 'female'
};

export type Sex = (typeof Sex)[keyof typeof Sex]


export const LeaveType: {
  annual: 'annual',
  sick: 'sick',
  unpaid: 'unpaid',
  maternity: 'maternity',
  other: 'other'
};

export type LeaveType = (typeof LeaveType)[keyof typeof LeaveType]


export const LeaveStatus: {
  pending: 'pending',
  approved: 'approved',
  rejected: 'rejected'
};

export type LeaveStatus = (typeof LeaveStatus)[keyof typeof LeaveStatus]


export const AttendanceStatus: {
  present: 'present',
  late: 'late',
  absent: 'absent',
  permission: 'permission'
};

export type AttendanceStatus = (typeof AttendanceStatus)[keyof typeof AttendanceStatus]


export const SummaryStatus: {
  present: 'present',
  absent: 'absent',
  half_day: 'half_day',
  on_leave: 'on_leave',
  holiday: 'holiday',
  weekend: 'weekend'
};

export type SummaryStatus = (typeof SummaryStatus)[keyof typeof SummaryStatus]


export const ComplaintStatus: {
  open: 'open',
  in_review: 'in_review',
  resolved: 'resolved',
  rejected: 'rejected'
};

export type ComplaintStatus = (typeof ComplaintStatus)[keyof typeof ComplaintStatus]


export const InterviewResult: {
  pending: 'pending',
  selected: 'selected',
  rejected: 'rejected'
};

export type InterviewResult = (typeof InterviewResult)[keyof typeof InterviewResult]


export const OvertimeApprovalStatus: {
  pending: 'pending',
  approved: 'approved',
  rejected: 'rejected'
};

export type OvertimeApprovalStatus = (typeof OvertimeApprovalStatus)[keyof typeof OvertimeApprovalStatus]


export const CompensationMethod: {
  cash: 'cash',
  time_off: 'time_off'
};

export type CompensationMethod = (typeof CompensationMethod)[keyof typeof CompensationMethod]


export const SalaryStatus: {
  paid: 'paid',
  unpaid: 'unpaid',
  pending: 'pending'
};

export type SalaryStatus = (typeof SalaryStatus)[keyof typeof SalaryStatus]


export const TerminationStatus: {
  voluntary: 'voluntary',
  involuntary: 'involuntary',
  retired: 'retired'
};

export type TerminationStatus = (typeof TerminationStatus)[keyof typeof TerminationStatus]


export const WorkflowStatus: {
  pending_approval: 'pending_approval',
  processing: 'processing',
  finalized: 'finalized'
};

export type WorkflowStatus = (typeof WorkflowStatus)[keyof typeof WorkflowStatus]

}

export type Sex = $Enums.Sex

export const Sex: typeof $Enums.Sex

export type LeaveType = $Enums.LeaveType

export const LeaveType: typeof $Enums.LeaveType

export type LeaveStatus = $Enums.LeaveStatus

export const LeaveStatus: typeof $Enums.LeaveStatus

export type AttendanceStatus = $Enums.AttendanceStatus

export const AttendanceStatus: typeof $Enums.AttendanceStatus

export type SummaryStatus = $Enums.SummaryStatus

export const SummaryStatus: typeof $Enums.SummaryStatus

export type ComplaintStatus = $Enums.ComplaintStatus

export const ComplaintStatus: typeof $Enums.ComplaintStatus

export type InterviewResult = $Enums.InterviewResult

export const InterviewResult: typeof $Enums.InterviewResult

export type OvertimeApprovalStatus = $Enums.OvertimeApprovalStatus

export const OvertimeApprovalStatus: typeof $Enums.OvertimeApprovalStatus

export type CompensationMethod = $Enums.CompensationMethod

export const CompensationMethod: typeof $Enums.CompensationMethod

export type SalaryStatus = $Enums.SalaryStatus

export const SalaryStatus: typeof $Enums.SalaryStatus

export type TerminationStatus = $Enums.TerminationStatus

export const TerminationStatus: typeof $Enums.TerminationStatus

export type WorkflowStatus = $Enums.WorkflowStatus

export const WorkflowStatus: typeof $Enums.WorkflowStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Roles
 * const roles = await prisma.role.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Roles
   * const roles = await prisma.role.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.position`: Exposes CRUD operations for the **Position** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Positions
    * const positions = await prisma.position.findMany()
    * ```
    */
  get position(): Prisma.PositionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.maritalStatus`: Exposes CRUD operations for the **MaritalStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaritalStatuses
    * const maritalStatuses = await prisma.maritalStatus.findMany()
    * ```
    */
  get maritalStatus(): Prisma.MaritalStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employmentType`: Exposes CRUD operations for the **EmploymentType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmploymentTypes
    * const employmentTypes = await prisma.employmentType.findMany()
    * ```
    */
  get employmentType(): Prisma.EmploymentTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobStatus`: Exposes CRUD operations for the **JobStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobStatuses
    * const jobStatuses = await prisma.jobStatus.findMany()
    * ```
    */
  get jobStatus(): Prisma.JobStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agreementStatus`: Exposes CRUD operations for the **AgreementStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgreementStatuses
    * const agreementStatuses = await prisma.agreementStatus.findMany()
    * ```
    */
  get agreementStatus(): Prisma.AgreementStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.meeting`: Exposes CRUD operations for the **Meeting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meetings
    * const meetings = await prisma.meeting.findMany()
    * ```
    */
  get meeting(): Prisma.MeetingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shift`: Exposes CRUD operations for the **Shift** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shifts
    * const shifts = await prisma.shift.findMany()
    * ```
    */
  get shift(): Prisma.ShiftDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employeeShift`: Exposes CRUD operations for the **EmployeeShift** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeShifts
    * const employeeShifts = await prisma.employeeShift.findMany()
    * ```
    */
  get employeeShift(): Prisma.EmployeeShiftDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessionDefinition`: Exposes CRUD operations for the **SessionDefinition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionDefinitions
    * const sessionDefinitions = await prisma.sessionDefinition.findMany()
    * ```
    */
  get sessionDefinition(): Prisma.SessionDefinitionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendanceLog`: Exposes CRUD operations for the **AttendanceLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttendanceLogs
    * const attendanceLogs = await prisma.attendanceLog.findMany()
    * ```
    */
  get attendanceLog(): Prisma.AttendanceLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendanceSummary`: Exposes CRUD operations for the **AttendanceSummary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttendanceSummaries
    * const attendanceSummaries = await prisma.attendanceSummary.findMany()
    * ```
    */
  get attendanceSummary(): Prisma.AttendanceSummaryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leave`: Exposes CRUD operations for the **Leave** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leaves
    * const leaves = await prisma.leave.findMany()
    * ```
    */
  get leave(): Prisma.LeaveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.holiday`: Exposes CRUD operations for the **Holiday** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Holidays
    * const holidays = await prisma.holiday.findMany()
    * ```
    */
  get holiday(): Prisma.HolidayDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.overtimeLog`: Exposes CRUD operations for the **OvertimeLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OvertimeLogs
    * const overtimeLogs = await prisma.overtimeLog.findMany()
    * ```
    */
  get overtimeLog(): Prisma.OvertimeLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salary`: Exposes CRUD operations for the **Salary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Salaries
    * const salaries = await prisma.salary.findMany()
    * ```
    */
  get salary(): Prisma.SalaryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.complaint`: Exposes CRUD operations for the **Complaint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Complaints
    * const complaints = await prisma.complaint.findMany()
    * ```
    */
  get complaint(): Prisma.ComplaintDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.interview`: Exposes CRUD operations for the **Interview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Interviews
    * const interviews = await prisma.interview.findMany()
    * ```
    */
  get interview(): Prisma.InterviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.performanceReview`: Exposes CRUD operations for the **PerformanceReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PerformanceReviews
    * const performanceReviews = await prisma.performanceReview.findMany()
    * ```
    */
  get performanceReview(): Prisma.PerformanceReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.termination`: Exposes CRUD operations for the **Termination** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Terminations
    * const terminations = await prisma.termination.findMany()
    * ```
    */
  get termination(): Prisma.TerminationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.14.0
   * Query Engine version: 717184b7b35ea05dfa71a3236b7af656013e1e49
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Role: 'Role',
    User: 'User',
    UserRole: 'UserRole',
    Department: 'Department',
    Position: 'Position',
    MaritalStatus: 'MaritalStatus',
    EmploymentType: 'EmploymentType',
    JobStatus: 'JobStatus',
    AgreementStatus: 'AgreementStatus',
    Meeting: 'Meeting',
    Employee: 'Employee',
    Shift: 'Shift',
    EmployeeShift: 'EmployeeShift',
    SessionDefinition: 'SessionDefinition',
    AttendanceLog: 'AttendanceLog',
    AttendanceSummary: 'AttendanceSummary',
    Leave: 'Leave',
    Holiday: 'Holiday',
    OvertimeLog: 'OvertimeLog',
    Salary: 'Salary',
    Complaint: 'Complaint',
    Interview: 'Interview',
    PerformanceReview: 'PerformanceReview',
    Termination: 'Termination'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "role" | "user" | "userRole" | "department" | "position" | "maritalStatus" | "employmentType" | "jobStatus" | "agreementStatus" | "meeting" | "employee" | "shift" | "employeeShift" | "sessionDefinition" | "attendanceLog" | "attendanceSummary" | "leave" | "holiday" | "overtimeLog" | "salary" | "complaint" | "interview" | "performanceReview" | "termination"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      Position: {
        payload: Prisma.$PositionPayload<ExtArgs>
        fields: Prisma.PositionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PositionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PositionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          findFirst: {
            args: Prisma.PositionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PositionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          findMany: {
            args: Prisma.PositionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>[]
          }
          create: {
            args: Prisma.PositionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          createMany: {
            args: Prisma.PositionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PositionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          update: {
            args: Prisma.PositionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          deleteMany: {
            args: Prisma.PositionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PositionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PositionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          aggregate: {
            args: Prisma.PositionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePosition>
          }
          groupBy: {
            args: Prisma.PositionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PositionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PositionCountArgs<ExtArgs>
            result: $Utils.Optional<PositionCountAggregateOutputType> | number
          }
        }
      }
      MaritalStatus: {
        payload: Prisma.$MaritalStatusPayload<ExtArgs>
        fields: Prisma.MaritalStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaritalStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaritalStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaritalStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaritalStatusPayload>
          }
          findFirst: {
            args: Prisma.MaritalStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaritalStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaritalStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaritalStatusPayload>
          }
          findMany: {
            args: Prisma.MaritalStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaritalStatusPayload>[]
          }
          create: {
            args: Prisma.MaritalStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaritalStatusPayload>
          }
          createMany: {
            args: Prisma.MaritalStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MaritalStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaritalStatusPayload>
          }
          update: {
            args: Prisma.MaritalStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaritalStatusPayload>
          }
          deleteMany: {
            args: Prisma.MaritalStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaritalStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaritalStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaritalStatusPayload>
          }
          aggregate: {
            args: Prisma.MaritalStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaritalStatus>
          }
          groupBy: {
            args: Prisma.MaritalStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaritalStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaritalStatusCountArgs<ExtArgs>
            result: $Utils.Optional<MaritalStatusCountAggregateOutputType> | number
          }
        }
      }
      EmploymentType: {
        payload: Prisma.$EmploymentTypePayload<ExtArgs>
        fields: Prisma.EmploymentTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmploymentTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmploymentTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentTypePayload>
          }
          findFirst: {
            args: Prisma.EmploymentTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmploymentTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentTypePayload>
          }
          findMany: {
            args: Prisma.EmploymentTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentTypePayload>[]
          }
          create: {
            args: Prisma.EmploymentTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentTypePayload>
          }
          createMany: {
            args: Prisma.EmploymentTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmploymentTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentTypePayload>
          }
          update: {
            args: Prisma.EmploymentTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentTypePayload>
          }
          deleteMany: {
            args: Prisma.EmploymentTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmploymentTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmploymentTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentTypePayload>
          }
          aggregate: {
            args: Prisma.EmploymentTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmploymentType>
          }
          groupBy: {
            args: Prisma.EmploymentTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmploymentTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmploymentTypeCountArgs<ExtArgs>
            result: $Utils.Optional<EmploymentTypeCountAggregateOutputType> | number
          }
        }
      }
      JobStatus: {
        payload: Prisma.$JobStatusPayload<ExtArgs>
        fields: Prisma.JobStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobStatusPayload>
          }
          findFirst: {
            args: Prisma.JobStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobStatusPayload>
          }
          findMany: {
            args: Prisma.JobStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobStatusPayload>[]
          }
          create: {
            args: Prisma.JobStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobStatusPayload>
          }
          createMany: {
            args: Prisma.JobStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.JobStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobStatusPayload>
          }
          update: {
            args: Prisma.JobStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobStatusPayload>
          }
          deleteMany: {
            args: Prisma.JobStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JobStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobStatusPayload>
          }
          aggregate: {
            args: Prisma.JobStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobStatus>
          }
          groupBy: {
            args: Prisma.JobStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobStatusCountArgs<ExtArgs>
            result: $Utils.Optional<JobStatusCountAggregateOutputType> | number
          }
        }
      }
      AgreementStatus: {
        payload: Prisma.$AgreementStatusPayload<ExtArgs>
        fields: Prisma.AgreementStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgreementStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgreementStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementStatusPayload>
          }
          findFirst: {
            args: Prisma.AgreementStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgreementStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementStatusPayload>
          }
          findMany: {
            args: Prisma.AgreementStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementStatusPayload>[]
          }
          create: {
            args: Prisma.AgreementStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementStatusPayload>
          }
          createMany: {
            args: Prisma.AgreementStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AgreementStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementStatusPayload>
          }
          update: {
            args: Prisma.AgreementStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementStatusPayload>
          }
          deleteMany: {
            args: Prisma.AgreementStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgreementStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AgreementStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementStatusPayload>
          }
          aggregate: {
            args: Prisma.AgreementStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgreementStatus>
          }
          groupBy: {
            args: Prisma.AgreementStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgreementStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgreementStatusCountArgs<ExtArgs>
            result: $Utils.Optional<AgreementStatusCountAggregateOutputType> | number
          }
        }
      }
      Meeting: {
        payload: Prisma.$MeetingPayload<ExtArgs>
        fields: Prisma.MeetingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MeetingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MeetingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          findFirst: {
            args: Prisma.MeetingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MeetingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          findMany: {
            args: Prisma.MeetingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>[]
          }
          create: {
            args: Prisma.MeetingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          createMany: {
            args: Prisma.MeetingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MeetingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          update: {
            args: Prisma.MeetingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          deleteMany: {
            args: Prisma.MeetingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MeetingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MeetingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          aggregate: {
            args: Prisma.MeetingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeeting>
          }
          groupBy: {
            args: Prisma.MeetingGroupByArgs<ExtArgs>
            result: $Utils.Optional<MeetingGroupByOutputType>[]
          }
          count: {
            args: Prisma.MeetingCountArgs<ExtArgs>
            result: $Utils.Optional<MeetingCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      Shift: {
        payload: Prisma.$ShiftPayload<ExtArgs>
        fields: Prisma.ShiftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShiftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShiftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          findFirst: {
            args: Prisma.ShiftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShiftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          findMany: {
            args: Prisma.ShiftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          create: {
            args: Prisma.ShiftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          createMany: {
            args: Prisma.ShiftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ShiftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          update: {
            args: Prisma.ShiftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          deleteMany: {
            args: Prisma.ShiftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShiftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShiftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          aggregate: {
            args: Prisma.ShiftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShift>
          }
          groupBy: {
            args: Prisma.ShiftGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShiftGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShiftCountArgs<ExtArgs>
            result: $Utils.Optional<ShiftCountAggregateOutputType> | number
          }
        }
      }
      EmployeeShift: {
        payload: Prisma.$EmployeeShiftPayload<ExtArgs>
        fields: Prisma.EmployeeShiftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeShiftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeShiftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeShiftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeShiftPayload>
          }
          findFirst: {
            args: Prisma.EmployeeShiftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeShiftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeShiftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeShiftPayload>
          }
          findMany: {
            args: Prisma.EmployeeShiftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeShiftPayload>[]
          }
          create: {
            args: Prisma.EmployeeShiftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeShiftPayload>
          }
          createMany: {
            args: Prisma.EmployeeShiftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmployeeShiftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeShiftPayload>
          }
          update: {
            args: Prisma.EmployeeShiftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeShiftPayload>
          }
          deleteMany: {
            args: Prisma.EmployeeShiftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeShiftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeShiftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeShiftPayload>
          }
          aggregate: {
            args: Prisma.EmployeeShiftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeShift>
          }
          groupBy: {
            args: Prisma.EmployeeShiftGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeShiftGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeShiftCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeShiftCountAggregateOutputType> | number
          }
        }
      }
      SessionDefinition: {
        payload: Prisma.$SessionDefinitionPayload<ExtArgs>
        fields: Prisma.SessionDefinitionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionDefinitionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionDefinitionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionDefinitionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionDefinitionPayload>
          }
          findFirst: {
            args: Prisma.SessionDefinitionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionDefinitionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionDefinitionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionDefinitionPayload>
          }
          findMany: {
            args: Prisma.SessionDefinitionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionDefinitionPayload>[]
          }
          create: {
            args: Prisma.SessionDefinitionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionDefinitionPayload>
          }
          createMany: {
            args: Prisma.SessionDefinitionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SessionDefinitionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionDefinitionPayload>
          }
          update: {
            args: Prisma.SessionDefinitionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionDefinitionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDefinitionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionDefinitionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionDefinitionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionDefinitionPayload>
          }
          aggregate: {
            args: Prisma.SessionDefinitionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionDefinition>
          }
          groupBy: {
            args: Prisma.SessionDefinitionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionDefinitionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionDefinitionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionDefinitionCountAggregateOutputType> | number
          }
        }
      }
      AttendanceLog: {
        payload: Prisma.$AttendanceLogPayload<ExtArgs>
        fields: Prisma.AttendanceLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload>
          }
          findFirst: {
            args: Prisma.AttendanceLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload>
          }
          findMany: {
            args: Prisma.AttendanceLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload>[]
          }
          create: {
            args: Prisma.AttendanceLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload>
          }
          createMany: {
            args: Prisma.AttendanceLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AttendanceLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload>
          }
          update: {
            args: Prisma.AttendanceLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload>
          }
          deleteMany: {
            args: Prisma.AttendanceLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AttendanceLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload>
          }
          aggregate: {
            args: Prisma.AttendanceLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendanceLog>
          }
          groupBy: {
            args: Prisma.AttendanceLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceLogCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceLogCountAggregateOutputType> | number
          }
        }
      }
      AttendanceSummary: {
        payload: Prisma.$AttendanceSummaryPayload<ExtArgs>
        fields: Prisma.AttendanceSummaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceSummaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceSummaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>
          }
          findFirst: {
            args: Prisma.AttendanceSummaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceSummaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>
          }
          findMany: {
            args: Prisma.AttendanceSummaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>[]
          }
          create: {
            args: Prisma.AttendanceSummaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>
          }
          createMany: {
            args: Prisma.AttendanceSummaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AttendanceSummaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>
          }
          update: {
            args: Prisma.AttendanceSummaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>
          }
          deleteMany: {
            args: Prisma.AttendanceSummaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceSummaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AttendanceSummaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceSummaryPayload>
          }
          aggregate: {
            args: Prisma.AttendanceSummaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendanceSummary>
          }
          groupBy: {
            args: Prisma.AttendanceSummaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceSummaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceSummaryCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceSummaryCountAggregateOutputType> | number
          }
        }
      }
      Leave: {
        payload: Prisma.$LeavePayload<ExtArgs>
        fields: Prisma.LeaveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          findFirst: {
            args: Prisma.LeaveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          findMany: {
            args: Prisma.LeaveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>[]
          }
          create: {
            args: Prisma.LeaveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          createMany: {
            args: Prisma.LeaveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LeaveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          update: {
            args: Prisma.LeaveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          deleteMany: {
            args: Prisma.LeaveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeaveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          aggregate: {
            args: Prisma.LeaveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeave>
          }
          groupBy: {
            args: Prisma.LeaveGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaveGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveCountArgs<ExtArgs>
            result: $Utils.Optional<LeaveCountAggregateOutputType> | number
          }
        }
      }
      Holiday: {
        payload: Prisma.$HolidayPayload<ExtArgs>
        fields: Prisma.HolidayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HolidayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HolidayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          findFirst: {
            args: Prisma.HolidayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HolidayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          findMany: {
            args: Prisma.HolidayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>[]
          }
          create: {
            args: Prisma.HolidayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          createMany: {
            args: Prisma.HolidayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.HolidayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          update: {
            args: Prisma.HolidayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          deleteMany: {
            args: Prisma.HolidayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HolidayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HolidayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HolidayPayload>
          }
          aggregate: {
            args: Prisma.HolidayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHoliday>
          }
          groupBy: {
            args: Prisma.HolidayGroupByArgs<ExtArgs>
            result: $Utils.Optional<HolidayGroupByOutputType>[]
          }
          count: {
            args: Prisma.HolidayCountArgs<ExtArgs>
            result: $Utils.Optional<HolidayCountAggregateOutputType> | number
          }
        }
      }
      OvertimeLog: {
        payload: Prisma.$OvertimeLogPayload<ExtArgs>
        fields: Prisma.OvertimeLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OvertimeLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimeLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OvertimeLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimeLogPayload>
          }
          findFirst: {
            args: Prisma.OvertimeLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimeLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OvertimeLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimeLogPayload>
          }
          findMany: {
            args: Prisma.OvertimeLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimeLogPayload>[]
          }
          create: {
            args: Prisma.OvertimeLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimeLogPayload>
          }
          createMany: {
            args: Prisma.OvertimeLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OvertimeLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimeLogPayload>
          }
          update: {
            args: Prisma.OvertimeLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimeLogPayload>
          }
          deleteMany: {
            args: Prisma.OvertimeLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OvertimeLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OvertimeLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimeLogPayload>
          }
          aggregate: {
            args: Prisma.OvertimeLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOvertimeLog>
          }
          groupBy: {
            args: Prisma.OvertimeLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<OvertimeLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.OvertimeLogCountArgs<ExtArgs>
            result: $Utils.Optional<OvertimeLogCountAggregateOutputType> | number
          }
        }
      }
      Salary: {
        payload: Prisma.$SalaryPayload<ExtArgs>
        fields: Prisma.SalaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>
          }
          findFirst: {
            args: Prisma.SalaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>
          }
          findMany: {
            args: Prisma.SalaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>[]
          }
          create: {
            args: Prisma.SalaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>
          }
          createMany: {
            args: Prisma.SalaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SalaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>
          }
          update: {
            args: Prisma.SalaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>
          }
          deleteMany: {
            args: Prisma.SalaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SalaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryPayload>
          }
          aggregate: {
            args: Prisma.SalaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalary>
          }
          groupBy: {
            args: Prisma.SalaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalaryCountArgs<ExtArgs>
            result: $Utils.Optional<SalaryCountAggregateOutputType> | number
          }
        }
      }
      Complaint: {
        payload: Prisma.$ComplaintPayload<ExtArgs>
        fields: Prisma.ComplaintFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComplaintFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComplaintFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          findFirst: {
            args: Prisma.ComplaintFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComplaintFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          findMany: {
            args: Prisma.ComplaintFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>[]
          }
          create: {
            args: Prisma.ComplaintCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          createMany: {
            args: Prisma.ComplaintCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ComplaintDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          update: {
            args: Prisma.ComplaintUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          deleteMany: {
            args: Prisma.ComplaintDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComplaintUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComplaintUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          aggregate: {
            args: Prisma.ComplaintAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplaint>
          }
          groupBy: {
            args: Prisma.ComplaintGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplaintGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComplaintCountArgs<ExtArgs>
            result: $Utils.Optional<ComplaintCountAggregateOutputType> | number
          }
        }
      }
      Interview: {
        payload: Prisma.$InterviewPayload<ExtArgs>
        fields: Prisma.InterviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>
          }
          findFirst: {
            args: Prisma.InterviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>
          }
          findMany: {
            args: Prisma.InterviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>[]
          }
          create: {
            args: Prisma.InterviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>
          }
          createMany: {
            args: Prisma.InterviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InterviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>
          }
          update: {
            args: Prisma.InterviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>
          }
          deleteMany: {
            args: Prisma.InterviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InterviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewPayload>
          }
          aggregate: {
            args: Prisma.InterviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterview>
          }
          groupBy: {
            args: Prisma.InterviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterviewCountArgs<ExtArgs>
            result: $Utils.Optional<InterviewCountAggregateOutputType> | number
          }
        }
      }
      PerformanceReview: {
        payload: Prisma.$PerformanceReviewPayload<ExtArgs>
        fields: Prisma.PerformanceReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PerformanceReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PerformanceReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>
          }
          findFirst: {
            args: Prisma.PerformanceReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PerformanceReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>
          }
          findMany: {
            args: Prisma.PerformanceReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>[]
          }
          create: {
            args: Prisma.PerformanceReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>
          }
          createMany: {
            args: Prisma.PerformanceReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PerformanceReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>
          }
          update: {
            args: Prisma.PerformanceReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>
          }
          deleteMany: {
            args: Prisma.PerformanceReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PerformanceReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PerformanceReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceReviewPayload>
          }
          aggregate: {
            args: Prisma.PerformanceReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerformanceReview>
          }
          groupBy: {
            args: Prisma.PerformanceReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<PerformanceReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.PerformanceReviewCountArgs<ExtArgs>
            result: $Utils.Optional<PerformanceReviewCountAggregateOutputType> | number
          }
        }
      }
      Termination: {
        payload: Prisma.$TerminationPayload<ExtArgs>
        fields: Prisma.TerminationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TerminationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TerminationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminationPayload>
          }
          findFirst: {
            args: Prisma.TerminationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TerminationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminationPayload>
          }
          findMany: {
            args: Prisma.TerminationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminationPayload>[]
          }
          create: {
            args: Prisma.TerminationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminationPayload>
          }
          createMany: {
            args: Prisma.TerminationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TerminationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminationPayload>
          }
          update: {
            args: Prisma.TerminationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminationPayload>
          }
          deleteMany: {
            args: Prisma.TerminationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TerminationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TerminationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminationPayload>
          }
          aggregate: {
            args: Prisma.TerminationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTermination>
          }
          groupBy: {
            args: Prisma.TerminationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TerminationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TerminationCountArgs<ExtArgs>
            result: $Utils.Optional<TerminationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    role?: RoleOmit
    user?: UserOmit
    userRole?: UserRoleOmit
    department?: DepartmentOmit
    position?: PositionOmit
    maritalStatus?: MaritalStatusOmit
    employmentType?: EmploymentTypeOmit
    jobStatus?: JobStatusOmit
    agreementStatus?: AgreementStatusOmit
    meeting?: MeetingOmit
    employee?: EmployeeOmit
    shift?: ShiftOmit
    employeeShift?: EmployeeShiftOmit
    sessionDefinition?: SessionDefinitionOmit
    attendanceLog?: AttendanceLogOmit
    attendanceSummary?: AttendanceSummaryOmit
    leave?: LeaveOmit
    holiday?: HolidayOmit
    overtimeLog?: OvertimeLogOmit
    salary?: SalaryOmit
    complaint?: ComplaintOmit
    interview?: InterviewOmit
    performanceReview?: PerformanceReviewOmit
    termination?: TerminationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    roles: number
    employees: number
    approvedLeaves: number
    approvedOvertimes: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | UserCountOutputTypeCountRolesArgs
    employees?: boolean | UserCountOutputTypeCountEmployeesArgs
    approvedLeaves?: boolean | UserCountOutputTypeCountApprovedLeavesArgs
    approvedOvertimes?: boolean | UserCountOutputTypeCountApprovedOvertimesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedLeavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedOvertimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OvertimeLogWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    subDepartments: number
    employees: number
    attendanceSummaries: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subDepartments?: boolean | DepartmentCountOutputTypeCountSubDepartmentsArgs
    employees?: boolean | DepartmentCountOutputTypeCountEmployeesArgs
    attendanceSummaries?: boolean | DepartmentCountOutputTypeCountAttendanceSummariesArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountSubDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountAttendanceSummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceSummaryWhereInput
  }


  /**
   * Count Type PositionCountOutputType
   */

  export type PositionCountOutputType = {
    employees: number
  }

  export type PositionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | PositionCountOutputTypeCountEmployeesArgs
  }

  // Custom InputTypes
  /**
   * PositionCountOutputType without action
   */
  export type PositionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionCountOutputType
     */
    select?: PositionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PositionCountOutputType without action
   */
  export type PositionCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }


  /**
   * Count Type MaritalStatusCountOutputType
   */

  export type MaritalStatusCountOutputType = {
    employees: number
  }

  export type MaritalStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | MaritalStatusCountOutputTypeCountEmployeesArgs
  }

  // Custom InputTypes
  /**
   * MaritalStatusCountOutputType without action
   */
  export type MaritalStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatusCountOutputType
     */
    select?: MaritalStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaritalStatusCountOutputType without action
   */
  export type MaritalStatusCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }


  /**
   * Count Type EmploymentTypeCountOutputType
   */

  export type EmploymentTypeCountOutputType = {
    employees: number
  }

  export type EmploymentTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | EmploymentTypeCountOutputTypeCountEmployeesArgs
  }

  // Custom InputTypes
  /**
   * EmploymentTypeCountOutputType without action
   */
  export type EmploymentTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentTypeCountOutputType
     */
    select?: EmploymentTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmploymentTypeCountOutputType without action
   */
  export type EmploymentTypeCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }


  /**
   * Count Type JobStatusCountOutputType
   */

  export type JobStatusCountOutputType = {
    employees: number
  }

  export type JobStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | JobStatusCountOutputTypeCountEmployeesArgs
  }

  // Custom InputTypes
  /**
   * JobStatusCountOutputType without action
   */
  export type JobStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobStatusCountOutputType
     */
    select?: JobStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobStatusCountOutputType without action
   */
  export type JobStatusCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }


  /**
   * Count Type AgreementStatusCountOutputType
   */

  export type AgreementStatusCountOutputType = {
    employees: number
  }

  export type AgreementStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | AgreementStatusCountOutputTypeCountEmployeesArgs
  }

  // Custom InputTypes
  /**
   * AgreementStatusCountOutputType without action
   */
  export type AgreementStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementStatusCountOutputType
     */
    select?: AgreementStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgreementStatusCountOutputType without action
   */
  export type AgreementStatusCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    createdMeetings: number
    shifts: number
    attendanceLogs: number
    attendanceSummaries: number
    leaves: number
    complaints: number
    performanceReviews: number
    terminations: number
    salaries: number
    overtimes: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdMeetings?: boolean | EmployeeCountOutputTypeCountCreatedMeetingsArgs
    shifts?: boolean | EmployeeCountOutputTypeCountShiftsArgs
    attendanceLogs?: boolean | EmployeeCountOutputTypeCountAttendanceLogsArgs
    attendanceSummaries?: boolean | EmployeeCountOutputTypeCountAttendanceSummariesArgs
    leaves?: boolean | EmployeeCountOutputTypeCountLeavesArgs
    complaints?: boolean | EmployeeCountOutputTypeCountComplaintsArgs
    performanceReviews?: boolean | EmployeeCountOutputTypeCountPerformanceReviewsArgs
    terminations?: boolean | EmployeeCountOutputTypeCountTerminationsArgs
    salaries?: boolean | EmployeeCountOutputTypeCountSalariesArgs
    overtimes?: boolean | EmployeeCountOutputTypeCountOvertimesArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountCreatedMeetingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeShiftWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountAttendanceLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceLogWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountAttendanceSummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceSummaryWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountLeavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountPerformanceReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceReviewWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountTerminationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TerminationWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountSalariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountOvertimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OvertimeLogWhereInput
  }


  /**
   * Count Type ShiftCountOutputType
   */

  export type ShiftCountOutputType = {
    assignments: number
  }

  export type ShiftCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | ShiftCountOutputTypeCountAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * ShiftCountOutputType without action
   */
  export type ShiftCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftCountOutputType
     */
    select?: ShiftCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShiftCountOutputType without action
   */
  export type ShiftCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeShiftWhereInput
  }


  /**
   * Count Type SessionDefinitionCountOutputType
   */

  export type SessionDefinitionCountOutputType = {
    logs: number
  }

  export type SessionDefinitionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | SessionDefinitionCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * SessionDefinitionCountOutputType without action
   */
  export type SessionDefinitionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionDefinitionCountOutputType
     */
    select?: SessionDefinitionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SessionDefinitionCountOutputType without action
   */
  export type SessionDefinitionCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceLogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number | null
  }

  export type RoleSumAggregateOutputType = {
    id: number | null
  }

  export type RoleMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _avg?: RoleAvgAggregateInputType
    _sum?: RoleSumAggregateInputType
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: number
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _avg: RoleAvgAggregateOutputType | null
    _sum: RoleSumAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>



  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      users: Prisma.$UserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'Int'>
    readonly name: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    password: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    notifyOnComplaint: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    password: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    notifyOnComplaint: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    password: number
    isActive: number
    createdAt: number
    updatedAt: number
    notifyOnComplaint: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    notifyOnComplaint?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    notifyOnComplaint?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    notifyOnComplaint?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    username: string
    email: string
    password: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    notifyOnComplaint: boolean
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    notifyOnComplaint?: boolean
    roles?: boolean | User$rolesArgs<ExtArgs>
    employees?: boolean | User$employeesArgs<ExtArgs>
    approvedLeaves?: boolean | User$approvedLeavesArgs<ExtArgs>
    approvedOvertimes?: boolean | User$approvedOvertimesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    notifyOnComplaint?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "password" | "isActive" | "createdAt" | "updatedAt" | "notifyOnComplaint", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | User$rolesArgs<ExtArgs>
    employees?: boolean | User$employeesArgs<ExtArgs>
    approvedLeaves?: boolean | User$approvedLeavesArgs<ExtArgs>
    approvedOvertimes?: boolean | User$approvedOvertimesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      roles: Prisma.$UserRolePayload<ExtArgs>[]
      employees: Prisma.$EmployeePayload<ExtArgs>[]
      approvedLeaves: Prisma.$LeavePayload<ExtArgs>[]
      approvedOvertimes: Prisma.$OvertimeLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      email: string
      password: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      notifyOnComplaint: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends User$rolesArgs<ExtArgs> = {}>(args?: Subset<T, User$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employees<T extends User$employeesArgs<ExtArgs> = {}>(args?: Subset<T, User$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvedLeaves<T extends User$approvedLeavesArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedLeavesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvedOvertimes<T extends User$approvedOvertimesArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedOvertimesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OvertimeLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly notifyOnComplaint: FieldRef<"User", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.roles
   */
  export type User$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * User.employees
   */
  export type User$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * User.approvedLeaves
   */
  export type User$approvedLeavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    where?: LeaveWhereInput
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    cursor?: LeaveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * User.approvedOvertimes
   */
  export type User$approvedOvertimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OvertimeLog
     */
    select?: OvertimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OvertimeLog
     */
    omit?: OvertimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeLogInclude<ExtArgs> | null
    where?: OvertimeLogWhereInput
    orderBy?: OvertimeLogOrderByWithRelationInput | OvertimeLogOrderByWithRelationInput[]
    cursor?: OvertimeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OvertimeLogScalarFieldEnum | OvertimeLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _avg: UserRoleAvgAggregateOutputType | null
    _sum: UserRoleSumAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleAvgAggregateOutputType = {
    userId: number | null
    roleId: number | null
  }

  export type UserRoleSumAggregateOutputType = {
    userId: number | null
    roleId: number | null
  }

  export type UserRoleMinAggregateOutputType = {
    userId: number | null
    roleId: number | null
  }

  export type UserRoleMaxAggregateOutputType = {
    userId: number | null
    roleId: number | null
  }

  export type UserRoleCountAggregateOutputType = {
    userId: number
    roleId: number
    _all: number
  }


  export type UserRoleAvgAggregateInputType = {
    userId?: true
    roleId?: true
  }

  export type UserRoleSumAggregateInputType = {
    userId?: true
    roleId?: true
  }

  export type UserRoleMinAggregateInputType = {
    userId?: true
    roleId?: true
  }

  export type UserRoleMaxAggregateInputType = {
    userId?: true
    roleId?: true
  }

  export type UserRoleCountAggregateInputType = {
    userId?: true
    roleId?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserRoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserRoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _avg?: UserRoleAvgAggregateInputType
    _sum?: UserRoleSumAggregateInputType
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    userId: number
    roleId: number
    _count: UserRoleCountAggregateOutputType | null
    _avg: UserRoleAvgAggregateOutputType | null
    _sum: UserRoleSumAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>



  export type UserRoleSelectScalar = {
    userId?: boolean
    roleId?: boolean
  }

  export type UserRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "roleId", ExtArgs["result"]["userRole"]>
  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      roleId: number
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */
  interface UserRoleFieldRefs {
    readonly userId: FieldRef<"UserRole", 'Int'>
    readonly roleId: FieldRef<"UserRole", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to delete.
     */
    limit?: number
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentAvgAggregateOutputType = {
    id: number | null
    parentId: number | null
  }

  export type DepartmentSumAggregateOutputType = {
    id: number | null
    parentId: number | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    parentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    parentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    parentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentAvgAggregateInputType = {
    id?: true
    parentId?: true
  }

  export type DepartmentSumAggregateInputType = {
    id?: true
    parentId?: true
  }

  export type DepartmentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _avg?: DepartmentAvgAggregateInputType
    _sum?: DepartmentSumAggregateInputType
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: number
    name: string
    description: string | null
    parentId: number | null
    createdAt: Date
    updatedAt: Date
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Department$parentArgs<ExtArgs>
    subDepartments?: boolean | Department$subDepartmentsArgs<ExtArgs>
    employees?: boolean | Department$employeesArgs<ExtArgs>
    attendanceSummaries?: boolean | Department$attendanceSummariesArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>



  export type DepartmentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepartmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "parentId" | "createdAt" | "updatedAt", ExtArgs["result"]["department"]>
  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Department$parentArgs<ExtArgs>
    subDepartments?: boolean | Department$subDepartmentsArgs<ExtArgs>
    employees?: boolean | Department$employeesArgs<ExtArgs>
    attendanceSummaries?: boolean | Department$attendanceSummariesArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      parent: Prisma.$DepartmentPayload<ExtArgs> | null
      subDepartments: Prisma.$DepartmentPayload<ExtArgs>[]
      employees: Prisma.$EmployeePayload<ExtArgs>[]
      attendanceSummaries: Prisma.$AttendanceSummaryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      parentId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends Department$parentArgs<ExtArgs> = {}>(args?: Subset<T, Department$parentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subDepartments<T extends Department$subDepartmentsArgs<ExtArgs> = {}>(args?: Subset<T, Department$subDepartmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employees<T extends Department$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Department$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendanceSummaries<T extends Department$attendanceSummariesArgs<ExtArgs> = {}>(args?: Subset<T, Department$attendanceSummariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'Int'>
    readonly name: FieldRef<"Department", 'String'>
    readonly description: FieldRef<"Department", 'String'>
    readonly parentId: FieldRef<"Department", 'Int'>
    readonly createdAt: FieldRef<"Department", 'DateTime'>
    readonly updatedAt: FieldRef<"Department", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to delete.
     */
    limit?: number
  }

  /**
   * Department.parent
   */
  export type Department$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Department.subDepartments
   */
  export type Department$subDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department.employees
   */
  export type Department$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Department.attendanceSummaries
   */
  export type Department$attendanceSummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    where?: AttendanceSummaryWhereInput
    orderBy?: AttendanceSummaryOrderByWithRelationInput | AttendanceSummaryOrderByWithRelationInput[]
    cursor?: AttendanceSummaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceSummaryScalarFieldEnum | AttendanceSummaryScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model Position
   */

  export type AggregatePosition = {
    _count: PositionCountAggregateOutputType | null
    _avg: PositionAvgAggregateOutputType | null
    _sum: PositionSumAggregateOutputType | null
    _min: PositionMinAggregateOutputType | null
    _max: PositionMaxAggregateOutputType | null
  }

  export type PositionAvgAggregateOutputType = {
    id: number | null
  }

  export type PositionSumAggregateOutputType = {
    id: number | null
  }

  export type PositionMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PositionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PositionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PositionAvgAggregateInputType = {
    id?: true
  }

  export type PositionSumAggregateInputType = {
    id?: true
  }

  export type PositionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PositionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PositionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PositionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Position to aggregate.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Positions
    **/
    _count?: true | PositionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PositionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PositionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PositionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PositionMaxAggregateInputType
  }

  export type GetPositionAggregateType<T extends PositionAggregateArgs> = {
        [P in keyof T & keyof AggregatePosition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePosition[P]>
      : GetScalarType<T[P], AggregatePosition[P]>
  }




  export type PositionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PositionWhereInput
    orderBy?: PositionOrderByWithAggregationInput | PositionOrderByWithAggregationInput[]
    by: PositionScalarFieldEnum[] | PositionScalarFieldEnum
    having?: PositionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PositionCountAggregateInputType | true
    _avg?: PositionAvgAggregateInputType
    _sum?: PositionSumAggregateInputType
    _min?: PositionMinAggregateInputType
    _max?: PositionMaxAggregateInputType
  }

  export type PositionGroupByOutputType = {
    id: number
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: PositionCountAggregateOutputType | null
    _avg: PositionAvgAggregateOutputType | null
    _sum: PositionSumAggregateOutputType | null
    _min: PositionMinAggregateOutputType | null
    _max: PositionMaxAggregateOutputType | null
  }

  type GetPositionGroupByPayload<T extends PositionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PositionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PositionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PositionGroupByOutputType[P]>
            : GetScalarType<T[P], PositionGroupByOutputType[P]>
        }
      >
    >


  export type PositionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employees?: boolean | Position$employeesArgs<ExtArgs>
    _count?: boolean | PositionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["position"]>



  export type PositionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PositionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["position"]>
  export type PositionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | Position$employeesArgs<ExtArgs>
    _count?: boolean | PositionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PositionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Position"
    objects: {
      employees: Prisma.$EmployeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["position"]>
    composites: {}
  }

  type PositionGetPayload<S extends boolean | null | undefined | PositionDefaultArgs> = $Result.GetResult<Prisma.$PositionPayload, S>

  type PositionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PositionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PositionCountAggregateInputType | true
    }

  export interface PositionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Position'], meta: { name: 'Position' } }
    /**
     * Find zero or one Position that matches the filter.
     * @param {PositionFindUniqueArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PositionFindUniqueArgs>(args: SelectSubset<T, PositionFindUniqueArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Position that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PositionFindUniqueOrThrowArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PositionFindUniqueOrThrowArgs>(args: SelectSubset<T, PositionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Position that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionFindFirstArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PositionFindFirstArgs>(args?: SelectSubset<T, PositionFindFirstArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Position that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionFindFirstOrThrowArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PositionFindFirstOrThrowArgs>(args?: SelectSubset<T, PositionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Positions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Positions
     * const positions = await prisma.position.findMany()
     * 
     * // Get first 10 Positions
     * const positions = await prisma.position.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const positionWithIdOnly = await prisma.position.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PositionFindManyArgs>(args?: SelectSubset<T, PositionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Position.
     * @param {PositionCreateArgs} args - Arguments to create a Position.
     * @example
     * // Create one Position
     * const Position = await prisma.position.create({
     *   data: {
     *     // ... data to create a Position
     *   }
     * })
     * 
     */
    create<T extends PositionCreateArgs>(args: SelectSubset<T, PositionCreateArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Positions.
     * @param {PositionCreateManyArgs} args - Arguments to create many Positions.
     * @example
     * // Create many Positions
     * const position = await prisma.position.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PositionCreateManyArgs>(args?: SelectSubset<T, PositionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Position.
     * @param {PositionDeleteArgs} args - Arguments to delete one Position.
     * @example
     * // Delete one Position
     * const Position = await prisma.position.delete({
     *   where: {
     *     // ... filter to delete one Position
     *   }
     * })
     * 
     */
    delete<T extends PositionDeleteArgs>(args: SelectSubset<T, PositionDeleteArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Position.
     * @param {PositionUpdateArgs} args - Arguments to update one Position.
     * @example
     * // Update one Position
     * const position = await prisma.position.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PositionUpdateArgs>(args: SelectSubset<T, PositionUpdateArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Positions.
     * @param {PositionDeleteManyArgs} args - Arguments to filter Positions to delete.
     * @example
     * // Delete a few Positions
     * const { count } = await prisma.position.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PositionDeleteManyArgs>(args?: SelectSubset<T, PositionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Positions
     * const position = await prisma.position.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PositionUpdateManyArgs>(args: SelectSubset<T, PositionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Position.
     * @param {PositionUpsertArgs} args - Arguments to update or create a Position.
     * @example
     * // Update or create a Position
     * const position = await prisma.position.upsert({
     *   create: {
     *     // ... data to create a Position
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Position we want to update
     *   }
     * })
     */
    upsert<T extends PositionUpsertArgs>(args: SelectSubset<T, PositionUpsertArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionCountArgs} args - Arguments to filter Positions to count.
     * @example
     * // Count the number of Positions
     * const count = await prisma.position.count({
     *   where: {
     *     // ... the filter for the Positions we want to count
     *   }
     * })
    **/
    count<T extends PositionCountArgs>(
      args?: Subset<T, PositionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PositionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Position.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PositionAggregateArgs>(args: Subset<T, PositionAggregateArgs>): Prisma.PrismaPromise<GetPositionAggregateType<T>>

    /**
     * Group by Position.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PositionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PositionGroupByArgs['orderBy'] }
        : { orderBy?: PositionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PositionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPositionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Position model
   */
  readonly fields: PositionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Position.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PositionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employees<T extends Position$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Position$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Position model
   */
  interface PositionFieldRefs {
    readonly id: FieldRef<"Position", 'Int'>
    readonly name: FieldRef<"Position", 'String'>
    readonly description: FieldRef<"Position", 'String'>
    readonly createdAt: FieldRef<"Position", 'DateTime'>
    readonly updatedAt: FieldRef<"Position", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Position findUnique
   */
  export type PositionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Position to fetch.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position findUniqueOrThrow
   */
  export type PositionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Position to fetch.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position findFirst
   */
  export type PositionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Position to fetch.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Positions.
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Positions.
     */
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * Position findFirstOrThrow
   */
  export type PositionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Position to fetch.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Positions.
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Positions.
     */
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * Position findMany
   */
  export type PositionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Positions to fetch.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Positions.
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * Position create
   */
  export type PositionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * The data needed to create a Position.
     */
    data: XOR<PositionCreateInput, PositionUncheckedCreateInput>
  }

  /**
   * Position createMany
   */
  export type PositionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Positions.
     */
    data: PositionCreateManyInput | PositionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Position update
   */
  export type PositionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * The data needed to update a Position.
     */
    data: XOR<PositionUpdateInput, PositionUncheckedUpdateInput>
    /**
     * Choose, which Position to update.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position updateMany
   */
  export type PositionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Positions.
     */
    data: XOR<PositionUpdateManyMutationInput, PositionUncheckedUpdateManyInput>
    /**
     * Filter which Positions to update
     */
    where?: PositionWhereInput
    /**
     * Limit how many Positions to update.
     */
    limit?: number
  }

  /**
   * Position upsert
   */
  export type PositionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * The filter to search for the Position to update in case it exists.
     */
    where: PositionWhereUniqueInput
    /**
     * In case the Position found by the `where` argument doesn't exist, create a new Position with this data.
     */
    create: XOR<PositionCreateInput, PositionUncheckedCreateInput>
    /**
     * In case the Position was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PositionUpdateInput, PositionUncheckedUpdateInput>
  }

  /**
   * Position delete
   */
  export type PositionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter which Position to delete.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position deleteMany
   */
  export type PositionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Positions to delete
     */
    where?: PositionWhereInput
    /**
     * Limit how many Positions to delete.
     */
    limit?: number
  }

  /**
   * Position.employees
   */
  export type Position$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Position without action
   */
  export type PositionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
  }


  /**
   * Model MaritalStatus
   */

  export type AggregateMaritalStatus = {
    _count: MaritalStatusCountAggregateOutputType | null
    _avg: MaritalStatusAvgAggregateOutputType | null
    _sum: MaritalStatusSumAggregateOutputType | null
    _min: MaritalStatusMinAggregateOutputType | null
    _max: MaritalStatusMaxAggregateOutputType | null
  }

  export type MaritalStatusAvgAggregateOutputType = {
    id: number | null
  }

  export type MaritalStatusSumAggregateOutputType = {
    id: number | null
  }

  export type MaritalStatusMinAggregateOutputType = {
    id: number | null
    status: string | null
  }

  export type MaritalStatusMaxAggregateOutputType = {
    id: number | null
    status: string | null
  }

  export type MaritalStatusCountAggregateOutputType = {
    id: number
    status: number
    _all: number
  }


  export type MaritalStatusAvgAggregateInputType = {
    id?: true
  }

  export type MaritalStatusSumAggregateInputType = {
    id?: true
  }

  export type MaritalStatusMinAggregateInputType = {
    id?: true
    status?: true
  }

  export type MaritalStatusMaxAggregateInputType = {
    id?: true
    status?: true
  }

  export type MaritalStatusCountAggregateInputType = {
    id?: true
    status?: true
    _all?: true
  }

  export type MaritalStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaritalStatus to aggregate.
     */
    where?: MaritalStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaritalStatuses to fetch.
     */
    orderBy?: MaritalStatusOrderByWithRelationInput | MaritalStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaritalStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaritalStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaritalStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaritalStatuses
    **/
    _count?: true | MaritalStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaritalStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaritalStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaritalStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaritalStatusMaxAggregateInputType
  }

  export type GetMaritalStatusAggregateType<T extends MaritalStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateMaritalStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaritalStatus[P]>
      : GetScalarType<T[P], AggregateMaritalStatus[P]>
  }




  export type MaritalStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaritalStatusWhereInput
    orderBy?: MaritalStatusOrderByWithAggregationInput | MaritalStatusOrderByWithAggregationInput[]
    by: MaritalStatusScalarFieldEnum[] | MaritalStatusScalarFieldEnum
    having?: MaritalStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaritalStatusCountAggregateInputType | true
    _avg?: MaritalStatusAvgAggregateInputType
    _sum?: MaritalStatusSumAggregateInputType
    _min?: MaritalStatusMinAggregateInputType
    _max?: MaritalStatusMaxAggregateInputType
  }

  export type MaritalStatusGroupByOutputType = {
    id: number
    status: string
    _count: MaritalStatusCountAggregateOutputType | null
    _avg: MaritalStatusAvgAggregateOutputType | null
    _sum: MaritalStatusSumAggregateOutputType | null
    _min: MaritalStatusMinAggregateOutputType | null
    _max: MaritalStatusMaxAggregateOutputType | null
  }

  type GetMaritalStatusGroupByPayload<T extends MaritalStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaritalStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaritalStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaritalStatusGroupByOutputType[P]>
            : GetScalarType<T[P], MaritalStatusGroupByOutputType[P]>
        }
      >
    >


  export type MaritalStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    employees?: boolean | MaritalStatus$employeesArgs<ExtArgs>
    _count?: boolean | MaritalStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maritalStatus"]>



  export type MaritalStatusSelectScalar = {
    id?: boolean
    status?: boolean
  }

  export type MaritalStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status", ExtArgs["result"]["maritalStatus"]>
  export type MaritalStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | MaritalStatus$employeesArgs<ExtArgs>
    _count?: boolean | MaritalStatusCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MaritalStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaritalStatus"
    objects: {
      employees: Prisma.$EmployeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      status: string
    }, ExtArgs["result"]["maritalStatus"]>
    composites: {}
  }

  type MaritalStatusGetPayload<S extends boolean | null | undefined | MaritalStatusDefaultArgs> = $Result.GetResult<Prisma.$MaritalStatusPayload, S>

  type MaritalStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaritalStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaritalStatusCountAggregateInputType | true
    }

  export interface MaritalStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaritalStatus'], meta: { name: 'MaritalStatus' } }
    /**
     * Find zero or one MaritalStatus that matches the filter.
     * @param {MaritalStatusFindUniqueArgs} args - Arguments to find a MaritalStatus
     * @example
     * // Get one MaritalStatus
     * const maritalStatus = await prisma.maritalStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaritalStatusFindUniqueArgs>(args: SelectSubset<T, MaritalStatusFindUniqueArgs<ExtArgs>>): Prisma__MaritalStatusClient<$Result.GetResult<Prisma.$MaritalStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MaritalStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaritalStatusFindUniqueOrThrowArgs} args - Arguments to find a MaritalStatus
     * @example
     * // Get one MaritalStatus
     * const maritalStatus = await prisma.maritalStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaritalStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, MaritalStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaritalStatusClient<$Result.GetResult<Prisma.$MaritalStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaritalStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaritalStatusFindFirstArgs} args - Arguments to find a MaritalStatus
     * @example
     * // Get one MaritalStatus
     * const maritalStatus = await prisma.maritalStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaritalStatusFindFirstArgs>(args?: SelectSubset<T, MaritalStatusFindFirstArgs<ExtArgs>>): Prisma__MaritalStatusClient<$Result.GetResult<Prisma.$MaritalStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaritalStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaritalStatusFindFirstOrThrowArgs} args - Arguments to find a MaritalStatus
     * @example
     * // Get one MaritalStatus
     * const maritalStatus = await prisma.maritalStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaritalStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, MaritalStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaritalStatusClient<$Result.GetResult<Prisma.$MaritalStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MaritalStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaritalStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaritalStatuses
     * const maritalStatuses = await prisma.maritalStatus.findMany()
     * 
     * // Get first 10 MaritalStatuses
     * const maritalStatuses = await prisma.maritalStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maritalStatusWithIdOnly = await prisma.maritalStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaritalStatusFindManyArgs>(args?: SelectSubset<T, MaritalStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaritalStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MaritalStatus.
     * @param {MaritalStatusCreateArgs} args - Arguments to create a MaritalStatus.
     * @example
     * // Create one MaritalStatus
     * const MaritalStatus = await prisma.maritalStatus.create({
     *   data: {
     *     // ... data to create a MaritalStatus
     *   }
     * })
     * 
     */
    create<T extends MaritalStatusCreateArgs>(args: SelectSubset<T, MaritalStatusCreateArgs<ExtArgs>>): Prisma__MaritalStatusClient<$Result.GetResult<Prisma.$MaritalStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MaritalStatuses.
     * @param {MaritalStatusCreateManyArgs} args - Arguments to create many MaritalStatuses.
     * @example
     * // Create many MaritalStatuses
     * const maritalStatus = await prisma.maritalStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaritalStatusCreateManyArgs>(args?: SelectSubset<T, MaritalStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MaritalStatus.
     * @param {MaritalStatusDeleteArgs} args - Arguments to delete one MaritalStatus.
     * @example
     * // Delete one MaritalStatus
     * const MaritalStatus = await prisma.maritalStatus.delete({
     *   where: {
     *     // ... filter to delete one MaritalStatus
     *   }
     * })
     * 
     */
    delete<T extends MaritalStatusDeleteArgs>(args: SelectSubset<T, MaritalStatusDeleteArgs<ExtArgs>>): Prisma__MaritalStatusClient<$Result.GetResult<Prisma.$MaritalStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MaritalStatus.
     * @param {MaritalStatusUpdateArgs} args - Arguments to update one MaritalStatus.
     * @example
     * // Update one MaritalStatus
     * const maritalStatus = await prisma.maritalStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaritalStatusUpdateArgs>(args: SelectSubset<T, MaritalStatusUpdateArgs<ExtArgs>>): Prisma__MaritalStatusClient<$Result.GetResult<Prisma.$MaritalStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MaritalStatuses.
     * @param {MaritalStatusDeleteManyArgs} args - Arguments to filter MaritalStatuses to delete.
     * @example
     * // Delete a few MaritalStatuses
     * const { count } = await prisma.maritalStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaritalStatusDeleteManyArgs>(args?: SelectSubset<T, MaritalStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaritalStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaritalStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaritalStatuses
     * const maritalStatus = await prisma.maritalStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaritalStatusUpdateManyArgs>(args: SelectSubset<T, MaritalStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MaritalStatus.
     * @param {MaritalStatusUpsertArgs} args - Arguments to update or create a MaritalStatus.
     * @example
     * // Update or create a MaritalStatus
     * const maritalStatus = await prisma.maritalStatus.upsert({
     *   create: {
     *     // ... data to create a MaritalStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaritalStatus we want to update
     *   }
     * })
     */
    upsert<T extends MaritalStatusUpsertArgs>(args: SelectSubset<T, MaritalStatusUpsertArgs<ExtArgs>>): Prisma__MaritalStatusClient<$Result.GetResult<Prisma.$MaritalStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MaritalStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaritalStatusCountArgs} args - Arguments to filter MaritalStatuses to count.
     * @example
     * // Count the number of MaritalStatuses
     * const count = await prisma.maritalStatus.count({
     *   where: {
     *     // ... the filter for the MaritalStatuses we want to count
     *   }
     * })
    **/
    count<T extends MaritalStatusCountArgs>(
      args?: Subset<T, MaritalStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaritalStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaritalStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaritalStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaritalStatusAggregateArgs>(args: Subset<T, MaritalStatusAggregateArgs>): Prisma.PrismaPromise<GetMaritalStatusAggregateType<T>>

    /**
     * Group by MaritalStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaritalStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaritalStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaritalStatusGroupByArgs['orderBy'] }
        : { orderBy?: MaritalStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaritalStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaritalStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaritalStatus model
   */
  readonly fields: MaritalStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaritalStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaritalStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employees<T extends MaritalStatus$employeesArgs<ExtArgs> = {}>(args?: Subset<T, MaritalStatus$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaritalStatus model
   */
  interface MaritalStatusFieldRefs {
    readonly id: FieldRef<"MaritalStatus", 'Int'>
    readonly status: FieldRef<"MaritalStatus", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MaritalStatus findUnique
   */
  export type MaritalStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatus
     */
    select?: MaritalStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaritalStatus
     */
    omit?: MaritalStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaritalStatusInclude<ExtArgs> | null
    /**
     * Filter, which MaritalStatus to fetch.
     */
    where: MaritalStatusWhereUniqueInput
  }

  /**
   * MaritalStatus findUniqueOrThrow
   */
  export type MaritalStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatus
     */
    select?: MaritalStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaritalStatus
     */
    omit?: MaritalStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaritalStatusInclude<ExtArgs> | null
    /**
     * Filter, which MaritalStatus to fetch.
     */
    where: MaritalStatusWhereUniqueInput
  }

  /**
   * MaritalStatus findFirst
   */
  export type MaritalStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatus
     */
    select?: MaritalStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaritalStatus
     */
    omit?: MaritalStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaritalStatusInclude<ExtArgs> | null
    /**
     * Filter, which MaritalStatus to fetch.
     */
    where?: MaritalStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaritalStatuses to fetch.
     */
    orderBy?: MaritalStatusOrderByWithRelationInput | MaritalStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaritalStatuses.
     */
    cursor?: MaritalStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaritalStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaritalStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaritalStatuses.
     */
    distinct?: MaritalStatusScalarFieldEnum | MaritalStatusScalarFieldEnum[]
  }

  /**
   * MaritalStatus findFirstOrThrow
   */
  export type MaritalStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatus
     */
    select?: MaritalStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaritalStatus
     */
    omit?: MaritalStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaritalStatusInclude<ExtArgs> | null
    /**
     * Filter, which MaritalStatus to fetch.
     */
    where?: MaritalStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaritalStatuses to fetch.
     */
    orderBy?: MaritalStatusOrderByWithRelationInput | MaritalStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaritalStatuses.
     */
    cursor?: MaritalStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaritalStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaritalStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaritalStatuses.
     */
    distinct?: MaritalStatusScalarFieldEnum | MaritalStatusScalarFieldEnum[]
  }

  /**
   * MaritalStatus findMany
   */
  export type MaritalStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatus
     */
    select?: MaritalStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaritalStatus
     */
    omit?: MaritalStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaritalStatusInclude<ExtArgs> | null
    /**
     * Filter, which MaritalStatuses to fetch.
     */
    where?: MaritalStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaritalStatuses to fetch.
     */
    orderBy?: MaritalStatusOrderByWithRelationInput | MaritalStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaritalStatuses.
     */
    cursor?: MaritalStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaritalStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaritalStatuses.
     */
    skip?: number
    distinct?: MaritalStatusScalarFieldEnum | MaritalStatusScalarFieldEnum[]
  }

  /**
   * MaritalStatus create
   */
  export type MaritalStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatus
     */
    select?: MaritalStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaritalStatus
     */
    omit?: MaritalStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaritalStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a MaritalStatus.
     */
    data: XOR<MaritalStatusCreateInput, MaritalStatusUncheckedCreateInput>
  }

  /**
   * MaritalStatus createMany
   */
  export type MaritalStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaritalStatuses.
     */
    data: MaritalStatusCreateManyInput | MaritalStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaritalStatus update
   */
  export type MaritalStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatus
     */
    select?: MaritalStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaritalStatus
     */
    omit?: MaritalStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaritalStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a MaritalStatus.
     */
    data: XOR<MaritalStatusUpdateInput, MaritalStatusUncheckedUpdateInput>
    /**
     * Choose, which MaritalStatus to update.
     */
    where: MaritalStatusWhereUniqueInput
  }

  /**
   * MaritalStatus updateMany
   */
  export type MaritalStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaritalStatuses.
     */
    data: XOR<MaritalStatusUpdateManyMutationInput, MaritalStatusUncheckedUpdateManyInput>
    /**
     * Filter which MaritalStatuses to update
     */
    where?: MaritalStatusWhereInput
    /**
     * Limit how many MaritalStatuses to update.
     */
    limit?: number
  }

  /**
   * MaritalStatus upsert
   */
  export type MaritalStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatus
     */
    select?: MaritalStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaritalStatus
     */
    omit?: MaritalStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaritalStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the MaritalStatus to update in case it exists.
     */
    where: MaritalStatusWhereUniqueInput
    /**
     * In case the MaritalStatus found by the `where` argument doesn't exist, create a new MaritalStatus with this data.
     */
    create: XOR<MaritalStatusCreateInput, MaritalStatusUncheckedCreateInput>
    /**
     * In case the MaritalStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaritalStatusUpdateInput, MaritalStatusUncheckedUpdateInput>
  }

  /**
   * MaritalStatus delete
   */
  export type MaritalStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatus
     */
    select?: MaritalStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaritalStatus
     */
    omit?: MaritalStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaritalStatusInclude<ExtArgs> | null
    /**
     * Filter which MaritalStatus to delete.
     */
    where: MaritalStatusWhereUniqueInput
  }

  /**
   * MaritalStatus deleteMany
   */
  export type MaritalStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaritalStatuses to delete
     */
    where?: MaritalStatusWhereInput
    /**
     * Limit how many MaritalStatuses to delete.
     */
    limit?: number
  }

  /**
   * MaritalStatus.employees
   */
  export type MaritalStatus$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * MaritalStatus without action
   */
  export type MaritalStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatus
     */
    select?: MaritalStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaritalStatus
     */
    omit?: MaritalStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaritalStatusInclude<ExtArgs> | null
  }


  /**
   * Model EmploymentType
   */

  export type AggregateEmploymentType = {
    _count: EmploymentTypeCountAggregateOutputType | null
    _avg: EmploymentTypeAvgAggregateOutputType | null
    _sum: EmploymentTypeSumAggregateOutputType | null
    _min: EmploymentTypeMinAggregateOutputType | null
    _max: EmploymentTypeMaxAggregateOutputType | null
  }

  export type EmploymentTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type EmploymentTypeSumAggregateOutputType = {
    id: number | null
  }

  export type EmploymentTypeMinAggregateOutputType = {
    id: number | null
    type: string | null
  }

  export type EmploymentTypeMaxAggregateOutputType = {
    id: number | null
    type: string | null
  }

  export type EmploymentTypeCountAggregateOutputType = {
    id: number
    type: number
    _all: number
  }


  export type EmploymentTypeAvgAggregateInputType = {
    id?: true
  }

  export type EmploymentTypeSumAggregateInputType = {
    id?: true
  }

  export type EmploymentTypeMinAggregateInputType = {
    id?: true
    type?: true
  }

  export type EmploymentTypeMaxAggregateInputType = {
    id?: true
    type?: true
  }

  export type EmploymentTypeCountAggregateInputType = {
    id?: true
    type?: true
    _all?: true
  }

  export type EmploymentTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmploymentType to aggregate.
     */
    where?: EmploymentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmploymentTypes to fetch.
     */
    orderBy?: EmploymentTypeOrderByWithRelationInput | EmploymentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmploymentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmploymentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmploymentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmploymentTypes
    **/
    _count?: true | EmploymentTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmploymentTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmploymentTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmploymentTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmploymentTypeMaxAggregateInputType
  }

  export type GetEmploymentTypeAggregateType<T extends EmploymentTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmploymentType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmploymentType[P]>
      : GetScalarType<T[P], AggregateEmploymentType[P]>
  }




  export type EmploymentTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmploymentTypeWhereInput
    orderBy?: EmploymentTypeOrderByWithAggregationInput | EmploymentTypeOrderByWithAggregationInput[]
    by: EmploymentTypeScalarFieldEnum[] | EmploymentTypeScalarFieldEnum
    having?: EmploymentTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmploymentTypeCountAggregateInputType | true
    _avg?: EmploymentTypeAvgAggregateInputType
    _sum?: EmploymentTypeSumAggregateInputType
    _min?: EmploymentTypeMinAggregateInputType
    _max?: EmploymentTypeMaxAggregateInputType
  }

  export type EmploymentTypeGroupByOutputType = {
    id: number
    type: string
    _count: EmploymentTypeCountAggregateOutputType | null
    _avg: EmploymentTypeAvgAggregateOutputType | null
    _sum: EmploymentTypeSumAggregateOutputType | null
    _min: EmploymentTypeMinAggregateOutputType | null
    _max: EmploymentTypeMaxAggregateOutputType | null
  }

  type GetEmploymentTypeGroupByPayload<T extends EmploymentTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmploymentTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmploymentTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmploymentTypeGroupByOutputType[P]>
            : GetScalarType<T[P], EmploymentTypeGroupByOutputType[P]>
        }
      >
    >


  export type EmploymentTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    employees?: boolean | EmploymentType$employeesArgs<ExtArgs>
    _count?: boolean | EmploymentTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employmentType"]>



  export type EmploymentTypeSelectScalar = {
    id?: boolean
    type?: boolean
  }

  export type EmploymentTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type", ExtArgs["result"]["employmentType"]>
  export type EmploymentTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | EmploymentType$employeesArgs<ExtArgs>
    _count?: boolean | EmploymentTypeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EmploymentTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmploymentType"
    objects: {
      employees: Prisma.$EmployeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
    }, ExtArgs["result"]["employmentType"]>
    composites: {}
  }

  type EmploymentTypeGetPayload<S extends boolean | null | undefined | EmploymentTypeDefaultArgs> = $Result.GetResult<Prisma.$EmploymentTypePayload, S>

  type EmploymentTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmploymentTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmploymentTypeCountAggregateInputType | true
    }

  export interface EmploymentTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmploymentType'], meta: { name: 'EmploymentType' } }
    /**
     * Find zero or one EmploymentType that matches the filter.
     * @param {EmploymentTypeFindUniqueArgs} args - Arguments to find a EmploymentType
     * @example
     * // Get one EmploymentType
     * const employmentType = await prisma.employmentType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmploymentTypeFindUniqueArgs>(args: SelectSubset<T, EmploymentTypeFindUniqueArgs<ExtArgs>>): Prisma__EmploymentTypeClient<$Result.GetResult<Prisma.$EmploymentTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmploymentType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmploymentTypeFindUniqueOrThrowArgs} args - Arguments to find a EmploymentType
     * @example
     * // Get one EmploymentType
     * const employmentType = await prisma.employmentType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmploymentTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmploymentTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmploymentTypeClient<$Result.GetResult<Prisma.$EmploymentTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmploymentType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentTypeFindFirstArgs} args - Arguments to find a EmploymentType
     * @example
     * // Get one EmploymentType
     * const employmentType = await prisma.employmentType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmploymentTypeFindFirstArgs>(args?: SelectSubset<T, EmploymentTypeFindFirstArgs<ExtArgs>>): Prisma__EmploymentTypeClient<$Result.GetResult<Prisma.$EmploymentTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmploymentType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentTypeFindFirstOrThrowArgs} args - Arguments to find a EmploymentType
     * @example
     * // Get one EmploymentType
     * const employmentType = await prisma.employmentType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmploymentTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmploymentTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmploymentTypeClient<$Result.GetResult<Prisma.$EmploymentTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmploymentTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmploymentTypes
     * const employmentTypes = await prisma.employmentType.findMany()
     * 
     * // Get first 10 EmploymentTypes
     * const employmentTypes = await prisma.employmentType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employmentTypeWithIdOnly = await prisma.employmentType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmploymentTypeFindManyArgs>(args?: SelectSubset<T, EmploymentTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmploymentTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmploymentType.
     * @param {EmploymentTypeCreateArgs} args - Arguments to create a EmploymentType.
     * @example
     * // Create one EmploymentType
     * const EmploymentType = await prisma.employmentType.create({
     *   data: {
     *     // ... data to create a EmploymentType
     *   }
     * })
     * 
     */
    create<T extends EmploymentTypeCreateArgs>(args: SelectSubset<T, EmploymentTypeCreateArgs<ExtArgs>>): Prisma__EmploymentTypeClient<$Result.GetResult<Prisma.$EmploymentTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmploymentTypes.
     * @param {EmploymentTypeCreateManyArgs} args - Arguments to create many EmploymentTypes.
     * @example
     * // Create many EmploymentTypes
     * const employmentType = await prisma.employmentType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmploymentTypeCreateManyArgs>(args?: SelectSubset<T, EmploymentTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmploymentType.
     * @param {EmploymentTypeDeleteArgs} args - Arguments to delete one EmploymentType.
     * @example
     * // Delete one EmploymentType
     * const EmploymentType = await prisma.employmentType.delete({
     *   where: {
     *     // ... filter to delete one EmploymentType
     *   }
     * })
     * 
     */
    delete<T extends EmploymentTypeDeleteArgs>(args: SelectSubset<T, EmploymentTypeDeleteArgs<ExtArgs>>): Prisma__EmploymentTypeClient<$Result.GetResult<Prisma.$EmploymentTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmploymentType.
     * @param {EmploymentTypeUpdateArgs} args - Arguments to update one EmploymentType.
     * @example
     * // Update one EmploymentType
     * const employmentType = await prisma.employmentType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmploymentTypeUpdateArgs>(args: SelectSubset<T, EmploymentTypeUpdateArgs<ExtArgs>>): Prisma__EmploymentTypeClient<$Result.GetResult<Prisma.$EmploymentTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmploymentTypes.
     * @param {EmploymentTypeDeleteManyArgs} args - Arguments to filter EmploymentTypes to delete.
     * @example
     * // Delete a few EmploymentTypes
     * const { count } = await prisma.employmentType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmploymentTypeDeleteManyArgs>(args?: SelectSubset<T, EmploymentTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmploymentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmploymentTypes
     * const employmentType = await prisma.employmentType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmploymentTypeUpdateManyArgs>(args: SelectSubset<T, EmploymentTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmploymentType.
     * @param {EmploymentTypeUpsertArgs} args - Arguments to update or create a EmploymentType.
     * @example
     * // Update or create a EmploymentType
     * const employmentType = await prisma.employmentType.upsert({
     *   create: {
     *     // ... data to create a EmploymentType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmploymentType we want to update
     *   }
     * })
     */
    upsert<T extends EmploymentTypeUpsertArgs>(args: SelectSubset<T, EmploymentTypeUpsertArgs<ExtArgs>>): Prisma__EmploymentTypeClient<$Result.GetResult<Prisma.$EmploymentTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmploymentTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentTypeCountArgs} args - Arguments to filter EmploymentTypes to count.
     * @example
     * // Count the number of EmploymentTypes
     * const count = await prisma.employmentType.count({
     *   where: {
     *     // ... the filter for the EmploymentTypes we want to count
     *   }
     * })
    **/
    count<T extends EmploymentTypeCountArgs>(
      args?: Subset<T, EmploymentTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmploymentTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmploymentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmploymentTypeAggregateArgs>(args: Subset<T, EmploymentTypeAggregateArgs>): Prisma.PrismaPromise<GetEmploymentTypeAggregateType<T>>

    /**
     * Group by EmploymentType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmploymentTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmploymentTypeGroupByArgs['orderBy'] }
        : { orderBy?: EmploymentTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmploymentTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmploymentTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmploymentType model
   */
  readonly fields: EmploymentTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmploymentType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmploymentTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employees<T extends EmploymentType$employeesArgs<ExtArgs> = {}>(args?: Subset<T, EmploymentType$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmploymentType model
   */
  interface EmploymentTypeFieldRefs {
    readonly id: FieldRef<"EmploymentType", 'Int'>
    readonly type: FieldRef<"EmploymentType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmploymentType findUnique
   */
  export type EmploymentTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentType
     */
    select?: EmploymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentType
     */
    omit?: EmploymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentTypeInclude<ExtArgs> | null
    /**
     * Filter, which EmploymentType to fetch.
     */
    where: EmploymentTypeWhereUniqueInput
  }

  /**
   * EmploymentType findUniqueOrThrow
   */
  export type EmploymentTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentType
     */
    select?: EmploymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentType
     */
    omit?: EmploymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentTypeInclude<ExtArgs> | null
    /**
     * Filter, which EmploymentType to fetch.
     */
    where: EmploymentTypeWhereUniqueInput
  }

  /**
   * EmploymentType findFirst
   */
  export type EmploymentTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentType
     */
    select?: EmploymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentType
     */
    omit?: EmploymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentTypeInclude<ExtArgs> | null
    /**
     * Filter, which EmploymentType to fetch.
     */
    where?: EmploymentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmploymentTypes to fetch.
     */
    orderBy?: EmploymentTypeOrderByWithRelationInput | EmploymentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmploymentTypes.
     */
    cursor?: EmploymentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmploymentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmploymentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmploymentTypes.
     */
    distinct?: EmploymentTypeScalarFieldEnum | EmploymentTypeScalarFieldEnum[]
  }

  /**
   * EmploymentType findFirstOrThrow
   */
  export type EmploymentTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentType
     */
    select?: EmploymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentType
     */
    omit?: EmploymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentTypeInclude<ExtArgs> | null
    /**
     * Filter, which EmploymentType to fetch.
     */
    where?: EmploymentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmploymentTypes to fetch.
     */
    orderBy?: EmploymentTypeOrderByWithRelationInput | EmploymentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmploymentTypes.
     */
    cursor?: EmploymentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmploymentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmploymentTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmploymentTypes.
     */
    distinct?: EmploymentTypeScalarFieldEnum | EmploymentTypeScalarFieldEnum[]
  }

  /**
   * EmploymentType findMany
   */
  export type EmploymentTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentType
     */
    select?: EmploymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentType
     */
    omit?: EmploymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentTypeInclude<ExtArgs> | null
    /**
     * Filter, which EmploymentTypes to fetch.
     */
    where?: EmploymentTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmploymentTypes to fetch.
     */
    orderBy?: EmploymentTypeOrderByWithRelationInput | EmploymentTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmploymentTypes.
     */
    cursor?: EmploymentTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmploymentTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmploymentTypes.
     */
    skip?: number
    distinct?: EmploymentTypeScalarFieldEnum | EmploymentTypeScalarFieldEnum[]
  }

  /**
   * EmploymentType create
   */
  export type EmploymentTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentType
     */
    select?: EmploymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentType
     */
    omit?: EmploymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a EmploymentType.
     */
    data: XOR<EmploymentTypeCreateInput, EmploymentTypeUncheckedCreateInput>
  }

  /**
   * EmploymentType createMany
   */
  export type EmploymentTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmploymentTypes.
     */
    data: EmploymentTypeCreateManyInput | EmploymentTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmploymentType update
   */
  export type EmploymentTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentType
     */
    select?: EmploymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentType
     */
    omit?: EmploymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a EmploymentType.
     */
    data: XOR<EmploymentTypeUpdateInput, EmploymentTypeUncheckedUpdateInput>
    /**
     * Choose, which EmploymentType to update.
     */
    where: EmploymentTypeWhereUniqueInput
  }

  /**
   * EmploymentType updateMany
   */
  export type EmploymentTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmploymentTypes.
     */
    data: XOR<EmploymentTypeUpdateManyMutationInput, EmploymentTypeUncheckedUpdateManyInput>
    /**
     * Filter which EmploymentTypes to update
     */
    where?: EmploymentTypeWhereInput
    /**
     * Limit how many EmploymentTypes to update.
     */
    limit?: number
  }

  /**
   * EmploymentType upsert
   */
  export type EmploymentTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentType
     */
    select?: EmploymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentType
     */
    omit?: EmploymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the EmploymentType to update in case it exists.
     */
    where: EmploymentTypeWhereUniqueInput
    /**
     * In case the EmploymentType found by the `where` argument doesn't exist, create a new EmploymentType with this data.
     */
    create: XOR<EmploymentTypeCreateInput, EmploymentTypeUncheckedCreateInput>
    /**
     * In case the EmploymentType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmploymentTypeUpdateInput, EmploymentTypeUncheckedUpdateInput>
  }

  /**
   * EmploymentType delete
   */
  export type EmploymentTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentType
     */
    select?: EmploymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentType
     */
    omit?: EmploymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentTypeInclude<ExtArgs> | null
    /**
     * Filter which EmploymentType to delete.
     */
    where: EmploymentTypeWhereUniqueInput
  }

  /**
   * EmploymentType deleteMany
   */
  export type EmploymentTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmploymentTypes to delete
     */
    where?: EmploymentTypeWhereInput
    /**
     * Limit how many EmploymentTypes to delete.
     */
    limit?: number
  }

  /**
   * EmploymentType.employees
   */
  export type EmploymentType$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * EmploymentType without action
   */
  export type EmploymentTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentType
     */
    select?: EmploymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentType
     */
    omit?: EmploymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentTypeInclude<ExtArgs> | null
  }


  /**
   * Model JobStatus
   */

  export type AggregateJobStatus = {
    _count: JobStatusCountAggregateOutputType | null
    _avg: JobStatusAvgAggregateOutputType | null
    _sum: JobStatusSumAggregateOutputType | null
    _min: JobStatusMinAggregateOutputType | null
    _max: JobStatusMaxAggregateOutputType | null
  }

  export type JobStatusAvgAggregateOutputType = {
    id: number | null
  }

  export type JobStatusSumAggregateOutputType = {
    id: number | null
  }

  export type JobStatusMinAggregateOutputType = {
    id: number | null
    status: string | null
  }

  export type JobStatusMaxAggregateOutputType = {
    id: number | null
    status: string | null
  }

  export type JobStatusCountAggregateOutputType = {
    id: number
    status: number
    _all: number
  }


  export type JobStatusAvgAggregateInputType = {
    id?: true
  }

  export type JobStatusSumAggregateInputType = {
    id?: true
  }

  export type JobStatusMinAggregateInputType = {
    id?: true
    status?: true
  }

  export type JobStatusMaxAggregateInputType = {
    id?: true
    status?: true
  }

  export type JobStatusCountAggregateInputType = {
    id?: true
    status?: true
    _all?: true
  }

  export type JobStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobStatus to aggregate.
     */
    where?: JobStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobStatuses to fetch.
     */
    orderBy?: JobStatusOrderByWithRelationInput | JobStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobStatuses
    **/
    _count?: true | JobStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobStatusMaxAggregateInputType
  }

  export type GetJobStatusAggregateType<T extends JobStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateJobStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobStatus[P]>
      : GetScalarType<T[P], AggregateJobStatus[P]>
  }




  export type JobStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobStatusWhereInput
    orderBy?: JobStatusOrderByWithAggregationInput | JobStatusOrderByWithAggregationInput[]
    by: JobStatusScalarFieldEnum[] | JobStatusScalarFieldEnum
    having?: JobStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobStatusCountAggregateInputType | true
    _avg?: JobStatusAvgAggregateInputType
    _sum?: JobStatusSumAggregateInputType
    _min?: JobStatusMinAggregateInputType
    _max?: JobStatusMaxAggregateInputType
  }

  export type JobStatusGroupByOutputType = {
    id: number
    status: string
    _count: JobStatusCountAggregateOutputType | null
    _avg: JobStatusAvgAggregateOutputType | null
    _sum: JobStatusSumAggregateOutputType | null
    _min: JobStatusMinAggregateOutputType | null
    _max: JobStatusMaxAggregateOutputType | null
  }

  type GetJobStatusGroupByPayload<T extends JobStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobStatusGroupByOutputType[P]>
            : GetScalarType<T[P], JobStatusGroupByOutputType[P]>
        }
      >
    >


  export type JobStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    employees?: boolean | JobStatus$employeesArgs<ExtArgs>
    _count?: boolean | JobStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobStatus"]>



  export type JobStatusSelectScalar = {
    id?: boolean
    status?: boolean
  }

  export type JobStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status", ExtArgs["result"]["jobStatus"]>
  export type JobStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | JobStatus$employeesArgs<ExtArgs>
    _count?: boolean | JobStatusCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $JobStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobStatus"
    objects: {
      employees: Prisma.$EmployeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      status: string
    }, ExtArgs["result"]["jobStatus"]>
    composites: {}
  }

  type JobStatusGetPayload<S extends boolean | null | undefined | JobStatusDefaultArgs> = $Result.GetResult<Prisma.$JobStatusPayload, S>

  type JobStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobStatusCountAggregateInputType | true
    }

  export interface JobStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobStatus'], meta: { name: 'JobStatus' } }
    /**
     * Find zero or one JobStatus that matches the filter.
     * @param {JobStatusFindUniqueArgs} args - Arguments to find a JobStatus
     * @example
     * // Get one JobStatus
     * const jobStatus = await prisma.jobStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobStatusFindUniqueArgs>(args: SelectSubset<T, JobStatusFindUniqueArgs<ExtArgs>>): Prisma__JobStatusClient<$Result.GetResult<Prisma.$JobStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobStatusFindUniqueOrThrowArgs} args - Arguments to find a JobStatus
     * @example
     * // Get one JobStatus
     * const jobStatus = await prisma.jobStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, JobStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobStatusClient<$Result.GetResult<Prisma.$JobStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobStatusFindFirstArgs} args - Arguments to find a JobStatus
     * @example
     * // Get one JobStatus
     * const jobStatus = await prisma.jobStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobStatusFindFirstArgs>(args?: SelectSubset<T, JobStatusFindFirstArgs<ExtArgs>>): Prisma__JobStatusClient<$Result.GetResult<Prisma.$JobStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobStatusFindFirstOrThrowArgs} args - Arguments to find a JobStatus
     * @example
     * // Get one JobStatus
     * const jobStatus = await prisma.jobStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, JobStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobStatusClient<$Result.GetResult<Prisma.$JobStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobStatuses
     * const jobStatuses = await prisma.jobStatus.findMany()
     * 
     * // Get first 10 JobStatuses
     * const jobStatuses = await prisma.jobStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobStatusWithIdOnly = await prisma.jobStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobStatusFindManyArgs>(args?: SelectSubset<T, JobStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobStatus.
     * @param {JobStatusCreateArgs} args - Arguments to create a JobStatus.
     * @example
     * // Create one JobStatus
     * const JobStatus = await prisma.jobStatus.create({
     *   data: {
     *     // ... data to create a JobStatus
     *   }
     * })
     * 
     */
    create<T extends JobStatusCreateArgs>(args: SelectSubset<T, JobStatusCreateArgs<ExtArgs>>): Prisma__JobStatusClient<$Result.GetResult<Prisma.$JobStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobStatuses.
     * @param {JobStatusCreateManyArgs} args - Arguments to create many JobStatuses.
     * @example
     * // Create many JobStatuses
     * const jobStatus = await prisma.jobStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobStatusCreateManyArgs>(args?: SelectSubset<T, JobStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a JobStatus.
     * @param {JobStatusDeleteArgs} args - Arguments to delete one JobStatus.
     * @example
     * // Delete one JobStatus
     * const JobStatus = await prisma.jobStatus.delete({
     *   where: {
     *     // ... filter to delete one JobStatus
     *   }
     * })
     * 
     */
    delete<T extends JobStatusDeleteArgs>(args: SelectSubset<T, JobStatusDeleteArgs<ExtArgs>>): Prisma__JobStatusClient<$Result.GetResult<Prisma.$JobStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobStatus.
     * @param {JobStatusUpdateArgs} args - Arguments to update one JobStatus.
     * @example
     * // Update one JobStatus
     * const jobStatus = await prisma.jobStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobStatusUpdateArgs>(args: SelectSubset<T, JobStatusUpdateArgs<ExtArgs>>): Prisma__JobStatusClient<$Result.GetResult<Prisma.$JobStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobStatuses.
     * @param {JobStatusDeleteManyArgs} args - Arguments to filter JobStatuses to delete.
     * @example
     * // Delete a few JobStatuses
     * const { count } = await prisma.jobStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobStatusDeleteManyArgs>(args?: SelectSubset<T, JobStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobStatuses
     * const jobStatus = await prisma.jobStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobStatusUpdateManyArgs>(args: SelectSubset<T, JobStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JobStatus.
     * @param {JobStatusUpsertArgs} args - Arguments to update or create a JobStatus.
     * @example
     * // Update or create a JobStatus
     * const jobStatus = await prisma.jobStatus.upsert({
     *   create: {
     *     // ... data to create a JobStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobStatus we want to update
     *   }
     * })
     */
    upsert<T extends JobStatusUpsertArgs>(args: SelectSubset<T, JobStatusUpsertArgs<ExtArgs>>): Prisma__JobStatusClient<$Result.GetResult<Prisma.$JobStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobStatusCountArgs} args - Arguments to filter JobStatuses to count.
     * @example
     * // Count the number of JobStatuses
     * const count = await prisma.jobStatus.count({
     *   where: {
     *     // ... the filter for the JobStatuses we want to count
     *   }
     * })
    **/
    count<T extends JobStatusCountArgs>(
      args?: Subset<T, JobStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobStatusAggregateArgs>(args: Subset<T, JobStatusAggregateArgs>): Prisma.PrismaPromise<GetJobStatusAggregateType<T>>

    /**
     * Group by JobStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobStatusGroupByArgs['orderBy'] }
        : { orderBy?: JobStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobStatus model
   */
  readonly fields: JobStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employees<T extends JobStatus$employeesArgs<ExtArgs> = {}>(args?: Subset<T, JobStatus$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobStatus model
   */
  interface JobStatusFieldRefs {
    readonly id: FieldRef<"JobStatus", 'Int'>
    readonly status: FieldRef<"JobStatus", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JobStatus findUnique
   */
  export type JobStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobStatus
     */
    select?: JobStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobStatus
     */
    omit?: JobStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobStatusInclude<ExtArgs> | null
    /**
     * Filter, which JobStatus to fetch.
     */
    where: JobStatusWhereUniqueInput
  }

  /**
   * JobStatus findUniqueOrThrow
   */
  export type JobStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobStatus
     */
    select?: JobStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobStatus
     */
    omit?: JobStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobStatusInclude<ExtArgs> | null
    /**
     * Filter, which JobStatus to fetch.
     */
    where: JobStatusWhereUniqueInput
  }

  /**
   * JobStatus findFirst
   */
  export type JobStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobStatus
     */
    select?: JobStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobStatus
     */
    omit?: JobStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobStatusInclude<ExtArgs> | null
    /**
     * Filter, which JobStatus to fetch.
     */
    where?: JobStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobStatuses to fetch.
     */
    orderBy?: JobStatusOrderByWithRelationInput | JobStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobStatuses.
     */
    cursor?: JobStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobStatuses.
     */
    distinct?: JobStatusScalarFieldEnum | JobStatusScalarFieldEnum[]
  }

  /**
   * JobStatus findFirstOrThrow
   */
  export type JobStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobStatus
     */
    select?: JobStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobStatus
     */
    omit?: JobStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobStatusInclude<ExtArgs> | null
    /**
     * Filter, which JobStatus to fetch.
     */
    where?: JobStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobStatuses to fetch.
     */
    orderBy?: JobStatusOrderByWithRelationInput | JobStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobStatuses.
     */
    cursor?: JobStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobStatuses.
     */
    distinct?: JobStatusScalarFieldEnum | JobStatusScalarFieldEnum[]
  }

  /**
   * JobStatus findMany
   */
  export type JobStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobStatus
     */
    select?: JobStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobStatus
     */
    omit?: JobStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobStatusInclude<ExtArgs> | null
    /**
     * Filter, which JobStatuses to fetch.
     */
    where?: JobStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobStatuses to fetch.
     */
    orderBy?: JobStatusOrderByWithRelationInput | JobStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobStatuses.
     */
    cursor?: JobStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobStatuses.
     */
    skip?: number
    distinct?: JobStatusScalarFieldEnum | JobStatusScalarFieldEnum[]
  }

  /**
   * JobStatus create
   */
  export type JobStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobStatus
     */
    select?: JobStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobStatus
     */
    omit?: JobStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a JobStatus.
     */
    data: XOR<JobStatusCreateInput, JobStatusUncheckedCreateInput>
  }

  /**
   * JobStatus createMany
   */
  export type JobStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobStatuses.
     */
    data: JobStatusCreateManyInput | JobStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobStatus update
   */
  export type JobStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobStatus
     */
    select?: JobStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobStatus
     */
    omit?: JobStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a JobStatus.
     */
    data: XOR<JobStatusUpdateInput, JobStatusUncheckedUpdateInput>
    /**
     * Choose, which JobStatus to update.
     */
    where: JobStatusWhereUniqueInput
  }

  /**
   * JobStatus updateMany
   */
  export type JobStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobStatuses.
     */
    data: XOR<JobStatusUpdateManyMutationInput, JobStatusUncheckedUpdateManyInput>
    /**
     * Filter which JobStatuses to update
     */
    where?: JobStatusWhereInput
    /**
     * Limit how many JobStatuses to update.
     */
    limit?: number
  }

  /**
   * JobStatus upsert
   */
  export type JobStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobStatus
     */
    select?: JobStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobStatus
     */
    omit?: JobStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the JobStatus to update in case it exists.
     */
    where: JobStatusWhereUniqueInput
    /**
     * In case the JobStatus found by the `where` argument doesn't exist, create a new JobStatus with this data.
     */
    create: XOR<JobStatusCreateInput, JobStatusUncheckedCreateInput>
    /**
     * In case the JobStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobStatusUpdateInput, JobStatusUncheckedUpdateInput>
  }

  /**
   * JobStatus delete
   */
  export type JobStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobStatus
     */
    select?: JobStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobStatus
     */
    omit?: JobStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobStatusInclude<ExtArgs> | null
    /**
     * Filter which JobStatus to delete.
     */
    where: JobStatusWhereUniqueInput
  }

  /**
   * JobStatus deleteMany
   */
  export type JobStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobStatuses to delete
     */
    where?: JobStatusWhereInput
    /**
     * Limit how many JobStatuses to delete.
     */
    limit?: number
  }

  /**
   * JobStatus.employees
   */
  export type JobStatus$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * JobStatus without action
   */
  export type JobStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobStatus
     */
    select?: JobStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobStatus
     */
    omit?: JobStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobStatusInclude<ExtArgs> | null
  }


  /**
   * Model AgreementStatus
   */

  export type AggregateAgreementStatus = {
    _count: AgreementStatusCountAggregateOutputType | null
    _avg: AgreementStatusAvgAggregateOutputType | null
    _sum: AgreementStatusSumAggregateOutputType | null
    _min: AgreementStatusMinAggregateOutputType | null
    _max: AgreementStatusMaxAggregateOutputType | null
  }

  export type AgreementStatusAvgAggregateOutputType = {
    id: number | null
  }

  export type AgreementStatusSumAggregateOutputType = {
    id: number | null
  }

  export type AgreementStatusMinAggregateOutputType = {
    id: number | null
    status: string | null
  }

  export type AgreementStatusMaxAggregateOutputType = {
    id: number | null
    status: string | null
  }

  export type AgreementStatusCountAggregateOutputType = {
    id: number
    status: number
    _all: number
  }


  export type AgreementStatusAvgAggregateInputType = {
    id?: true
  }

  export type AgreementStatusSumAggregateInputType = {
    id?: true
  }

  export type AgreementStatusMinAggregateInputType = {
    id?: true
    status?: true
  }

  export type AgreementStatusMaxAggregateInputType = {
    id?: true
    status?: true
  }

  export type AgreementStatusCountAggregateInputType = {
    id?: true
    status?: true
    _all?: true
  }

  export type AgreementStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgreementStatus to aggregate.
     */
    where?: AgreementStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgreementStatuses to fetch.
     */
    orderBy?: AgreementStatusOrderByWithRelationInput | AgreementStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgreementStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgreementStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgreementStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgreementStatuses
    **/
    _count?: true | AgreementStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgreementStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgreementStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgreementStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgreementStatusMaxAggregateInputType
  }

  export type GetAgreementStatusAggregateType<T extends AgreementStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateAgreementStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgreementStatus[P]>
      : GetScalarType<T[P], AggregateAgreementStatus[P]>
  }




  export type AgreementStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgreementStatusWhereInput
    orderBy?: AgreementStatusOrderByWithAggregationInput | AgreementStatusOrderByWithAggregationInput[]
    by: AgreementStatusScalarFieldEnum[] | AgreementStatusScalarFieldEnum
    having?: AgreementStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgreementStatusCountAggregateInputType | true
    _avg?: AgreementStatusAvgAggregateInputType
    _sum?: AgreementStatusSumAggregateInputType
    _min?: AgreementStatusMinAggregateInputType
    _max?: AgreementStatusMaxAggregateInputType
  }

  export type AgreementStatusGroupByOutputType = {
    id: number
    status: string
    _count: AgreementStatusCountAggregateOutputType | null
    _avg: AgreementStatusAvgAggregateOutputType | null
    _sum: AgreementStatusSumAggregateOutputType | null
    _min: AgreementStatusMinAggregateOutputType | null
    _max: AgreementStatusMaxAggregateOutputType | null
  }

  type GetAgreementStatusGroupByPayload<T extends AgreementStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgreementStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgreementStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgreementStatusGroupByOutputType[P]>
            : GetScalarType<T[P], AgreementStatusGroupByOutputType[P]>
        }
      >
    >


  export type AgreementStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    employees?: boolean | AgreementStatus$employeesArgs<ExtArgs>
    _count?: boolean | AgreementStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agreementStatus"]>



  export type AgreementStatusSelectScalar = {
    id?: boolean
    status?: boolean
  }

  export type AgreementStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status", ExtArgs["result"]["agreementStatus"]>
  export type AgreementStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | AgreementStatus$employeesArgs<ExtArgs>
    _count?: boolean | AgreementStatusCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AgreementStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgreementStatus"
    objects: {
      employees: Prisma.$EmployeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      status: string
    }, ExtArgs["result"]["agreementStatus"]>
    composites: {}
  }

  type AgreementStatusGetPayload<S extends boolean | null | undefined | AgreementStatusDefaultArgs> = $Result.GetResult<Prisma.$AgreementStatusPayload, S>

  type AgreementStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgreementStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgreementStatusCountAggregateInputType | true
    }

  export interface AgreementStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgreementStatus'], meta: { name: 'AgreementStatus' } }
    /**
     * Find zero or one AgreementStatus that matches the filter.
     * @param {AgreementStatusFindUniqueArgs} args - Arguments to find a AgreementStatus
     * @example
     * // Get one AgreementStatus
     * const agreementStatus = await prisma.agreementStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgreementStatusFindUniqueArgs>(args: SelectSubset<T, AgreementStatusFindUniqueArgs<ExtArgs>>): Prisma__AgreementStatusClient<$Result.GetResult<Prisma.$AgreementStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgreementStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgreementStatusFindUniqueOrThrowArgs} args - Arguments to find a AgreementStatus
     * @example
     * // Get one AgreementStatus
     * const agreementStatus = await prisma.agreementStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgreementStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, AgreementStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgreementStatusClient<$Result.GetResult<Prisma.$AgreementStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgreementStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementStatusFindFirstArgs} args - Arguments to find a AgreementStatus
     * @example
     * // Get one AgreementStatus
     * const agreementStatus = await prisma.agreementStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgreementStatusFindFirstArgs>(args?: SelectSubset<T, AgreementStatusFindFirstArgs<ExtArgs>>): Prisma__AgreementStatusClient<$Result.GetResult<Prisma.$AgreementStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgreementStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementStatusFindFirstOrThrowArgs} args - Arguments to find a AgreementStatus
     * @example
     * // Get one AgreementStatus
     * const agreementStatus = await prisma.agreementStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgreementStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, AgreementStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgreementStatusClient<$Result.GetResult<Prisma.$AgreementStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgreementStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgreementStatuses
     * const agreementStatuses = await prisma.agreementStatus.findMany()
     * 
     * // Get first 10 AgreementStatuses
     * const agreementStatuses = await prisma.agreementStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agreementStatusWithIdOnly = await prisma.agreementStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgreementStatusFindManyArgs>(args?: SelectSubset<T, AgreementStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgreementStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgreementStatus.
     * @param {AgreementStatusCreateArgs} args - Arguments to create a AgreementStatus.
     * @example
     * // Create one AgreementStatus
     * const AgreementStatus = await prisma.agreementStatus.create({
     *   data: {
     *     // ... data to create a AgreementStatus
     *   }
     * })
     * 
     */
    create<T extends AgreementStatusCreateArgs>(args: SelectSubset<T, AgreementStatusCreateArgs<ExtArgs>>): Prisma__AgreementStatusClient<$Result.GetResult<Prisma.$AgreementStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgreementStatuses.
     * @param {AgreementStatusCreateManyArgs} args - Arguments to create many AgreementStatuses.
     * @example
     * // Create many AgreementStatuses
     * const agreementStatus = await prisma.agreementStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgreementStatusCreateManyArgs>(args?: SelectSubset<T, AgreementStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AgreementStatus.
     * @param {AgreementStatusDeleteArgs} args - Arguments to delete one AgreementStatus.
     * @example
     * // Delete one AgreementStatus
     * const AgreementStatus = await prisma.agreementStatus.delete({
     *   where: {
     *     // ... filter to delete one AgreementStatus
     *   }
     * })
     * 
     */
    delete<T extends AgreementStatusDeleteArgs>(args: SelectSubset<T, AgreementStatusDeleteArgs<ExtArgs>>): Prisma__AgreementStatusClient<$Result.GetResult<Prisma.$AgreementStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgreementStatus.
     * @param {AgreementStatusUpdateArgs} args - Arguments to update one AgreementStatus.
     * @example
     * // Update one AgreementStatus
     * const agreementStatus = await prisma.agreementStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgreementStatusUpdateArgs>(args: SelectSubset<T, AgreementStatusUpdateArgs<ExtArgs>>): Prisma__AgreementStatusClient<$Result.GetResult<Prisma.$AgreementStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgreementStatuses.
     * @param {AgreementStatusDeleteManyArgs} args - Arguments to filter AgreementStatuses to delete.
     * @example
     * // Delete a few AgreementStatuses
     * const { count } = await prisma.agreementStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgreementStatusDeleteManyArgs>(args?: SelectSubset<T, AgreementStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgreementStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgreementStatuses
     * const agreementStatus = await prisma.agreementStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgreementStatusUpdateManyArgs>(args: SelectSubset<T, AgreementStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AgreementStatus.
     * @param {AgreementStatusUpsertArgs} args - Arguments to update or create a AgreementStatus.
     * @example
     * // Update or create a AgreementStatus
     * const agreementStatus = await prisma.agreementStatus.upsert({
     *   create: {
     *     // ... data to create a AgreementStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgreementStatus we want to update
     *   }
     * })
     */
    upsert<T extends AgreementStatusUpsertArgs>(args: SelectSubset<T, AgreementStatusUpsertArgs<ExtArgs>>): Prisma__AgreementStatusClient<$Result.GetResult<Prisma.$AgreementStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgreementStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementStatusCountArgs} args - Arguments to filter AgreementStatuses to count.
     * @example
     * // Count the number of AgreementStatuses
     * const count = await prisma.agreementStatus.count({
     *   where: {
     *     // ... the filter for the AgreementStatuses we want to count
     *   }
     * })
    **/
    count<T extends AgreementStatusCountArgs>(
      args?: Subset<T, AgreementStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgreementStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgreementStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgreementStatusAggregateArgs>(args: Subset<T, AgreementStatusAggregateArgs>): Prisma.PrismaPromise<GetAgreementStatusAggregateType<T>>

    /**
     * Group by AgreementStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgreementStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgreementStatusGroupByArgs['orderBy'] }
        : { orderBy?: AgreementStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgreementStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgreementStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgreementStatus model
   */
  readonly fields: AgreementStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgreementStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgreementStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employees<T extends AgreementStatus$employeesArgs<ExtArgs> = {}>(args?: Subset<T, AgreementStatus$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgreementStatus model
   */
  interface AgreementStatusFieldRefs {
    readonly id: FieldRef<"AgreementStatus", 'Int'>
    readonly status: FieldRef<"AgreementStatus", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AgreementStatus findUnique
   */
  export type AgreementStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementStatus
     */
    select?: AgreementStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgreementStatus
     */
    omit?: AgreementStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementStatusInclude<ExtArgs> | null
    /**
     * Filter, which AgreementStatus to fetch.
     */
    where: AgreementStatusWhereUniqueInput
  }

  /**
   * AgreementStatus findUniqueOrThrow
   */
  export type AgreementStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementStatus
     */
    select?: AgreementStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgreementStatus
     */
    omit?: AgreementStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementStatusInclude<ExtArgs> | null
    /**
     * Filter, which AgreementStatus to fetch.
     */
    where: AgreementStatusWhereUniqueInput
  }

  /**
   * AgreementStatus findFirst
   */
  export type AgreementStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementStatus
     */
    select?: AgreementStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgreementStatus
     */
    omit?: AgreementStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementStatusInclude<ExtArgs> | null
    /**
     * Filter, which AgreementStatus to fetch.
     */
    where?: AgreementStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgreementStatuses to fetch.
     */
    orderBy?: AgreementStatusOrderByWithRelationInput | AgreementStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgreementStatuses.
     */
    cursor?: AgreementStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgreementStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgreementStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgreementStatuses.
     */
    distinct?: AgreementStatusScalarFieldEnum | AgreementStatusScalarFieldEnum[]
  }

  /**
   * AgreementStatus findFirstOrThrow
   */
  export type AgreementStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementStatus
     */
    select?: AgreementStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgreementStatus
     */
    omit?: AgreementStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementStatusInclude<ExtArgs> | null
    /**
     * Filter, which AgreementStatus to fetch.
     */
    where?: AgreementStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgreementStatuses to fetch.
     */
    orderBy?: AgreementStatusOrderByWithRelationInput | AgreementStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgreementStatuses.
     */
    cursor?: AgreementStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgreementStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgreementStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgreementStatuses.
     */
    distinct?: AgreementStatusScalarFieldEnum | AgreementStatusScalarFieldEnum[]
  }

  /**
   * AgreementStatus findMany
   */
  export type AgreementStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementStatus
     */
    select?: AgreementStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgreementStatus
     */
    omit?: AgreementStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementStatusInclude<ExtArgs> | null
    /**
     * Filter, which AgreementStatuses to fetch.
     */
    where?: AgreementStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgreementStatuses to fetch.
     */
    orderBy?: AgreementStatusOrderByWithRelationInput | AgreementStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgreementStatuses.
     */
    cursor?: AgreementStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgreementStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgreementStatuses.
     */
    skip?: number
    distinct?: AgreementStatusScalarFieldEnum | AgreementStatusScalarFieldEnum[]
  }

  /**
   * AgreementStatus create
   */
  export type AgreementStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementStatus
     */
    select?: AgreementStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgreementStatus
     */
    omit?: AgreementStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a AgreementStatus.
     */
    data: XOR<AgreementStatusCreateInput, AgreementStatusUncheckedCreateInput>
  }

  /**
   * AgreementStatus createMany
   */
  export type AgreementStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgreementStatuses.
     */
    data: AgreementStatusCreateManyInput | AgreementStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgreementStatus update
   */
  export type AgreementStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementStatus
     */
    select?: AgreementStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgreementStatus
     */
    omit?: AgreementStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a AgreementStatus.
     */
    data: XOR<AgreementStatusUpdateInput, AgreementStatusUncheckedUpdateInput>
    /**
     * Choose, which AgreementStatus to update.
     */
    where: AgreementStatusWhereUniqueInput
  }

  /**
   * AgreementStatus updateMany
   */
  export type AgreementStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgreementStatuses.
     */
    data: XOR<AgreementStatusUpdateManyMutationInput, AgreementStatusUncheckedUpdateManyInput>
    /**
     * Filter which AgreementStatuses to update
     */
    where?: AgreementStatusWhereInput
    /**
     * Limit how many AgreementStatuses to update.
     */
    limit?: number
  }

  /**
   * AgreementStatus upsert
   */
  export type AgreementStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementStatus
     */
    select?: AgreementStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgreementStatus
     */
    omit?: AgreementStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the AgreementStatus to update in case it exists.
     */
    where: AgreementStatusWhereUniqueInput
    /**
     * In case the AgreementStatus found by the `where` argument doesn't exist, create a new AgreementStatus with this data.
     */
    create: XOR<AgreementStatusCreateInput, AgreementStatusUncheckedCreateInput>
    /**
     * In case the AgreementStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgreementStatusUpdateInput, AgreementStatusUncheckedUpdateInput>
  }

  /**
   * AgreementStatus delete
   */
  export type AgreementStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementStatus
     */
    select?: AgreementStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgreementStatus
     */
    omit?: AgreementStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementStatusInclude<ExtArgs> | null
    /**
     * Filter which AgreementStatus to delete.
     */
    where: AgreementStatusWhereUniqueInput
  }

  /**
   * AgreementStatus deleteMany
   */
  export type AgreementStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgreementStatuses to delete
     */
    where?: AgreementStatusWhereInput
    /**
     * Limit how many AgreementStatuses to delete.
     */
    limit?: number
  }

  /**
   * AgreementStatus.employees
   */
  export type AgreementStatus$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * AgreementStatus without action
   */
  export type AgreementStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementStatus
     */
    select?: AgreementStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgreementStatus
     */
    omit?: AgreementStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementStatusInclude<ExtArgs> | null
  }


  /**
   * Model Meeting
   */

  export type AggregateMeeting = {
    _count: MeetingCountAggregateOutputType | null
    _avg: MeetingAvgAggregateOutputType | null
    _sum: MeetingSumAggregateOutputType | null
    _min: MeetingMinAggregateOutputType | null
    _max: MeetingMaxAggregateOutputType | null
  }

  export type MeetingAvgAggregateOutputType = {
    id: number | null
    creatorId: number | null
  }

  export type MeetingSumAggregateOutputType = {
    id: number | null
    creatorId: number | null
  }

  export type MeetingMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    date: string | null
    time: string | null
    creatorId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MeetingMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    date: string | null
    time: string | null
    creatorId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MeetingCountAggregateOutputType = {
    id: number
    title: number
    description: number
    date: number
    time: number
    creatorId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MeetingAvgAggregateInputType = {
    id?: true
    creatorId?: true
  }

  export type MeetingSumAggregateInputType = {
    id?: true
    creatorId?: true
  }

  export type MeetingMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    time?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MeetingMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    time?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MeetingCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    date?: true
    time?: true
    creatorId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MeetingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Meeting to aggregate.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Meetings
    **/
    _count?: true | MeetingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MeetingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MeetingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeetingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeetingMaxAggregateInputType
  }

  export type GetMeetingAggregateType<T extends MeetingAggregateArgs> = {
        [P in keyof T & keyof AggregateMeeting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeeting[P]>
      : GetScalarType<T[P], AggregateMeeting[P]>
  }




  export type MeetingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingWhereInput
    orderBy?: MeetingOrderByWithAggregationInput | MeetingOrderByWithAggregationInput[]
    by: MeetingScalarFieldEnum[] | MeetingScalarFieldEnum
    having?: MeetingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeetingCountAggregateInputType | true
    _avg?: MeetingAvgAggregateInputType
    _sum?: MeetingSumAggregateInputType
    _min?: MeetingMinAggregateInputType
    _max?: MeetingMaxAggregateInputType
  }

  export type MeetingGroupByOutputType = {
    id: number
    title: string
    description: string | null
    date: string
    time: string
    creatorId: number | null
    createdAt: Date
    updatedAt: Date
    _count: MeetingCountAggregateOutputType | null
    _avg: MeetingAvgAggregateOutputType | null
    _sum: MeetingSumAggregateOutputType | null
    _min: MeetingMinAggregateOutputType | null
    _max: MeetingMaxAggregateOutputType | null
  }

  type GetMeetingGroupByPayload<T extends MeetingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MeetingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeetingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeetingGroupByOutputType[P]>
            : GetScalarType<T[P], MeetingGroupByOutputType[P]>
        }
      >
    >


  export type MeetingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    time?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | Meeting$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["meeting"]>



  export type MeetingSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    time?: boolean
    creatorId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MeetingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "date" | "time" | "creatorId" | "createdAt" | "updatedAt", ExtArgs["result"]["meeting"]>
  export type MeetingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Meeting$creatorArgs<ExtArgs>
  }

  export type $MeetingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Meeting"
    objects: {
      creator: Prisma.$EmployeePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      date: string
      time: string
      creatorId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["meeting"]>
    composites: {}
  }

  type MeetingGetPayload<S extends boolean | null | undefined | MeetingDefaultArgs> = $Result.GetResult<Prisma.$MeetingPayload, S>

  type MeetingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MeetingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MeetingCountAggregateInputType | true
    }

  export interface MeetingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Meeting'], meta: { name: 'Meeting' } }
    /**
     * Find zero or one Meeting that matches the filter.
     * @param {MeetingFindUniqueArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MeetingFindUniqueArgs>(args: SelectSubset<T, MeetingFindUniqueArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Meeting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MeetingFindUniqueOrThrowArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MeetingFindUniqueOrThrowArgs>(args: SelectSubset<T, MeetingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Meeting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindFirstArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MeetingFindFirstArgs>(args?: SelectSubset<T, MeetingFindFirstArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Meeting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindFirstOrThrowArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MeetingFindFirstOrThrowArgs>(args?: SelectSubset<T, MeetingFindFirstOrThrowArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Meetings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Meetings
     * const meetings = await prisma.meeting.findMany()
     * 
     * // Get first 10 Meetings
     * const meetings = await prisma.meeting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const meetingWithIdOnly = await prisma.meeting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MeetingFindManyArgs>(args?: SelectSubset<T, MeetingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Meeting.
     * @param {MeetingCreateArgs} args - Arguments to create a Meeting.
     * @example
     * // Create one Meeting
     * const Meeting = await prisma.meeting.create({
     *   data: {
     *     // ... data to create a Meeting
     *   }
     * })
     * 
     */
    create<T extends MeetingCreateArgs>(args: SelectSubset<T, MeetingCreateArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Meetings.
     * @param {MeetingCreateManyArgs} args - Arguments to create many Meetings.
     * @example
     * // Create many Meetings
     * const meeting = await prisma.meeting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MeetingCreateManyArgs>(args?: SelectSubset<T, MeetingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Meeting.
     * @param {MeetingDeleteArgs} args - Arguments to delete one Meeting.
     * @example
     * // Delete one Meeting
     * const Meeting = await prisma.meeting.delete({
     *   where: {
     *     // ... filter to delete one Meeting
     *   }
     * })
     * 
     */
    delete<T extends MeetingDeleteArgs>(args: SelectSubset<T, MeetingDeleteArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Meeting.
     * @param {MeetingUpdateArgs} args - Arguments to update one Meeting.
     * @example
     * // Update one Meeting
     * const meeting = await prisma.meeting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MeetingUpdateArgs>(args: SelectSubset<T, MeetingUpdateArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Meetings.
     * @param {MeetingDeleteManyArgs} args - Arguments to filter Meetings to delete.
     * @example
     * // Delete a few Meetings
     * const { count } = await prisma.meeting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MeetingDeleteManyArgs>(args?: SelectSubset<T, MeetingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Meetings
     * const meeting = await prisma.meeting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MeetingUpdateManyArgs>(args: SelectSubset<T, MeetingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Meeting.
     * @param {MeetingUpsertArgs} args - Arguments to update or create a Meeting.
     * @example
     * // Update or create a Meeting
     * const meeting = await prisma.meeting.upsert({
     *   create: {
     *     // ... data to create a Meeting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meeting we want to update
     *   }
     * })
     */
    upsert<T extends MeetingUpsertArgs>(args: SelectSubset<T, MeetingUpsertArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Meetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingCountArgs} args - Arguments to filter Meetings to count.
     * @example
     * // Count the number of Meetings
     * const count = await prisma.meeting.count({
     *   where: {
     *     // ... the filter for the Meetings we want to count
     *   }
     * })
    **/
    count<T extends MeetingCountArgs>(
      args?: Subset<T, MeetingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeetingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Meeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeetingAggregateArgs>(args: Subset<T, MeetingAggregateArgs>): Prisma.PrismaPromise<GetMeetingAggregateType<T>>

    /**
     * Group by Meeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MeetingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MeetingGroupByArgs['orderBy'] }
        : { orderBy?: MeetingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MeetingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeetingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Meeting model
   */
  readonly fields: MeetingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Meeting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MeetingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends Meeting$creatorArgs<ExtArgs> = {}>(args?: Subset<T, Meeting$creatorArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Meeting model
   */
  interface MeetingFieldRefs {
    readonly id: FieldRef<"Meeting", 'Int'>
    readonly title: FieldRef<"Meeting", 'String'>
    readonly description: FieldRef<"Meeting", 'String'>
    readonly date: FieldRef<"Meeting", 'String'>
    readonly time: FieldRef<"Meeting", 'String'>
    readonly creatorId: FieldRef<"Meeting", 'Int'>
    readonly createdAt: FieldRef<"Meeting", 'DateTime'>
    readonly updatedAt: FieldRef<"Meeting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Meeting findUnique
   */
  export type MeetingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting findUniqueOrThrow
   */
  export type MeetingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting findFirst
   */
  export type MeetingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Meetings.
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Meetings.
     */
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Meeting findFirstOrThrow
   */
  export type MeetingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Meetings.
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Meetings.
     */
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Meeting findMany
   */
  export type MeetingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meetings to fetch.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Meetings.
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Meeting create
   */
  export type MeetingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * The data needed to create a Meeting.
     */
    data: XOR<MeetingCreateInput, MeetingUncheckedCreateInput>
  }

  /**
   * Meeting createMany
   */
  export type MeetingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Meetings.
     */
    data: MeetingCreateManyInput | MeetingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Meeting update
   */
  export type MeetingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * The data needed to update a Meeting.
     */
    data: XOR<MeetingUpdateInput, MeetingUncheckedUpdateInput>
    /**
     * Choose, which Meeting to update.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting updateMany
   */
  export type MeetingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Meetings.
     */
    data: XOR<MeetingUpdateManyMutationInput, MeetingUncheckedUpdateManyInput>
    /**
     * Filter which Meetings to update
     */
    where?: MeetingWhereInput
    /**
     * Limit how many Meetings to update.
     */
    limit?: number
  }

  /**
   * Meeting upsert
   */
  export type MeetingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * The filter to search for the Meeting to update in case it exists.
     */
    where: MeetingWhereUniqueInput
    /**
     * In case the Meeting found by the `where` argument doesn't exist, create a new Meeting with this data.
     */
    create: XOR<MeetingCreateInput, MeetingUncheckedCreateInput>
    /**
     * In case the Meeting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MeetingUpdateInput, MeetingUncheckedUpdateInput>
  }

  /**
   * Meeting delete
   */
  export type MeetingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter which Meeting to delete.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting deleteMany
   */
  export type MeetingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Meetings to delete
     */
    where?: MeetingWhereInput
    /**
     * Limit how many Meetings to delete.
     */
    limit?: number
  }

  /**
   * Meeting.creator
   */
  export type Meeting$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * Meeting without action
   */
  export type MeetingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    maritalStatusId: number | null
    departmentId: number | null
    subDepartmentId: number | null
    positionId: number | null
    employmentTypeId: number | null
    jobStatusId: number | null
    salary: Decimal | null
    bonusSalary: Decimal | null
    agreementStatusId: number | null
  }

  export type EmployeeSumAggregateOutputType = {
    id: number | null
    userId: number | null
    maritalStatusId: number | null
    departmentId: number | null
    subDepartmentId: number | null
    positionId: number | null
    employmentTypeId: number | null
    jobStatusId: number | null
    salary: Decimal | null
    bonusSalary: Decimal | null
    agreementStatusId: number | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: number | null
    userId: number | null
    firstName: string | null
    lastName: string | null
    baptismalName: string | null
    dateOfBirth: Date | null
    sex: $Enums.Sex | null
    nationality: string | null
    maritalStatusId: number | null
    departmentId: number | null
    subDepartmentId: number | null
    positionId: number | null
    employmentTypeId: number | null
    employmentDate: Date | null
    jobStatusId: number | null
    phone: string | null
    address: string | null
    subCity: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    repentanceFatherName: string | null
    repentanceFatherChurch: string | null
    repentanceFatherPhone: string | null
    academicQualification: string | null
    educationalInstitution: string | null
    salary: Decimal | null
    bonusSalary: Decimal | null
    accountNumber: string | null
    agreementStatusId: number | null
    photo: string | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    firstName: string | null
    lastName: string | null
    baptismalName: string | null
    dateOfBirth: Date | null
    sex: $Enums.Sex | null
    nationality: string | null
    maritalStatusId: number | null
    departmentId: number | null
    subDepartmentId: number | null
    positionId: number | null
    employmentTypeId: number | null
    employmentDate: Date | null
    jobStatusId: number | null
    phone: string | null
    address: string | null
    subCity: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    repentanceFatherName: string | null
    repentanceFatherChurch: string | null
    repentanceFatherPhone: string | null
    academicQualification: string | null
    educationalInstitution: string | null
    salary: Decimal | null
    bonusSalary: Decimal | null
    accountNumber: string | null
    agreementStatusId: number | null
    photo: string | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    userId: number
    firstName: number
    lastName: number
    baptismalName: number
    dateOfBirth: number
    sex: number
    nationality: number
    maritalStatusId: number
    departmentId: number
    subDepartmentId: number
    positionId: number
    employmentTypeId: number
    employmentDate: number
    jobStatusId: number
    phone: number
    address: number
    subCity: number
    emergencyContactName: number
    emergencyContactPhone: number
    repentanceFatherName: number
    repentanceFatherChurch: number
    repentanceFatherPhone: number
    academicQualification: number
    educationalInstitution: number
    salary: number
    bonusSalary: number
    accountNumber: number
    agreementStatusId: number
    photo: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeAvgAggregateInputType = {
    id?: true
    userId?: true
    maritalStatusId?: true
    departmentId?: true
    subDepartmentId?: true
    positionId?: true
    employmentTypeId?: true
    jobStatusId?: true
    salary?: true
    bonusSalary?: true
    agreementStatusId?: true
  }

  export type EmployeeSumAggregateInputType = {
    id?: true
    userId?: true
    maritalStatusId?: true
    departmentId?: true
    subDepartmentId?: true
    positionId?: true
    employmentTypeId?: true
    jobStatusId?: true
    salary?: true
    bonusSalary?: true
    agreementStatusId?: true
  }

  export type EmployeeMinAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    baptismalName?: true
    dateOfBirth?: true
    sex?: true
    nationality?: true
    maritalStatusId?: true
    departmentId?: true
    subDepartmentId?: true
    positionId?: true
    employmentTypeId?: true
    employmentDate?: true
    jobStatusId?: true
    phone?: true
    address?: true
    subCity?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    repentanceFatherName?: true
    repentanceFatherChurch?: true
    repentanceFatherPhone?: true
    academicQualification?: true
    educationalInstitution?: true
    salary?: true
    bonusSalary?: true
    accountNumber?: true
    agreementStatusId?: true
    photo?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    baptismalName?: true
    dateOfBirth?: true
    sex?: true
    nationality?: true
    maritalStatusId?: true
    departmentId?: true
    subDepartmentId?: true
    positionId?: true
    employmentTypeId?: true
    employmentDate?: true
    jobStatusId?: true
    phone?: true
    address?: true
    subCity?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    repentanceFatherName?: true
    repentanceFatherChurch?: true
    repentanceFatherPhone?: true
    academicQualification?: true
    educationalInstitution?: true
    salary?: true
    bonusSalary?: true
    accountNumber?: true
    agreementStatusId?: true
    photo?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    baptismalName?: true
    dateOfBirth?: true
    sex?: true
    nationality?: true
    maritalStatusId?: true
    departmentId?: true
    subDepartmentId?: true
    positionId?: true
    employmentTypeId?: true
    employmentDate?: true
    jobStatusId?: true
    phone?: true
    address?: true
    subCity?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    repentanceFatherName?: true
    repentanceFatherChurch?: true
    repentanceFatherPhone?: true
    academicQualification?: true
    educationalInstitution?: true
    salary?: true
    bonusSalary?: true
    accountNumber?: true
    agreementStatusId?: true
    photo?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _avg?: EmployeeAvgAggregateInputType
    _sum?: EmployeeSumAggregateInputType
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: number
    userId: number | null
    firstName: string
    lastName: string
    baptismalName: string | null
    dateOfBirth: Date | null
    sex: $Enums.Sex
    nationality: string | null
    maritalStatusId: number | null
    departmentId: number | null
    subDepartmentId: number | null
    positionId: number | null
    employmentTypeId: number | null
    employmentDate: Date | null
    jobStatusId: number | null
    phone: string | null
    address: string | null
    subCity: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    repentanceFatherName: string | null
    repentanceFatherChurch: string | null
    repentanceFatherPhone: string | null
    academicQualification: string | null
    educationalInstitution: string | null
    salary: Decimal
    bonusSalary: Decimal
    accountNumber: string | null
    agreementStatusId: number | null
    photo: string | null
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    baptismalName?: boolean
    dateOfBirth?: boolean
    sex?: boolean
    nationality?: boolean
    maritalStatusId?: boolean
    departmentId?: boolean
    subDepartmentId?: boolean
    positionId?: boolean
    employmentTypeId?: boolean
    employmentDate?: boolean
    jobStatusId?: boolean
    phone?: boolean
    address?: boolean
    subCity?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    repentanceFatherName?: boolean
    repentanceFatherChurch?: boolean
    repentanceFatherPhone?: boolean
    academicQualification?: boolean
    educationalInstitution?: boolean
    salary?: boolean
    bonusSalary?: boolean
    accountNumber?: boolean
    agreementStatusId?: boolean
    photo?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Employee$userArgs<ExtArgs>
    department?: boolean | Employee$departmentArgs<ExtArgs>
    position?: boolean | Employee$positionArgs<ExtArgs>
    maritalStatus?: boolean | Employee$maritalStatusArgs<ExtArgs>
    employmentType?: boolean | Employee$employmentTypeArgs<ExtArgs>
    jobStatus?: boolean | Employee$jobStatusArgs<ExtArgs>
    agreementStatus?: boolean | Employee$agreementStatusArgs<ExtArgs>
    createdMeetings?: boolean | Employee$createdMeetingsArgs<ExtArgs>
    shifts?: boolean | Employee$shiftsArgs<ExtArgs>
    attendanceLogs?: boolean | Employee$attendanceLogsArgs<ExtArgs>
    attendanceSummaries?: boolean | Employee$attendanceSummariesArgs<ExtArgs>
    leaves?: boolean | Employee$leavesArgs<ExtArgs>
    complaints?: boolean | Employee$complaintsArgs<ExtArgs>
    performanceReviews?: boolean | Employee$performanceReviewsArgs<ExtArgs>
    terminations?: boolean | Employee$terminationsArgs<ExtArgs>
    salaries?: boolean | Employee$salariesArgs<ExtArgs>
    overtimes?: boolean | Employee$overtimesArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>



  export type EmployeeSelectScalar = {
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    baptismalName?: boolean
    dateOfBirth?: boolean
    sex?: boolean
    nationality?: boolean
    maritalStatusId?: boolean
    departmentId?: boolean
    subDepartmentId?: boolean
    positionId?: boolean
    employmentTypeId?: boolean
    employmentDate?: boolean
    jobStatusId?: boolean
    phone?: boolean
    address?: boolean
    subCity?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    repentanceFatherName?: boolean
    repentanceFatherChurch?: boolean
    repentanceFatherPhone?: boolean
    academicQualification?: boolean
    educationalInstitution?: boolean
    salary?: boolean
    bonusSalary?: boolean
    accountNumber?: boolean
    agreementStatusId?: boolean
    photo?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "firstName" | "lastName" | "baptismalName" | "dateOfBirth" | "sex" | "nationality" | "maritalStatusId" | "departmentId" | "subDepartmentId" | "positionId" | "employmentTypeId" | "employmentDate" | "jobStatusId" | "phone" | "address" | "subCity" | "emergencyContactName" | "emergencyContactPhone" | "repentanceFatherName" | "repentanceFatherChurch" | "repentanceFatherPhone" | "academicQualification" | "educationalInstitution" | "salary" | "bonusSalary" | "accountNumber" | "agreementStatusId" | "photo" | "deletedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["employee"]>
  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Employee$userArgs<ExtArgs>
    department?: boolean | Employee$departmentArgs<ExtArgs>
    position?: boolean | Employee$positionArgs<ExtArgs>
    maritalStatus?: boolean | Employee$maritalStatusArgs<ExtArgs>
    employmentType?: boolean | Employee$employmentTypeArgs<ExtArgs>
    jobStatus?: boolean | Employee$jobStatusArgs<ExtArgs>
    agreementStatus?: boolean | Employee$agreementStatusArgs<ExtArgs>
    createdMeetings?: boolean | Employee$createdMeetingsArgs<ExtArgs>
    shifts?: boolean | Employee$shiftsArgs<ExtArgs>
    attendanceLogs?: boolean | Employee$attendanceLogsArgs<ExtArgs>
    attendanceSummaries?: boolean | Employee$attendanceSummariesArgs<ExtArgs>
    leaves?: boolean | Employee$leavesArgs<ExtArgs>
    complaints?: boolean | Employee$complaintsArgs<ExtArgs>
    performanceReviews?: boolean | Employee$performanceReviewsArgs<ExtArgs>
    terminations?: boolean | Employee$terminationsArgs<ExtArgs>
    salaries?: boolean | Employee$salariesArgs<ExtArgs>
    overtimes?: boolean | Employee$overtimesArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      position: Prisma.$PositionPayload<ExtArgs> | null
      maritalStatus: Prisma.$MaritalStatusPayload<ExtArgs> | null
      employmentType: Prisma.$EmploymentTypePayload<ExtArgs> | null
      jobStatus: Prisma.$JobStatusPayload<ExtArgs> | null
      agreementStatus: Prisma.$AgreementStatusPayload<ExtArgs> | null
      createdMeetings: Prisma.$MeetingPayload<ExtArgs>[]
      shifts: Prisma.$EmployeeShiftPayload<ExtArgs>[]
      attendanceLogs: Prisma.$AttendanceLogPayload<ExtArgs>[]
      attendanceSummaries: Prisma.$AttendanceSummaryPayload<ExtArgs>[]
      leaves: Prisma.$LeavePayload<ExtArgs>[]
      complaints: Prisma.$ComplaintPayload<ExtArgs>[]
      performanceReviews: Prisma.$PerformanceReviewPayload<ExtArgs>[]
      terminations: Prisma.$TerminationPayload<ExtArgs>[]
      salaries: Prisma.$SalaryPayload<ExtArgs>[]
      overtimes: Prisma.$OvertimeLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      firstName: string
      lastName: string
      baptismalName: string | null
      dateOfBirth: Date | null
      sex: $Enums.Sex
      nationality: string | null
      maritalStatusId: number | null
      departmentId: number | null
      subDepartmentId: number | null
      positionId: number | null
      employmentTypeId: number | null
      employmentDate: Date | null
      jobStatusId: number | null
      phone: string | null
      address: string | null
      subCity: string | null
      emergencyContactName: string | null
      emergencyContactPhone: string | null
      repentanceFatherName: string | null
      repentanceFatherChurch: string | null
      repentanceFatherPhone: string | null
      academicQualification: string | null
      educationalInstitution: string | null
      salary: Prisma.Decimal
      bonusSalary: Prisma.Decimal
      accountNumber: string | null
      agreementStatusId: number | null
      photo: string | null
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Employee$userArgs<ExtArgs> = {}>(args?: Subset<T, Employee$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    department<T extends Employee$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Employee$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    position<T extends Employee$positionArgs<ExtArgs> = {}>(args?: Subset<T, Employee$positionArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    maritalStatus<T extends Employee$maritalStatusArgs<ExtArgs> = {}>(args?: Subset<T, Employee$maritalStatusArgs<ExtArgs>>): Prisma__MaritalStatusClient<$Result.GetResult<Prisma.$MaritalStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    employmentType<T extends Employee$employmentTypeArgs<ExtArgs> = {}>(args?: Subset<T, Employee$employmentTypeArgs<ExtArgs>>): Prisma__EmploymentTypeClient<$Result.GetResult<Prisma.$EmploymentTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    jobStatus<T extends Employee$jobStatusArgs<ExtArgs> = {}>(args?: Subset<T, Employee$jobStatusArgs<ExtArgs>>): Prisma__JobStatusClient<$Result.GetResult<Prisma.$JobStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    agreementStatus<T extends Employee$agreementStatusArgs<ExtArgs> = {}>(args?: Subset<T, Employee$agreementStatusArgs<ExtArgs>>): Prisma__AgreementStatusClient<$Result.GetResult<Prisma.$AgreementStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdMeetings<T extends Employee$createdMeetingsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$createdMeetingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shifts<T extends Employee$shiftsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$shiftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendanceLogs<T extends Employee$attendanceLogsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$attendanceLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendanceSummaries<T extends Employee$attendanceSummariesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$attendanceSummariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leaves<T extends Employee$leavesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$leavesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    complaints<T extends Employee$complaintsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$complaintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    performanceReviews<T extends Employee$performanceReviewsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$performanceReviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    terminations<T extends Employee$terminationsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$terminationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TerminationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    salaries<T extends Employee$salariesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$salariesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    overtimes<T extends Employee$overtimesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$overtimesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OvertimeLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'Int'>
    readonly userId: FieldRef<"Employee", 'Int'>
    readonly firstName: FieldRef<"Employee", 'String'>
    readonly lastName: FieldRef<"Employee", 'String'>
    readonly baptismalName: FieldRef<"Employee", 'String'>
    readonly dateOfBirth: FieldRef<"Employee", 'DateTime'>
    readonly sex: FieldRef<"Employee", 'Sex'>
    readonly nationality: FieldRef<"Employee", 'String'>
    readonly maritalStatusId: FieldRef<"Employee", 'Int'>
    readonly departmentId: FieldRef<"Employee", 'Int'>
    readonly subDepartmentId: FieldRef<"Employee", 'Int'>
    readonly positionId: FieldRef<"Employee", 'Int'>
    readonly employmentTypeId: FieldRef<"Employee", 'Int'>
    readonly employmentDate: FieldRef<"Employee", 'DateTime'>
    readonly jobStatusId: FieldRef<"Employee", 'Int'>
    readonly phone: FieldRef<"Employee", 'String'>
    readonly address: FieldRef<"Employee", 'String'>
    readonly subCity: FieldRef<"Employee", 'String'>
    readonly emergencyContactName: FieldRef<"Employee", 'String'>
    readonly emergencyContactPhone: FieldRef<"Employee", 'String'>
    readonly repentanceFatherName: FieldRef<"Employee", 'String'>
    readonly repentanceFatherChurch: FieldRef<"Employee", 'String'>
    readonly repentanceFatherPhone: FieldRef<"Employee", 'String'>
    readonly academicQualification: FieldRef<"Employee", 'String'>
    readonly educationalInstitution: FieldRef<"Employee", 'String'>
    readonly salary: FieldRef<"Employee", 'Decimal'>
    readonly bonusSalary: FieldRef<"Employee", 'Decimal'>
    readonly accountNumber: FieldRef<"Employee", 'String'>
    readonly agreementStatusId: FieldRef<"Employee", 'Int'>
    readonly photo: FieldRef<"Employee", 'String'>
    readonly deletedAt: FieldRef<"Employee", 'DateTime'>
    readonly createdAt: FieldRef<"Employee", 'DateTime'>
    readonly updatedAt: FieldRef<"Employee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employee.user
   */
  export type Employee$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Employee.department
   */
  export type Employee$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Employee.position
   */
  export type Employee$positionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    where?: PositionWhereInput
  }

  /**
   * Employee.maritalStatus
   */
  export type Employee$maritalStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaritalStatus
     */
    select?: MaritalStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaritalStatus
     */
    omit?: MaritalStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaritalStatusInclude<ExtArgs> | null
    where?: MaritalStatusWhereInput
  }

  /**
   * Employee.employmentType
   */
  export type Employee$employmentTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentType
     */
    select?: EmploymentTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentType
     */
    omit?: EmploymentTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentTypeInclude<ExtArgs> | null
    where?: EmploymentTypeWhereInput
  }

  /**
   * Employee.jobStatus
   */
  export type Employee$jobStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobStatus
     */
    select?: JobStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobStatus
     */
    omit?: JobStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobStatusInclude<ExtArgs> | null
    where?: JobStatusWhereInput
  }

  /**
   * Employee.agreementStatus
   */
  export type Employee$agreementStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementStatus
     */
    select?: AgreementStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgreementStatus
     */
    omit?: AgreementStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementStatusInclude<ExtArgs> | null
    where?: AgreementStatusWhereInput
  }

  /**
   * Employee.createdMeetings
   */
  export type Employee$createdMeetingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    where?: MeetingWhereInput
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    cursor?: MeetingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Employee.shifts
   */
  export type Employee$shiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeShift
     */
    omit?: EmployeeShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    where?: EmployeeShiftWhereInput
    orderBy?: EmployeeShiftOrderByWithRelationInput | EmployeeShiftOrderByWithRelationInput[]
    cursor?: EmployeeShiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeShiftScalarFieldEnum | EmployeeShiftScalarFieldEnum[]
  }

  /**
   * Employee.attendanceLogs
   */
  export type Employee$attendanceLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceLog
     */
    omit?: AttendanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    where?: AttendanceLogWhereInput
    orderBy?: AttendanceLogOrderByWithRelationInput | AttendanceLogOrderByWithRelationInput[]
    cursor?: AttendanceLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceLogScalarFieldEnum | AttendanceLogScalarFieldEnum[]
  }

  /**
   * Employee.attendanceSummaries
   */
  export type Employee$attendanceSummariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    where?: AttendanceSummaryWhereInput
    orderBy?: AttendanceSummaryOrderByWithRelationInput | AttendanceSummaryOrderByWithRelationInput[]
    cursor?: AttendanceSummaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceSummaryScalarFieldEnum | AttendanceSummaryScalarFieldEnum[]
  }

  /**
   * Employee.leaves
   */
  export type Employee$leavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    where?: LeaveWhereInput
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    cursor?: LeaveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Employee.complaints
   */
  export type Employee$complaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    where?: ComplaintWhereInput
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    cursor?: ComplaintWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * Employee.performanceReviews
   */
  export type Employee$performanceReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    where?: PerformanceReviewWhereInput
    orderBy?: PerformanceReviewOrderByWithRelationInput | PerformanceReviewOrderByWithRelationInput[]
    cursor?: PerformanceReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PerformanceReviewScalarFieldEnum | PerformanceReviewScalarFieldEnum[]
  }

  /**
   * Employee.terminations
   */
  export type Employee$terminationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Termination
     */
    select?: TerminationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Termination
     */
    omit?: TerminationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminationInclude<ExtArgs> | null
    where?: TerminationWhereInput
    orderBy?: TerminationOrderByWithRelationInput | TerminationOrderByWithRelationInput[]
    cursor?: TerminationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TerminationScalarFieldEnum | TerminationScalarFieldEnum[]
  }

  /**
   * Employee.salaries
   */
  export type Employee$salariesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    where?: SalaryWhereInput
    orderBy?: SalaryOrderByWithRelationInput | SalaryOrderByWithRelationInput[]
    cursor?: SalaryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalaryScalarFieldEnum | SalaryScalarFieldEnum[]
  }

  /**
   * Employee.overtimes
   */
  export type Employee$overtimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OvertimeLog
     */
    select?: OvertimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OvertimeLog
     */
    omit?: OvertimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeLogInclude<ExtArgs> | null
    where?: OvertimeLogWhereInput
    orderBy?: OvertimeLogOrderByWithRelationInput | OvertimeLogOrderByWithRelationInput[]
    cursor?: OvertimeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OvertimeLogScalarFieldEnum | OvertimeLogScalarFieldEnum[]
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model Shift
   */

  export type AggregateShift = {
    _count: ShiftCountAggregateOutputType | null
    _avg: ShiftAvgAggregateOutputType | null
    _sum: ShiftSumAggregateOutputType | null
    _min: ShiftMinAggregateOutputType | null
    _max: ShiftMaxAggregateOutputType | null
  }

  export type ShiftAvgAggregateOutputType = {
    id: number | null
  }

  export type ShiftSumAggregateOutputType = {
    id: number | null
  }

  export type ShiftMinAggregateOutputType = {
    id: number | null
    name: string | null
    startTime: Date | null
    endTime: Date | null
    isFlexible: boolean | null
    description: string | null
  }

  export type ShiftMaxAggregateOutputType = {
    id: number | null
    name: string | null
    startTime: Date | null
    endTime: Date | null
    isFlexible: boolean | null
    description: string | null
  }

  export type ShiftCountAggregateOutputType = {
    id: number
    name: number
    startTime: number
    endTime: number
    isFlexible: number
    description: number
    _all: number
  }


  export type ShiftAvgAggregateInputType = {
    id?: true
  }

  export type ShiftSumAggregateInputType = {
    id?: true
  }

  export type ShiftMinAggregateInputType = {
    id?: true
    name?: true
    startTime?: true
    endTime?: true
    isFlexible?: true
    description?: true
  }

  export type ShiftMaxAggregateInputType = {
    id?: true
    name?: true
    startTime?: true
    endTime?: true
    isFlexible?: true
    description?: true
  }

  export type ShiftCountAggregateInputType = {
    id?: true
    name?: true
    startTime?: true
    endTime?: true
    isFlexible?: true
    description?: true
    _all?: true
  }

  export type ShiftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shift to aggregate.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shifts
    **/
    _count?: true | ShiftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShiftAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShiftSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShiftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShiftMaxAggregateInputType
  }

  export type GetShiftAggregateType<T extends ShiftAggregateArgs> = {
        [P in keyof T & keyof AggregateShift]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShift[P]>
      : GetScalarType<T[P], AggregateShift[P]>
  }




  export type ShiftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftWhereInput
    orderBy?: ShiftOrderByWithAggregationInput | ShiftOrderByWithAggregationInput[]
    by: ShiftScalarFieldEnum[] | ShiftScalarFieldEnum
    having?: ShiftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShiftCountAggregateInputType | true
    _avg?: ShiftAvgAggregateInputType
    _sum?: ShiftSumAggregateInputType
    _min?: ShiftMinAggregateInputType
    _max?: ShiftMaxAggregateInputType
  }

  export type ShiftGroupByOutputType = {
    id: number
    name: string
    startTime: Date
    endTime: Date
    isFlexible: boolean
    description: string | null
    _count: ShiftCountAggregateOutputType | null
    _avg: ShiftAvgAggregateOutputType | null
    _sum: ShiftSumAggregateOutputType | null
    _min: ShiftMinAggregateOutputType | null
    _max: ShiftMaxAggregateOutputType | null
  }

  type GetShiftGroupByPayload<T extends ShiftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShiftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShiftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShiftGroupByOutputType[P]>
            : GetScalarType<T[P], ShiftGroupByOutputType[P]>
        }
      >
    >


  export type ShiftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    isFlexible?: boolean
    description?: boolean
    assignments?: boolean | Shift$assignmentsArgs<ExtArgs>
    _count?: boolean | ShiftCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shift"]>



  export type ShiftSelectScalar = {
    id?: boolean
    name?: boolean
    startTime?: boolean
    endTime?: boolean
    isFlexible?: boolean
    description?: boolean
  }

  export type ShiftOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "startTime" | "endTime" | "isFlexible" | "description", ExtArgs["result"]["shift"]>
  export type ShiftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | Shift$assignmentsArgs<ExtArgs>
    _count?: boolean | ShiftCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ShiftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shift"
    objects: {
      assignments: Prisma.$EmployeeShiftPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      startTime: Date
      endTime: Date
      isFlexible: boolean
      description: string | null
    }, ExtArgs["result"]["shift"]>
    composites: {}
  }

  type ShiftGetPayload<S extends boolean | null | undefined | ShiftDefaultArgs> = $Result.GetResult<Prisma.$ShiftPayload, S>

  type ShiftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShiftFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShiftCountAggregateInputType | true
    }

  export interface ShiftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shift'], meta: { name: 'Shift' } }
    /**
     * Find zero or one Shift that matches the filter.
     * @param {ShiftFindUniqueArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShiftFindUniqueArgs>(args: SelectSubset<T, ShiftFindUniqueArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shift that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShiftFindUniqueOrThrowArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShiftFindUniqueOrThrowArgs>(args: SelectSubset<T, ShiftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shift that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindFirstArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShiftFindFirstArgs>(args?: SelectSubset<T, ShiftFindFirstArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shift that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindFirstOrThrowArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShiftFindFirstOrThrowArgs>(args?: SelectSubset<T, ShiftFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shifts
     * const shifts = await prisma.shift.findMany()
     * 
     * // Get first 10 Shifts
     * const shifts = await prisma.shift.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shiftWithIdOnly = await prisma.shift.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShiftFindManyArgs>(args?: SelectSubset<T, ShiftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shift.
     * @param {ShiftCreateArgs} args - Arguments to create a Shift.
     * @example
     * // Create one Shift
     * const Shift = await prisma.shift.create({
     *   data: {
     *     // ... data to create a Shift
     *   }
     * })
     * 
     */
    create<T extends ShiftCreateArgs>(args: SelectSubset<T, ShiftCreateArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shifts.
     * @param {ShiftCreateManyArgs} args - Arguments to create many Shifts.
     * @example
     * // Create many Shifts
     * const shift = await prisma.shift.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShiftCreateManyArgs>(args?: SelectSubset<T, ShiftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Shift.
     * @param {ShiftDeleteArgs} args - Arguments to delete one Shift.
     * @example
     * // Delete one Shift
     * const Shift = await prisma.shift.delete({
     *   where: {
     *     // ... filter to delete one Shift
     *   }
     * })
     * 
     */
    delete<T extends ShiftDeleteArgs>(args: SelectSubset<T, ShiftDeleteArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shift.
     * @param {ShiftUpdateArgs} args - Arguments to update one Shift.
     * @example
     * // Update one Shift
     * const shift = await prisma.shift.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShiftUpdateArgs>(args: SelectSubset<T, ShiftUpdateArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shifts.
     * @param {ShiftDeleteManyArgs} args - Arguments to filter Shifts to delete.
     * @example
     * // Delete a few Shifts
     * const { count } = await prisma.shift.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShiftDeleteManyArgs>(args?: SelectSubset<T, ShiftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shifts
     * const shift = await prisma.shift.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShiftUpdateManyArgs>(args: SelectSubset<T, ShiftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shift.
     * @param {ShiftUpsertArgs} args - Arguments to update or create a Shift.
     * @example
     * // Update or create a Shift
     * const shift = await prisma.shift.upsert({
     *   create: {
     *     // ... data to create a Shift
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shift we want to update
     *   }
     * })
     */
    upsert<T extends ShiftUpsertArgs>(args: SelectSubset<T, ShiftUpsertArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftCountArgs} args - Arguments to filter Shifts to count.
     * @example
     * // Count the number of Shifts
     * const count = await prisma.shift.count({
     *   where: {
     *     // ... the filter for the Shifts we want to count
     *   }
     * })
    **/
    count<T extends ShiftCountArgs>(
      args?: Subset<T, ShiftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShiftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShiftAggregateArgs>(args: Subset<T, ShiftAggregateArgs>): Prisma.PrismaPromise<GetShiftAggregateType<T>>

    /**
     * Group by Shift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShiftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShiftGroupByArgs['orderBy'] }
        : { orderBy?: ShiftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShiftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShiftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shift model
   */
  readonly fields: ShiftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shift.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShiftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignments<T extends Shift$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Shift$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shift model
   */
  interface ShiftFieldRefs {
    readonly id: FieldRef<"Shift", 'Int'>
    readonly name: FieldRef<"Shift", 'String'>
    readonly startTime: FieldRef<"Shift", 'DateTime'>
    readonly endTime: FieldRef<"Shift", 'DateTime'>
    readonly isFlexible: FieldRef<"Shift", 'Boolean'>
    readonly description: FieldRef<"Shift", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Shift findUnique
   */
  export type ShiftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift findUniqueOrThrow
   */
  export type ShiftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift findFirst
   */
  export type ShiftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shifts.
     */
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift findFirstOrThrow
   */
  export type ShiftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shifts.
     */
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift findMany
   */
  export type ShiftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shifts to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift create
   */
  export type ShiftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The data needed to create a Shift.
     */
    data: XOR<ShiftCreateInput, ShiftUncheckedCreateInput>
  }

  /**
   * Shift createMany
   */
  export type ShiftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shifts.
     */
    data: ShiftCreateManyInput | ShiftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shift update
   */
  export type ShiftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The data needed to update a Shift.
     */
    data: XOR<ShiftUpdateInput, ShiftUncheckedUpdateInput>
    /**
     * Choose, which Shift to update.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift updateMany
   */
  export type ShiftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shifts.
     */
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyInput>
    /**
     * Filter which Shifts to update
     */
    where?: ShiftWhereInput
    /**
     * Limit how many Shifts to update.
     */
    limit?: number
  }

  /**
   * Shift upsert
   */
  export type ShiftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The filter to search for the Shift to update in case it exists.
     */
    where: ShiftWhereUniqueInput
    /**
     * In case the Shift found by the `where` argument doesn't exist, create a new Shift with this data.
     */
    create: XOR<ShiftCreateInput, ShiftUncheckedCreateInput>
    /**
     * In case the Shift was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShiftUpdateInput, ShiftUncheckedUpdateInput>
  }

  /**
   * Shift delete
   */
  export type ShiftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter which Shift to delete.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift deleteMany
   */
  export type ShiftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shifts to delete
     */
    where?: ShiftWhereInput
    /**
     * Limit how many Shifts to delete.
     */
    limit?: number
  }

  /**
   * Shift.assignments
   */
  export type Shift$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeShift
     */
    omit?: EmployeeShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    where?: EmployeeShiftWhereInput
    orderBy?: EmployeeShiftOrderByWithRelationInput | EmployeeShiftOrderByWithRelationInput[]
    cursor?: EmployeeShiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeShiftScalarFieldEnum | EmployeeShiftScalarFieldEnum[]
  }

  /**
   * Shift without action
   */
  export type ShiftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeShift
   */

  export type AggregateEmployeeShift = {
    _count: EmployeeShiftCountAggregateOutputType | null
    _avg: EmployeeShiftAvgAggregateOutputType | null
    _sum: EmployeeShiftSumAggregateOutputType | null
    _min: EmployeeShiftMinAggregateOutputType | null
    _max: EmployeeShiftMaxAggregateOutputType | null
  }

  export type EmployeeShiftAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    shiftId: number | null
  }

  export type EmployeeShiftSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    shiftId: number | null
  }

  export type EmployeeShiftMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    shiftId: number | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
  }

  export type EmployeeShiftMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    shiftId: number | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
  }

  export type EmployeeShiftCountAggregateOutputType = {
    id: number
    employeeId: number
    shiftId: number
    effectiveFrom: number
    effectiveTo: number
    _all: number
  }


  export type EmployeeShiftAvgAggregateInputType = {
    id?: true
    employeeId?: true
    shiftId?: true
  }

  export type EmployeeShiftSumAggregateInputType = {
    id?: true
    employeeId?: true
    shiftId?: true
  }

  export type EmployeeShiftMinAggregateInputType = {
    id?: true
    employeeId?: true
    shiftId?: true
    effectiveFrom?: true
    effectiveTo?: true
  }

  export type EmployeeShiftMaxAggregateInputType = {
    id?: true
    employeeId?: true
    shiftId?: true
    effectiveFrom?: true
    effectiveTo?: true
  }

  export type EmployeeShiftCountAggregateInputType = {
    id?: true
    employeeId?: true
    shiftId?: true
    effectiveFrom?: true
    effectiveTo?: true
    _all?: true
  }

  export type EmployeeShiftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeShift to aggregate.
     */
    where?: EmployeeShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeShifts to fetch.
     */
    orderBy?: EmployeeShiftOrderByWithRelationInput | EmployeeShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeShifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeShifts
    **/
    _count?: true | EmployeeShiftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeShiftAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeShiftSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeShiftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeShiftMaxAggregateInputType
  }

  export type GetEmployeeShiftAggregateType<T extends EmployeeShiftAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeShift]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeShift[P]>
      : GetScalarType<T[P], AggregateEmployeeShift[P]>
  }




  export type EmployeeShiftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeShiftWhereInput
    orderBy?: EmployeeShiftOrderByWithAggregationInput | EmployeeShiftOrderByWithAggregationInput[]
    by: EmployeeShiftScalarFieldEnum[] | EmployeeShiftScalarFieldEnum
    having?: EmployeeShiftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeShiftCountAggregateInputType | true
    _avg?: EmployeeShiftAvgAggregateInputType
    _sum?: EmployeeShiftSumAggregateInputType
    _min?: EmployeeShiftMinAggregateInputType
    _max?: EmployeeShiftMaxAggregateInputType
  }

  export type EmployeeShiftGroupByOutputType = {
    id: number
    employeeId: number
    shiftId: number
    effectiveFrom: Date
    effectiveTo: Date | null
    _count: EmployeeShiftCountAggregateOutputType | null
    _avg: EmployeeShiftAvgAggregateOutputType | null
    _sum: EmployeeShiftSumAggregateOutputType | null
    _min: EmployeeShiftMinAggregateOutputType | null
    _max: EmployeeShiftMaxAggregateOutputType | null
  }

  type GetEmployeeShiftGroupByPayload<T extends EmployeeShiftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeShiftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeShiftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeShiftGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeShiftGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeShiftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    shiftId?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    shift?: boolean | ShiftDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeShift"]>



  export type EmployeeShiftSelectScalar = {
    id?: boolean
    employeeId?: boolean
    shiftId?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
  }

  export type EmployeeShiftOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "shiftId" | "effectiveFrom" | "effectiveTo", ExtArgs["result"]["employeeShift"]>
  export type EmployeeShiftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    shift?: boolean | ShiftDefaultArgs<ExtArgs>
  }

  export type $EmployeeShiftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeShift"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      shift: Prisma.$ShiftPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      shiftId: number
      effectiveFrom: Date
      effectiveTo: Date | null
    }, ExtArgs["result"]["employeeShift"]>
    composites: {}
  }

  type EmployeeShiftGetPayload<S extends boolean | null | undefined | EmployeeShiftDefaultArgs> = $Result.GetResult<Prisma.$EmployeeShiftPayload, S>

  type EmployeeShiftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeShiftFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeShiftCountAggregateInputType | true
    }

  export interface EmployeeShiftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeShift'], meta: { name: 'EmployeeShift' } }
    /**
     * Find zero or one EmployeeShift that matches the filter.
     * @param {EmployeeShiftFindUniqueArgs} args - Arguments to find a EmployeeShift
     * @example
     * // Get one EmployeeShift
     * const employeeShift = await prisma.employeeShift.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeShiftFindUniqueArgs>(args: SelectSubset<T, EmployeeShiftFindUniqueArgs<ExtArgs>>): Prisma__EmployeeShiftClient<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmployeeShift that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeShiftFindUniqueOrThrowArgs} args - Arguments to find a EmployeeShift
     * @example
     * // Get one EmployeeShift
     * const employeeShift = await prisma.employeeShift.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeShiftFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeShiftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeShiftClient<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeShift that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeShiftFindFirstArgs} args - Arguments to find a EmployeeShift
     * @example
     * // Get one EmployeeShift
     * const employeeShift = await prisma.employeeShift.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeShiftFindFirstArgs>(args?: SelectSubset<T, EmployeeShiftFindFirstArgs<ExtArgs>>): Prisma__EmployeeShiftClient<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeShift that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeShiftFindFirstOrThrowArgs} args - Arguments to find a EmployeeShift
     * @example
     * // Get one EmployeeShift
     * const employeeShift = await prisma.employeeShift.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeShiftFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeShiftFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeShiftClient<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmployeeShifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeShiftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeShifts
     * const employeeShifts = await prisma.employeeShift.findMany()
     * 
     * // Get first 10 EmployeeShifts
     * const employeeShifts = await prisma.employeeShift.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeShiftWithIdOnly = await prisma.employeeShift.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeShiftFindManyArgs>(args?: SelectSubset<T, EmployeeShiftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmployeeShift.
     * @param {EmployeeShiftCreateArgs} args - Arguments to create a EmployeeShift.
     * @example
     * // Create one EmployeeShift
     * const EmployeeShift = await prisma.employeeShift.create({
     *   data: {
     *     // ... data to create a EmployeeShift
     *   }
     * })
     * 
     */
    create<T extends EmployeeShiftCreateArgs>(args: SelectSubset<T, EmployeeShiftCreateArgs<ExtArgs>>): Prisma__EmployeeShiftClient<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmployeeShifts.
     * @param {EmployeeShiftCreateManyArgs} args - Arguments to create many EmployeeShifts.
     * @example
     * // Create many EmployeeShifts
     * const employeeShift = await prisma.employeeShift.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeShiftCreateManyArgs>(args?: SelectSubset<T, EmployeeShiftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmployeeShift.
     * @param {EmployeeShiftDeleteArgs} args - Arguments to delete one EmployeeShift.
     * @example
     * // Delete one EmployeeShift
     * const EmployeeShift = await prisma.employeeShift.delete({
     *   where: {
     *     // ... filter to delete one EmployeeShift
     *   }
     * })
     * 
     */
    delete<T extends EmployeeShiftDeleteArgs>(args: SelectSubset<T, EmployeeShiftDeleteArgs<ExtArgs>>): Prisma__EmployeeShiftClient<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmployeeShift.
     * @param {EmployeeShiftUpdateArgs} args - Arguments to update one EmployeeShift.
     * @example
     * // Update one EmployeeShift
     * const employeeShift = await prisma.employeeShift.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeShiftUpdateArgs>(args: SelectSubset<T, EmployeeShiftUpdateArgs<ExtArgs>>): Prisma__EmployeeShiftClient<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmployeeShifts.
     * @param {EmployeeShiftDeleteManyArgs} args - Arguments to filter EmployeeShifts to delete.
     * @example
     * // Delete a few EmployeeShifts
     * const { count } = await prisma.employeeShift.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeShiftDeleteManyArgs>(args?: SelectSubset<T, EmployeeShiftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeShifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeShiftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeShifts
     * const employeeShift = await prisma.employeeShift.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeShiftUpdateManyArgs>(args: SelectSubset<T, EmployeeShiftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeeShift.
     * @param {EmployeeShiftUpsertArgs} args - Arguments to update or create a EmployeeShift.
     * @example
     * // Update or create a EmployeeShift
     * const employeeShift = await prisma.employeeShift.upsert({
     *   create: {
     *     // ... data to create a EmployeeShift
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeShift we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeShiftUpsertArgs>(args: SelectSubset<T, EmployeeShiftUpsertArgs<ExtArgs>>): Prisma__EmployeeShiftClient<$Result.GetResult<Prisma.$EmployeeShiftPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmployeeShifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeShiftCountArgs} args - Arguments to filter EmployeeShifts to count.
     * @example
     * // Count the number of EmployeeShifts
     * const count = await prisma.employeeShift.count({
     *   where: {
     *     // ... the filter for the EmployeeShifts we want to count
     *   }
     * })
    **/
    count<T extends EmployeeShiftCountArgs>(
      args?: Subset<T, EmployeeShiftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeShiftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeShift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeShiftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeShiftAggregateArgs>(args: Subset<T, EmployeeShiftAggregateArgs>): Prisma.PrismaPromise<GetEmployeeShiftAggregateType<T>>

    /**
     * Group by EmployeeShift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeShiftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeShiftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeShiftGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeShiftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeShiftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeShiftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeShift model
   */
  readonly fields: EmployeeShiftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeShift.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeShiftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    shift<T extends ShiftDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShiftDefaultArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeShift model
   */
  interface EmployeeShiftFieldRefs {
    readonly id: FieldRef<"EmployeeShift", 'Int'>
    readonly employeeId: FieldRef<"EmployeeShift", 'Int'>
    readonly shiftId: FieldRef<"EmployeeShift", 'Int'>
    readonly effectiveFrom: FieldRef<"EmployeeShift", 'DateTime'>
    readonly effectiveTo: FieldRef<"EmployeeShift", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeShift findUnique
   */
  export type EmployeeShiftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeShift
     */
    omit?: EmployeeShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeShift to fetch.
     */
    where: EmployeeShiftWhereUniqueInput
  }

  /**
   * EmployeeShift findUniqueOrThrow
   */
  export type EmployeeShiftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeShift
     */
    omit?: EmployeeShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeShift to fetch.
     */
    where: EmployeeShiftWhereUniqueInput
  }

  /**
   * EmployeeShift findFirst
   */
  export type EmployeeShiftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeShift
     */
    omit?: EmployeeShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeShift to fetch.
     */
    where?: EmployeeShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeShifts to fetch.
     */
    orderBy?: EmployeeShiftOrderByWithRelationInput | EmployeeShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeShifts.
     */
    cursor?: EmployeeShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeShifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeShifts.
     */
    distinct?: EmployeeShiftScalarFieldEnum | EmployeeShiftScalarFieldEnum[]
  }

  /**
   * EmployeeShift findFirstOrThrow
   */
  export type EmployeeShiftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeShift
     */
    omit?: EmployeeShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeShift to fetch.
     */
    where?: EmployeeShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeShifts to fetch.
     */
    orderBy?: EmployeeShiftOrderByWithRelationInput | EmployeeShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeShifts.
     */
    cursor?: EmployeeShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeShifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeShifts.
     */
    distinct?: EmployeeShiftScalarFieldEnum | EmployeeShiftScalarFieldEnum[]
  }

  /**
   * EmployeeShift findMany
   */
  export type EmployeeShiftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeShift
     */
    omit?: EmployeeShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeShifts to fetch.
     */
    where?: EmployeeShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeShifts to fetch.
     */
    orderBy?: EmployeeShiftOrderByWithRelationInput | EmployeeShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeShifts.
     */
    cursor?: EmployeeShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeShifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeShifts.
     */
    skip?: number
    distinct?: EmployeeShiftScalarFieldEnum | EmployeeShiftScalarFieldEnum[]
  }

  /**
   * EmployeeShift create
   */
  export type EmployeeShiftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeShift
     */
    omit?: EmployeeShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeShift.
     */
    data: XOR<EmployeeShiftCreateInput, EmployeeShiftUncheckedCreateInput>
  }

  /**
   * EmployeeShift createMany
   */
  export type EmployeeShiftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeShifts.
     */
    data: EmployeeShiftCreateManyInput | EmployeeShiftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeeShift update
   */
  export type EmployeeShiftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeShift
     */
    omit?: EmployeeShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeShift.
     */
    data: XOR<EmployeeShiftUpdateInput, EmployeeShiftUncheckedUpdateInput>
    /**
     * Choose, which EmployeeShift to update.
     */
    where: EmployeeShiftWhereUniqueInput
  }

  /**
   * EmployeeShift updateMany
   */
  export type EmployeeShiftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeShifts.
     */
    data: XOR<EmployeeShiftUpdateManyMutationInput, EmployeeShiftUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeShifts to update
     */
    where?: EmployeeShiftWhereInput
    /**
     * Limit how many EmployeeShifts to update.
     */
    limit?: number
  }

  /**
   * EmployeeShift upsert
   */
  export type EmployeeShiftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeShift
     */
    omit?: EmployeeShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeShift to update in case it exists.
     */
    where: EmployeeShiftWhereUniqueInput
    /**
     * In case the EmployeeShift found by the `where` argument doesn't exist, create a new EmployeeShift with this data.
     */
    create: XOR<EmployeeShiftCreateInput, EmployeeShiftUncheckedCreateInput>
    /**
     * In case the EmployeeShift was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeShiftUpdateInput, EmployeeShiftUncheckedUpdateInput>
  }

  /**
   * EmployeeShift delete
   */
  export type EmployeeShiftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeShift
     */
    omit?: EmployeeShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
    /**
     * Filter which EmployeeShift to delete.
     */
    where: EmployeeShiftWhereUniqueInput
  }

  /**
   * EmployeeShift deleteMany
   */
  export type EmployeeShiftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeShifts to delete
     */
    where?: EmployeeShiftWhereInput
    /**
     * Limit how many EmployeeShifts to delete.
     */
    limit?: number
  }

  /**
   * EmployeeShift without action
   */
  export type EmployeeShiftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeShift
     */
    select?: EmployeeShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeShift
     */
    omit?: EmployeeShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeShiftInclude<ExtArgs> | null
  }


  /**
   * Model SessionDefinition
   */

  export type AggregateSessionDefinition = {
    _count: SessionDefinitionCountAggregateOutputType | null
    _avg: SessionDefinitionAvgAggregateOutputType | null
    _sum: SessionDefinitionSumAggregateOutputType | null
    _min: SessionDefinitionMinAggregateOutputType | null
    _max: SessionDefinitionMaxAggregateOutputType | null
  }

  export type SessionDefinitionAvgAggregateOutputType = {
    id: number | null
    sessionNumber: number | null
  }

  export type SessionDefinitionSumAggregateOutputType = {
    id: number | null
    sessionNumber: number | null
  }

  export type SessionDefinitionMinAggregateOutputType = {
    id: number | null
    sessionNumber: number | null
    expectedClockIn: Date | null
    expectedClockOut: Date | null
  }

  export type SessionDefinitionMaxAggregateOutputType = {
    id: number | null
    sessionNumber: number | null
    expectedClockIn: Date | null
    expectedClockOut: Date | null
  }

  export type SessionDefinitionCountAggregateOutputType = {
    id: number
    sessionNumber: number
    expectedClockIn: number
    expectedClockOut: number
    _all: number
  }


  export type SessionDefinitionAvgAggregateInputType = {
    id?: true
    sessionNumber?: true
  }

  export type SessionDefinitionSumAggregateInputType = {
    id?: true
    sessionNumber?: true
  }

  export type SessionDefinitionMinAggregateInputType = {
    id?: true
    sessionNumber?: true
    expectedClockIn?: true
    expectedClockOut?: true
  }

  export type SessionDefinitionMaxAggregateInputType = {
    id?: true
    sessionNumber?: true
    expectedClockIn?: true
    expectedClockOut?: true
  }

  export type SessionDefinitionCountAggregateInputType = {
    id?: true
    sessionNumber?: true
    expectedClockIn?: true
    expectedClockOut?: true
    _all?: true
  }

  export type SessionDefinitionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionDefinition to aggregate.
     */
    where?: SessionDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionDefinitions to fetch.
     */
    orderBy?: SessionDefinitionOrderByWithRelationInput | SessionDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionDefinitions
    **/
    _count?: true | SessionDefinitionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionDefinitionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionDefinitionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionDefinitionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionDefinitionMaxAggregateInputType
  }

  export type GetSessionDefinitionAggregateType<T extends SessionDefinitionAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionDefinition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionDefinition[P]>
      : GetScalarType<T[P], AggregateSessionDefinition[P]>
  }




  export type SessionDefinitionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionDefinitionWhereInput
    orderBy?: SessionDefinitionOrderByWithAggregationInput | SessionDefinitionOrderByWithAggregationInput[]
    by: SessionDefinitionScalarFieldEnum[] | SessionDefinitionScalarFieldEnum
    having?: SessionDefinitionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionDefinitionCountAggregateInputType | true
    _avg?: SessionDefinitionAvgAggregateInputType
    _sum?: SessionDefinitionSumAggregateInputType
    _min?: SessionDefinitionMinAggregateInputType
    _max?: SessionDefinitionMaxAggregateInputType
  }

  export type SessionDefinitionGroupByOutputType = {
    id: number
    sessionNumber: number
    expectedClockIn: Date
    expectedClockOut: Date
    _count: SessionDefinitionCountAggregateOutputType | null
    _avg: SessionDefinitionAvgAggregateOutputType | null
    _sum: SessionDefinitionSumAggregateOutputType | null
    _min: SessionDefinitionMinAggregateOutputType | null
    _max: SessionDefinitionMaxAggregateOutputType | null
  }

  type GetSessionDefinitionGroupByPayload<T extends SessionDefinitionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionDefinitionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionDefinitionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionDefinitionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionDefinitionGroupByOutputType[P]>
        }
      >
    >


  export type SessionDefinitionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionNumber?: boolean
    expectedClockIn?: boolean
    expectedClockOut?: boolean
    logs?: boolean | SessionDefinition$logsArgs<ExtArgs>
    _count?: boolean | SessionDefinitionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionDefinition"]>



  export type SessionDefinitionSelectScalar = {
    id?: boolean
    sessionNumber?: boolean
    expectedClockIn?: boolean
    expectedClockOut?: boolean
  }

  export type SessionDefinitionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionNumber" | "expectedClockIn" | "expectedClockOut", ExtArgs["result"]["sessionDefinition"]>
  export type SessionDefinitionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | SessionDefinition$logsArgs<ExtArgs>
    _count?: boolean | SessionDefinitionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SessionDefinitionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionDefinition"
    objects: {
      logs: Prisma.$AttendanceLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sessionNumber: number
      expectedClockIn: Date
      expectedClockOut: Date
    }, ExtArgs["result"]["sessionDefinition"]>
    composites: {}
  }

  type SessionDefinitionGetPayload<S extends boolean | null | undefined | SessionDefinitionDefaultArgs> = $Result.GetResult<Prisma.$SessionDefinitionPayload, S>

  type SessionDefinitionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionDefinitionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionDefinitionCountAggregateInputType | true
    }

  export interface SessionDefinitionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionDefinition'], meta: { name: 'SessionDefinition' } }
    /**
     * Find zero or one SessionDefinition that matches the filter.
     * @param {SessionDefinitionFindUniqueArgs} args - Arguments to find a SessionDefinition
     * @example
     * // Get one SessionDefinition
     * const sessionDefinition = await prisma.sessionDefinition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionDefinitionFindUniqueArgs>(args: SelectSubset<T, SessionDefinitionFindUniqueArgs<ExtArgs>>): Prisma__SessionDefinitionClient<$Result.GetResult<Prisma.$SessionDefinitionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SessionDefinition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionDefinitionFindUniqueOrThrowArgs} args - Arguments to find a SessionDefinition
     * @example
     * // Get one SessionDefinition
     * const sessionDefinition = await prisma.sessionDefinition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionDefinitionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionDefinitionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionDefinitionClient<$Result.GetResult<Prisma.$SessionDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionDefinition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionDefinitionFindFirstArgs} args - Arguments to find a SessionDefinition
     * @example
     * // Get one SessionDefinition
     * const sessionDefinition = await prisma.sessionDefinition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionDefinitionFindFirstArgs>(args?: SelectSubset<T, SessionDefinitionFindFirstArgs<ExtArgs>>): Prisma__SessionDefinitionClient<$Result.GetResult<Prisma.$SessionDefinitionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionDefinition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionDefinitionFindFirstOrThrowArgs} args - Arguments to find a SessionDefinition
     * @example
     * // Get one SessionDefinition
     * const sessionDefinition = await prisma.sessionDefinition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionDefinitionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionDefinitionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionDefinitionClient<$Result.GetResult<Prisma.$SessionDefinitionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SessionDefinitions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionDefinitionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionDefinitions
     * const sessionDefinitions = await prisma.sessionDefinition.findMany()
     * 
     * // Get first 10 SessionDefinitions
     * const sessionDefinitions = await prisma.sessionDefinition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionDefinitionWithIdOnly = await prisma.sessionDefinition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionDefinitionFindManyArgs>(args?: SelectSubset<T, SessionDefinitionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionDefinitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SessionDefinition.
     * @param {SessionDefinitionCreateArgs} args - Arguments to create a SessionDefinition.
     * @example
     * // Create one SessionDefinition
     * const SessionDefinition = await prisma.sessionDefinition.create({
     *   data: {
     *     // ... data to create a SessionDefinition
     *   }
     * })
     * 
     */
    create<T extends SessionDefinitionCreateArgs>(args: SelectSubset<T, SessionDefinitionCreateArgs<ExtArgs>>): Prisma__SessionDefinitionClient<$Result.GetResult<Prisma.$SessionDefinitionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SessionDefinitions.
     * @param {SessionDefinitionCreateManyArgs} args - Arguments to create many SessionDefinitions.
     * @example
     * // Create many SessionDefinitions
     * const sessionDefinition = await prisma.sessionDefinition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionDefinitionCreateManyArgs>(args?: SelectSubset<T, SessionDefinitionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SessionDefinition.
     * @param {SessionDefinitionDeleteArgs} args - Arguments to delete one SessionDefinition.
     * @example
     * // Delete one SessionDefinition
     * const SessionDefinition = await prisma.sessionDefinition.delete({
     *   where: {
     *     // ... filter to delete one SessionDefinition
     *   }
     * })
     * 
     */
    delete<T extends SessionDefinitionDeleteArgs>(args: SelectSubset<T, SessionDefinitionDeleteArgs<ExtArgs>>): Prisma__SessionDefinitionClient<$Result.GetResult<Prisma.$SessionDefinitionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SessionDefinition.
     * @param {SessionDefinitionUpdateArgs} args - Arguments to update one SessionDefinition.
     * @example
     * // Update one SessionDefinition
     * const sessionDefinition = await prisma.sessionDefinition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionDefinitionUpdateArgs>(args: SelectSubset<T, SessionDefinitionUpdateArgs<ExtArgs>>): Prisma__SessionDefinitionClient<$Result.GetResult<Prisma.$SessionDefinitionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SessionDefinitions.
     * @param {SessionDefinitionDeleteManyArgs} args - Arguments to filter SessionDefinitions to delete.
     * @example
     * // Delete a few SessionDefinitions
     * const { count } = await prisma.sessionDefinition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDefinitionDeleteManyArgs>(args?: SelectSubset<T, SessionDefinitionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionDefinitionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionDefinitions
     * const sessionDefinition = await prisma.sessionDefinition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionDefinitionUpdateManyArgs>(args: SelectSubset<T, SessionDefinitionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SessionDefinition.
     * @param {SessionDefinitionUpsertArgs} args - Arguments to update or create a SessionDefinition.
     * @example
     * // Update or create a SessionDefinition
     * const sessionDefinition = await prisma.sessionDefinition.upsert({
     *   create: {
     *     // ... data to create a SessionDefinition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionDefinition we want to update
     *   }
     * })
     */
    upsert<T extends SessionDefinitionUpsertArgs>(args: SelectSubset<T, SessionDefinitionUpsertArgs<ExtArgs>>): Prisma__SessionDefinitionClient<$Result.GetResult<Prisma.$SessionDefinitionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SessionDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionDefinitionCountArgs} args - Arguments to filter SessionDefinitions to count.
     * @example
     * // Count the number of SessionDefinitions
     * const count = await prisma.sessionDefinition.count({
     *   where: {
     *     // ... the filter for the SessionDefinitions we want to count
     *   }
     * })
    **/
    count<T extends SessionDefinitionCountArgs>(
      args?: Subset<T, SessionDefinitionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionDefinitionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionDefinitionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionDefinitionAggregateArgs>(args: Subset<T, SessionDefinitionAggregateArgs>): Prisma.PrismaPromise<GetSessionDefinitionAggregateType<T>>

    /**
     * Group by SessionDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionDefinitionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionDefinitionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionDefinitionGroupByArgs['orderBy'] }
        : { orderBy?: SessionDefinitionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionDefinitionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionDefinitionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionDefinition model
   */
  readonly fields: SessionDefinitionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionDefinition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionDefinitionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    logs<T extends SessionDefinition$logsArgs<ExtArgs> = {}>(args?: Subset<T, SessionDefinition$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionDefinition model
   */
  interface SessionDefinitionFieldRefs {
    readonly id: FieldRef<"SessionDefinition", 'Int'>
    readonly sessionNumber: FieldRef<"SessionDefinition", 'Int'>
    readonly expectedClockIn: FieldRef<"SessionDefinition", 'DateTime'>
    readonly expectedClockOut: FieldRef<"SessionDefinition", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SessionDefinition findUnique
   */
  export type SessionDefinitionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionDefinition
     */
    select?: SessionDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionDefinition
     */
    omit?: SessionDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which SessionDefinition to fetch.
     */
    where: SessionDefinitionWhereUniqueInput
  }

  /**
   * SessionDefinition findUniqueOrThrow
   */
  export type SessionDefinitionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionDefinition
     */
    select?: SessionDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionDefinition
     */
    omit?: SessionDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which SessionDefinition to fetch.
     */
    where: SessionDefinitionWhereUniqueInput
  }

  /**
   * SessionDefinition findFirst
   */
  export type SessionDefinitionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionDefinition
     */
    select?: SessionDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionDefinition
     */
    omit?: SessionDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which SessionDefinition to fetch.
     */
    where?: SessionDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionDefinitions to fetch.
     */
    orderBy?: SessionDefinitionOrderByWithRelationInput | SessionDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionDefinitions.
     */
    cursor?: SessionDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionDefinitions.
     */
    distinct?: SessionDefinitionScalarFieldEnum | SessionDefinitionScalarFieldEnum[]
  }

  /**
   * SessionDefinition findFirstOrThrow
   */
  export type SessionDefinitionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionDefinition
     */
    select?: SessionDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionDefinition
     */
    omit?: SessionDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which SessionDefinition to fetch.
     */
    where?: SessionDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionDefinitions to fetch.
     */
    orderBy?: SessionDefinitionOrderByWithRelationInput | SessionDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionDefinitions.
     */
    cursor?: SessionDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionDefinitions.
     */
    distinct?: SessionDefinitionScalarFieldEnum | SessionDefinitionScalarFieldEnum[]
  }

  /**
   * SessionDefinition findMany
   */
  export type SessionDefinitionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionDefinition
     */
    select?: SessionDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionDefinition
     */
    omit?: SessionDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which SessionDefinitions to fetch.
     */
    where?: SessionDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionDefinitions to fetch.
     */
    orderBy?: SessionDefinitionOrderByWithRelationInput | SessionDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionDefinitions.
     */
    cursor?: SessionDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionDefinitions.
     */
    skip?: number
    distinct?: SessionDefinitionScalarFieldEnum | SessionDefinitionScalarFieldEnum[]
  }

  /**
   * SessionDefinition create
   */
  export type SessionDefinitionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionDefinition
     */
    select?: SessionDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionDefinition
     */
    omit?: SessionDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionDefinition.
     */
    data: XOR<SessionDefinitionCreateInput, SessionDefinitionUncheckedCreateInput>
  }

  /**
   * SessionDefinition createMany
   */
  export type SessionDefinitionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionDefinitions.
     */
    data: SessionDefinitionCreateManyInput | SessionDefinitionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SessionDefinition update
   */
  export type SessionDefinitionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionDefinition
     */
    select?: SessionDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionDefinition
     */
    omit?: SessionDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionDefinition.
     */
    data: XOR<SessionDefinitionUpdateInput, SessionDefinitionUncheckedUpdateInput>
    /**
     * Choose, which SessionDefinition to update.
     */
    where: SessionDefinitionWhereUniqueInput
  }

  /**
   * SessionDefinition updateMany
   */
  export type SessionDefinitionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionDefinitions.
     */
    data: XOR<SessionDefinitionUpdateManyMutationInput, SessionDefinitionUncheckedUpdateManyInput>
    /**
     * Filter which SessionDefinitions to update
     */
    where?: SessionDefinitionWhereInput
    /**
     * Limit how many SessionDefinitions to update.
     */
    limit?: number
  }

  /**
   * SessionDefinition upsert
   */
  export type SessionDefinitionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionDefinition
     */
    select?: SessionDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionDefinition
     */
    omit?: SessionDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDefinitionInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionDefinition to update in case it exists.
     */
    where: SessionDefinitionWhereUniqueInput
    /**
     * In case the SessionDefinition found by the `where` argument doesn't exist, create a new SessionDefinition with this data.
     */
    create: XOR<SessionDefinitionCreateInput, SessionDefinitionUncheckedCreateInput>
    /**
     * In case the SessionDefinition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionDefinitionUpdateInput, SessionDefinitionUncheckedUpdateInput>
  }

  /**
   * SessionDefinition delete
   */
  export type SessionDefinitionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionDefinition
     */
    select?: SessionDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionDefinition
     */
    omit?: SessionDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDefinitionInclude<ExtArgs> | null
    /**
     * Filter which SessionDefinition to delete.
     */
    where: SessionDefinitionWhereUniqueInput
  }

  /**
   * SessionDefinition deleteMany
   */
  export type SessionDefinitionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionDefinitions to delete
     */
    where?: SessionDefinitionWhereInput
    /**
     * Limit how many SessionDefinitions to delete.
     */
    limit?: number
  }

  /**
   * SessionDefinition.logs
   */
  export type SessionDefinition$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceLog
     */
    omit?: AttendanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    where?: AttendanceLogWhereInput
    orderBy?: AttendanceLogOrderByWithRelationInput | AttendanceLogOrderByWithRelationInput[]
    cursor?: AttendanceLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceLogScalarFieldEnum | AttendanceLogScalarFieldEnum[]
  }

  /**
   * SessionDefinition without action
   */
  export type SessionDefinitionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionDefinition
     */
    select?: SessionDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionDefinition
     */
    omit?: SessionDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDefinitionInclude<ExtArgs> | null
  }


  /**
   * Model AttendanceLog
   */

  export type AggregateAttendanceLog = {
    _count: AttendanceLogCountAggregateOutputType | null
    _avg: AttendanceLogAvgAggregateOutputType | null
    _sum: AttendanceLogSumAggregateOutputType | null
    _min: AttendanceLogMinAggregateOutputType | null
    _max: AttendanceLogMaxAggregateOutputType | null
  }

  export type AttendanceLogAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    sessionId: number | null
  }

  export type AttendanceLogSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    sessionId: number | null
  }

  export type AttendanceLogMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    date: Date | null
    sessionId: number | null
    actualClockIn: Date | null
    actualClockOut: Date | null
    status: $Enums.AttendanceStatus | null
    createdAt: Date | null
  }

  export type AttendanceLogMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    date: Date | null
    sessionId: number | null
    actualClockIn: Date | null
    actualClockOut: Date | null
    status: $Enums.AttendanceStatus | null
    createdAt: Date | null
  }

  export type AttendanceLogCountAggregateOutputType = {
    id: number
    employeeId: number
    date: number
    sessionId: number
    actualClockIn: number
    actualClockOut: number
    status: number
    createdAt: number
    _all: number
  }


  export type AttendanceLogAvgAggregateInputType = {
    id?: true
    employeeId?: true
    sessionId?: true
  }

  export type AttendanceLogSumAggregateInputType = {
    id?: true
    employeeId?: true
    sessionId?: true
  }

  export type AttendanceLogMinAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    sessionId?: true
    actualClockIn?: true
    actualClockOut?: true
    status?: true
    createdAt?: true
  }

  export type AttendanceLogMaxAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    sessionId?: true
    actualClockIn?: true
    actualClockOut?: true
    status?: true
    createdAt?: true
  }

  export type AttendanceLogCountAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    sessionId?: true
    actualClockIn?: true
    actualClockOut?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type AttendanceLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceLog to aggregate.
     */
    where?: AttendanceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceLogs to fetch.
     */
    orderBy?: AttendanceLogOrderByWithRelationInput | AttendanceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttendanceLogs
    **/
    _count?: true | AttendanceLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceLogMaxAggregateInputType
  }

  export type GetAttendanceLogAggregateType<T extends AttendanceLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendanceLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceLog[P]>
      : GetScalarType<T[P], AggregateAttendanceLog[P]>
  }




  export type AttendanceLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceLogWhereInput
    orderBy?: AttendanceLogOrderByWithAggregationInput | AttendanceLogOrderByWithAggregationInput[]
    by: AttendanceLogScalarFieldEnum[] | AttendanceLogScalarFieldEnum
    having?: AttendanceLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceLogCountAggregateInputType | true
    _avg?: AttendanceLogAvgAggregateInputType
    _sum?: AttendanceLogSumAggregateInputType
    _min?: AttendanceLogMinAggregateInputType
    _max?: AttendanceLogMaxAggregateInputType
  }

  export type AttendanceLogGroupByOutputType = {
    id: number
    employeeId: number
    date: Date
    sessionId: number
    actualClockIn: Date | null
    actualClockOut: Date | null
    status: $Enums.AttendanceStatus
    createdAt: Date
    _count: AttendanceLogCountAggregateOutputType | null
    _avg: AttendanceLogAvgAggregateOutputType | null
    _sum: AttendanceLogSumAggregateOutputType | null
    _min: AttendanceLogMinAggregateOutputType | null
    _max: AttendanceLogMaxAggregateOutputType | null
  }

  type GetAttendanceLogGroupByPayload<T extends AttendanceLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceLogGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceLogGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    date?: boolean
    sessionId?: boolean
    actualClockIn?: boolean
    actualClockOut?: boolean
    status?: boolean
    createdAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    session?: boolean | SessionDefinitionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceLog"]>



  export type AttendanceLogSelectScalar = {
    id?: boolean
    employeeId?: boolean
    date?: boolean
    sessionId?: boolean
    actualClockIn?: boolean
    actualClockOut?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type AttendanceLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "date" | "sessionId" | "actualClockIn" | "actualClockOut" | "status" | "createdAt", ExtArgs["result"]["attendanceLog"]>
  export type AttendanceLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    session?: boolean | SessionDefinitionDefaultArgs<ExtArgs>
  }

  export type $AttendanceLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttendanceLog"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      session: Prisma.$SessionDefinitionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      date: Date
      sessionId: number
      actualClockIn: Date | null
      actualClockOut: Date | null
      status: $Enums.AttendanceStatus
      createdAt: Date
    }, ExtArgs["result"]["attendanceLog"]>
    composites: {}
  }

  type AttendanceLogGetPayload<S extends boolean | null | undefined | AttendanceLogDefaultArgs> = $Result.GetResult<Prisma.$AttendanceLogPayload, S>

  type AttendanceLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceLogCountAggregateInputType | true
    }

  export interface AttendanceLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttendanceLog'], meta: { name: 'AttendanceLog' } }
    /**
     * Find zero or one AttendanceLog that matches the filter.
     * @param {AttendanceLogFindUniqueArgs} args - Arguments to find a AttendanceLog
     * @example
     * // Get one AttendanceLog
     * const attendanceLog = await prisma.attendanceLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceLogFindUniqueArgs>(args: SelectSubset<T, AttendanceLogFindUniqueArgs<ExtArgs>>): Prisma__AttendanceLogClient<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AttendanceLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceLogFindUniqueOrThrowArgs} args - Arguments to find a AttendanceLog
     * @example
     * // Get one AttendanceLog
     * const attendanceLog = await prisma.attendanceLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceLogClient<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceLogFindFirstArgs} args - Arguments to find a AttendanceLog
     * @example
     * // Get one AttendanceLog
     * const attendanceLog = await prisma.attendanceLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceLogFindFirstArgs>(args?: SelectSubset<T, AttendanceLogFindFirstArgs<ExtArgs>>): Prisma__AttendanceLogClient<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceLogFindFirstOrThrowArgs} args - Arguments to find a AttendanceLog
     * @example
     * // Get one AttendanceLog
     * const attendanceLog = await prisma.attendanceLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceLogClient<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AttendanceLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceLogs
     * const attendanceLogs = await prisma.attendanceLog.findMany()
     * 
     * // Get first 10 AttendanceLogs
     * const attendanceLogs = await prisma.attendanceLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceLogWithIdOnly = await prisma.attendanceLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceLogFindManyArgs>(args?: SelectSubset<T, AttendanceLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AttendanceLog.
     * @param {AttendanceLogCreateArgs} args - Arguments to create a AttendanceLog.
     * @example
     * // Create one AttendanceLog
     * const AttendanceLog = await prisma.attendanceLog.create({
     *   data: {
     *     // ... data to create a AttendanceLog
     *   }
     * })
     * 
     */
    create<T extends AttendanceLogCreateArgs>(args: SelectSubset<T, AttendanceLogCreateArgs<ExtArgs>>): Prisma__AttendanceLogClient<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AttendanceLogs.
     * @param {AttendanceLogCreateManyArgs} args - Arguments to create many AttendanceLogs.
     * @example
     * // Create many AttendanceLogs
     * const attendanceLog = await prisma.attendanceLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceLogCreateManyArgs>(args?: SelectSubset<T, AttendanceLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AttendanceLog.
     * @param {AttendanceLogDeleteArgs} args - Arguments to delete one AttendanceLog.
     * @example
     * // Delete one AttendanceLog
     * const AttendanceLog = await prisma.attendanceLog.delete({
     *   where: {
     *     // ... filter to delete one AttendanceLog
     *   }
     * })
     * 
     */
    delete<T extends AttendanceLogDeleteArgs>(args: SelectSubset<T, AttendanceLogDeleteArgs<ExtArgs>>): Prisma__AttendanceLogClient<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AttendanceLog.
     * @param {AttendanceLogUpdateArgs} args - Arguments to update one AttendanceLog.
     * @example
     * // Update one AttendanceLog
     * const attendanceLog = await prisma.attendanceLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceLogUpdateArgs>(args: SelectSubset<T, AttendanceLogUpdateArgs<ExtArgs>>): Prisma__AttendanceLogClient<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AttendanceLogs.
     * @param {AttendanceLogDeleteManyArgs} args - Arguments to filter AttendanceLogs to delete.
     * @example
     * // Delete a few AttendanceLogs
     * const { count } = await prisma.attendanceLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceLogDeleteManyArgs>(args?: SelectSubset<T, AttendanceLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceLogs
     * const attendanceLog = await prisma.attendanceLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceLogUpdateManyArgs>(args: SelectSubset<T, AttendanceLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AttendanceLog.
     * @param {AttendanceLogUpsertArgs} args - Arguments to update or create a AttendanceLog.
     * @example
     * // Update or create a AttendanceLog
     * const attendanceLog = await prisma.attendanceLog.upsert({
     *   create: {
     *     // ... data to create a AttendanceLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceLog we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceLogUpsertArgs>(args: SelectSubset<T, AttendanceLogUpsertArgs<ExtArgs>>): Prisma__AttendanceLogClient<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AttendanceLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceLogCountArgs} args - Arguments to filter AttendanceLogs to count.
     * @example
     * // Count the number of AttendanceLogs
     * const count = await prisma.attendanceLog.count({
     *   where: {
     *     // ... the filter for the AttendanceLogs we want to count
     *   }
     * })
    **/
    count<T extends AttendanceLogCountArgs>(
      args?: Subset<T, AttendanceLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttendanceLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceLogAggregateArgs>(args: Subset<T, AttendanceLogAggregateArgs>): Prisma.PrismaPromise<GetAttendanceLogAggregateType<T>>

    /**
     * Group by AttendanceLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceLogGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttendanceLog model
   */
  readonly fields: AttendanceLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    session<T extends SessionDefinitionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessionDefinitionDefaultArgs<ExtArgs>>): Prisma__SessionDefinitionClient<$Result.GetResult<Prisma.$SessionDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttendanceLog model
   */
  interface AttendanceLogFieldRefs {
    readonly id: FieldRef<"AttendanceLog", 'Int'>
    readonly employeeId: FieldRef<"AttendanceLog", 'Int'>
    readonly date: FieldRef<"AttendanceLog", 'DateTime'>
    readonly sessionId: FieldRef<"AttendanceLog", 'Int'>
    readonly actualClockIn: FieldRef<"AttendanceLog", 'DateTime'>
    readonly actualClockOut: FieldRef<"AttendanceLog", 'DateTime'>
    readonly status: FieldRef<"AttendanceLog", 'AttendanceStatus'>
    readonly createdAt: FieldRef<"AttendanceLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AttendanceLog findUnique
   */
  export type AttendanceLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceLog
     */
    omit?: AttendanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceLog to fetch.
     */
    where: AttendanceLogWhereUniqueInput
  }

  /**
   * AttendanceLog findUniqueOrThrow
   */
  export type AttendanceLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceLog
     */
    omit?: AttendanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceLog to fetch.
     */
    where: AttendanceLogWhereUniqueInput
  }

  /**
   * AttendanceLog findFirst
   */
  export type AttendanceLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceLog
     */
    omit?: AttendanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceLog to fetch.
     */
    where?: AttendanceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceLogs to fetch.
     */
    orderBy?: AttendanceLogOrderByWithRelationInput | AttendanceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceLogs.
     */
    cursor?: AttendanceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceLogs.
     */
    distinct?: AttendanceLogScalarFieldEnum | AttendanceLogScalarFieldEnum[]
  }

  /**
   * AttendanceLog findFirstOrThrow
   */
  export type AttendanceLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceLog
     */
    omit?: AttendanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceLog to fetch.
     */
    where?: AttendanceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceLogs to fetch.
     */
    orderBy?: AttendanceLogOrderByWithRelationInput | AttendanceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceLogs.
     */
    cursor?: AttendanceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceLogs.
     */
    distinct?: AttendanceLogScalarFieldEnum | AttendanceLogScalarFieldEnum[]
  }

  /**
   * AttendanceLog findMany
   */
  export type AttendanceLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceLog
     */
    omit?: AttendanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceLogs to fetch.
     */
    where?: AttendanceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceLogs to fetch.
     */
    orderBy?: AttendanceLogOrderByWithRelationInput | AttendanceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttendanceLogs.
     */
    cursor?: AttendanceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceLogs.
     */
    skip?: number
    distinct?: AttendanceLogScalarFieldEnum | AttendanceLogScalarFieldEnum[]
  }

  /**
   * AttendanceLog create
   */
  export type AttendanceLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceLog
     */
    omit?: AttendanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AttendanceLog.
     */
    data: XOR<AttendanceLogCreateInput, AttendanceLogUncheckedCreateInput>
  }

  /**
   * AttendanceLog createMany
   */
  export type AttendanceLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttendanceLogs.
     */
    data: AttendanceLogCreateManyInput | AttendanceLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttendanceLog update
   */
  export type AttendanceLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceLog
     */
    omit?: AttendanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AttendanceLog.
     */
    data: XOR<AttendanceLogUpdateInput, AttendanceLogUncheckedUpdateInput>
    /**
     * Choose, which AttendanceLog to update.
     */
    where: AttendanceLogWhereUniqueInput
  }

  /**
   * AttendanceLog updateMany
   */
  export type AttendanceLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttendanceLogs.
     */
    data: XOR<AttendanceLogUpdateManyMutationInput, AttendanceLogUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceLogs to update
     */
    where?: AttendanceLogWhereInput
    /**
     * Limit how many AttendanceLogs to update.
     */
    limit?: number
  }

  /**
   * AttendanceLog upsert
   */
  export type AttendanceLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceLog
     */
    omit?: AttendanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AttendanceLog to update in case it exists.
     */
    where: AttendanceLogWhereUniqueInput
    /**
     * In case the AttendanceLog found by the `where` argument doesn't exist, create a new AttendanceLog with this data.
     */
    create: XOR<AttendanceLogCreateInput, AttendanceLogUncheckedCreateInput>
    /**
     * In case the AttendanceLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceLogUpdateInput, AttendanceLogUncheckedUpdateInput>
  }

  /**
   * AttendanceLog delete
   */
  export type AttendanceLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceLog
     */
    omit?: AttendanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * Filter which AttendanceLog to delete.
     */
    where: AttendanceLogWhereUniqueInput
  }

  /**
   * AttendanceLog deleteMany
   */
  export type AttendanceLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceLogs to delete
     */
    where?: AttendanceLogWhereInput
    /**
     * Limit how many AttendanceLogs to delete.
     */
    limit?: number
  }

  /**
   * AttendanceLog without action
   */
  export type AttendanceLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceLog
     */
    omit?: AttendanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
  }


  /**
   * Model AttendanceSummary
   */

  export type AggregateAttendanceSummary = {
    _count: AttendanceSummaryCountAggregateOutputType | null
    _avg: AttendanceSummaryAvgAggregateOutputType | null
    _sum: AttendanceSummarySumAggregateOutputType | null
    _min: AttendanceSummaryMinAggregateOutputType | null
    _max: AttendanceSummaryMaxAggregateOutputType | null
  }

  export type AttendanceSummaryAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    totalWorkHours: Decimal | null
    departmentId: number | null
  }

  export type AttendanceSummarySumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    totalWorkHours: Decimal | null
    departmentId: number | null
  }

  export type AttendanceSummaryMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    date: Date | null
    status: $Enums.SummaryStatus | null
    lateArrival: boolean | null
    earlyDeparture: boolean | null
    unplannedAbsence: boolean | null
    totalWorkHours: Decimal | null
    remarks: string | null
    departmentId: number | null
  }

  export type AttendanceSummaryMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    date: Date | null
    status: $Enums.SummaryStatus | null
    lateArrival: boolean | null
    earlyDeparture: boolean | null
    unplannedAbsence: boolean | null
    totalWorkHours: Decimal | null
    remarks: string | null
    departmentId: number | null
  }

  export type AttendanceSummaryCountAggregateOutputType = {
    id: number
    employeeId: number
    date: number
    status: number
    lateArrival: number
    earlyDeparture: number
    unplannedAbsence: number
    totalWorkHours: number
    remarks: number
    departmentId: number
    _all: number
  }


  export type AttendanceSummaryAvgAggregateInputType = {
    id?: true
    employeeId?: true
    totalWorkHours?: true
    departmentId?: true
  }

  export type AttendanceSummarySumAggregateInputType = {
    id?: true
    employeeId?: true
    totalWorkHours?: true
    departmentId?: true
  }

  export type AttendanceSummaryMinAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    status?: true
    lateArrival?: true
    earlyDeparture?: true
    unplannedAbsence?: true
    totalWorkHours?: true
    remarks?: true
    departmentId?: true
  }

  export type AttendanceSummaryMaxAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    status?: true
    lateArrival?: true
    earlyDeparture?: true
    unplannedAbsence?: true
    totalWorkHours?: true
    remarks?: true
    departmentId?: true
  }

  export type AttendanceSummaryCountAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    status?: true
    lateArrival?: true
    earlyDeparture?: true
    unplannedAbsence?: true
    totalWorkHours?: true
    remarks?: true
    departmentId?: true
    _all?: true
  }

  export type AttendanceSummaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceSummary to aggregate.
     */
    where?: AttendanceSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceSummaries to fetch.
     */
    orderBy?: AttendanceSummaryOrderByWithRelationInput | AttendanceSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttendanceSummaries
    **/
    _count?: true | AttendanceSummaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceSummaryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceSummarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceSummaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceSummaryMaxAggregateInputType
  }

  export type GetAttendanceSummaryAggregateType<T extends AttendanceSummaryAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendanceSummary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceSummary[P]>
      : GetScalarType<T[P], AggregateAttendanceSummary[P]>
  }




  export type AttendanceSummaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceSummaryWhereInput
    orderBy?: AttendanceSummaryOrderByWithAggregationInput | AttendanceSummaryOrderByWithAggregationInput[]
    by: AttendanceSummaryScalarFieldEnum[] | AttendanceSummaryScalarFieldEnum
    having?: AttendanceSummaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceSummaryCountAggregateInputType | true
    _avg?: AttendanceSummaryAvgAggregateInputType
    _sum?: AttendanceSummarySumAggregateInputType
    _min?: AttendanceSummaryMinAggregateInputType
    _max?: AttendanceSummaryMaxAggregateInputType
  }

  export type AttendanceSummaryGroupByOutputType = {
    id: number
    employeeId: number
    date: Date
    status: $Enums.SummaryStatus
    lateArrival: boolean
    earlyDeparture: boolean
    unplannedAbsence: boolean
    totalWorkHours: Decimal | null
    remarks: string | null
    departmentId: number | null
    _count: AttendanceSummaryCountAggregateOutputType | null
    _avg: AttendanceSummaryAvgAggregateOutputType | null
    _sum: AttendanceSummarySumAggregateOutputType | null
    _min: AttendanceSummaryMinAggregateOutputType | null
    _max: AttendanceSummaryMaxAggregateOutputType | null
  }

  type GetAttendanceSummaryGroupByPayload<T extends AttendanceSummaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceSummaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceSummaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceSummaryGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceSummaryGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSummarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    date?: boolean
    status?: boolean
    lateArrival?: boolean
    earlyDeparture?: boolean
    unplannedAbsence?: boolean
    totalWorkHours?: boolean
    remarks?: boolean
    departmentId?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    department?: boolean | AttendanceSummary$departmentArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceSummary"]>



  export type AttendanceSummarySelectScalar = {
    id?: boolean
    employeeId?: boolean
    date?: boolean
    status?: boolean
    lateArrival?: boolean
    earlyDeparture?: boolean
    unplannedAbsence?: boolean
    totalWorkHours?: boolean
    remarks?: boolean
    departmentId?: boolean
  }

  export type AttendanceSummaryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "date" | "status" | "lateArrival" | "earlyDeparture" | "unplannedAbsence" | "totalWorkHours" | "remarks" | "departmentId", ExtArgs["result"]["attendanceSummary"]>
  export type AttendanceSummaryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    department?: boolean | AttendanceSummary$departmentArgs<ExtArgs>
  }

  export type $AttendanceSummaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttendanceSummary"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      department: Prisma.$DepartmentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      date: Date
      status: $Enums.SummaryStatus
      lateArrival: boolean
      earlyDeparture: boolean
      unplannedAbsence: boolean
      totalWorkHours: Prisma.Decimal | null
      remarks: string | null
      departmentId: number | null
    }, ExtArgs["result"]["attendanceSummary"]>
    composites: {}
  }

  type AttendanceSummaryGetPayload<S extends boolean | null | undefined | AttendanceSummaryDefaultArgs> = $Result.GetResult<Prisma.$AttendanceSummaryPayload, S>

  type AttendanceSummaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceSummaryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceSummaryCountAggregateInputType | true
    }

  export interface AttendanceSummaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttendanceSummary'], meta: { name: 'AttendanceSummary' } }
    /**
     * Find zero or one AttendanceSummary that matches the filter.
     * @param {AttendanceSummaryFindUniqueArgs} args - Arguments to find a AttendanceSummary
     * @example
     * // Get one AttendanceSummary
     * const attendanceSummary = await prisma.attendanceSummary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceSummaryFindUniqueArgs>(args: SelectSubset<T, AttendanceSummaryFindUniqueArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AttendanceSummary that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceSummaryFindUniqueOrThrowArgs} args - Arguments to find a AttendanceSummary
     * @example
     * // Get one AttendanceSummary
     * const attendanceSummary = await prisma.attendanceSummary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceSummaryFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceSummaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceSummary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSummaryFindFirstArgs} args - Arguments to find a AttendanceSummary
     * @example
     * // Get one AttendanceSummary
     * const attendanceSummary = await prisma.attendanceSummary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceSummaryFindFirstArgs>(args?: SelectSubset<T, AttendanceSummaryFindFirstArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AttendanceSummary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSummaryFindFirstOrThrowArgs} args - Arguments to find a AttendanceSummary
     * @example
     * // Get one AttendanceSummary
     * const attendanceSummary = await prisma.attendanceSummary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceSummaryFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceSummaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AttendanceSummaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSummaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceSummaries
     * const attendanceSummaries = await prisma.attendanceSummary.findMany()
     * 
     * // Get first 10 AttendanceSummaries
     * const attendanceSummaries = await prisma.attendanceSummary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceSummaryWithIdOnly = await prisma.attendanceSummary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceSummaryFindManyArgs>(args?: SelectSubset<T, AttendanceSummaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AttendanceSummary.
     * @param {AttendanceSummaryCreateArgs} args - Arguments to create a AttendanceSummary.
     * @example
     * // Create one AttendanceSummary
     * const AttendanceSummary = await prisma.attendanceSummary.create({
     *   data: {
     *     // ... data to create a AttendanceSummary
     *   }
     * })
     * 
     */
    create<T extends AttendanceSummaryCreateArgs>(args: SelectSubset<T, AttendanceSummaryCreateArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AttendanceSummaries.
     * @param {AttendanceSummaryCreateManyArgs} args - Arguments to create many AttendanceSummaries.
     * @example
     * // Create many AttendanceSummaries
     * const attendanceSummary = await prisma.attendanceSummary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceSummaryCreateManyArgs>(args?: SelectSubset<T, AttendanceSummaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AttendanceSummary.
     * @param {AttendanceSummaryDeleteArgs} args - Arguments to delete one AttendanceSummary.
     * @example
     * // Delete one AttendanceSummary
     * const AttendanceSummary = await prisma.attendanceSummary.delete({
     *   where: {
     *     // ... filter to delete one AttendanceSummary
     *   }
     * })
     * 
     */
    delete<T extends AttendanceSummaryDeleteArgs>(args: SelectSubset<T, AttendanceSummaryDeleteArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AttendanceSummary.
     * @param {AttendanceSummaryUpdateArgs} args - Arguments to update one AttendanceSummary.
     * @example
     * // Update one AttendanceSummary
     * const attendanceSummary = await prisma.attendanceSummary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceSummaryUpdateArgs>(args: SelectSubset<T, AttendanceSummaryUpdateArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AttendanceSummaries.
     * @param {AttendanceSummaryDeleteManyArgs} args - Arguments to filter AttendanceSummaries to delete.
     * @example
     * // Delete a few AttendanceSummaries
     * const { count } = await prisma.attendanceSummary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceSummaryDeleteManyArgs>(args?: SelectSubset<T, AttendanceSummaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSummaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceSummaries
     * const attendanceSummary = await prisma.attendanceSummary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceSummaryUpdateManyArgs>(args: SelectSubset<T, AttendanceSummaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AttendanceSummary.
     * @param {AttendanceSummaryUpsertArgs} args - Arguments to update or create a AttendanceSummary.
     * @example
     * // Update or create a AttendanceSummary
     * const attendanceSummary = await prisma.attendanceSummary.upsert({
     *   create: {
     *     // ... data to create a AttendanceSummary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceSummary we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceSummaryUpsertArgs>(args: SelectSubset<T, AttendanceSummaryUpsertArgs<ExtArgs>>): Prisma__AttendanceSummaryClient<$Result.GetResult<Prisma.$AttendanceSummaryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AttendanceSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSummaryCountArgs} args - Arguments to filter AttendanceSummaries to count.
     * @example
     * // Count the number of AttendanceSummaries
     * const count = await prisma.attendanceSummary.count({
     *   where: {
     *     // ... the filter for the AttendanceSummaries we want to count
     *   }
     * })
    **/
    count<T extends AttendanceSummaryCountArgs>(
      args?: Subset<T, AttendanceSummaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceSummaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttendanceSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSummaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceSummaryAggregateArgs>(args: Subset<T, AttendanceSummaryAggregateArgs>): Prisma.PrismaPromise<GetAttendanceSummaryAggregateType<T>>

    /**
     * Group by AttendanceSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceSummaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceSummaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceSummaryGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceSummaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceSummaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceSummaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttendanceSummary model
   */
  readonly fields: AttendanceSummaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceSummary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceSummaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    department<T extends AttendanceSummary$departmentArgs<ExtArgs> = {}>(args?: Subset<T, AttendanceSummary$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttendanceSummary model
   */
  interface AttendanceSummaryFieldRefs {
    readonly id: FieldRef<"AttendanceSummary", 'Int'>
    readonly employeeId: FieldRef<"AttendanceSummary", 'Int'>
    readonly date: FieldRef<"AttendanceSummary", 'DateTime'>
    readonly status: FieldRef<"AttendanceSummary", 'SummaryStatus'>
    readonly lateArrival: FieldRef<"AttendanceSummary", 'Boolean'>
    readonly earlyDeparture: FieldRef<"AttendanceSummary", 'Boolean'>
    readonly unplannedAbsence: FieldRef<"AttendanceSummary", 'Boolean'>
    readonly totalWorkHours: FieldRef<"AttendanceSummary", 'Decimal'>
    readonly remarks: FieldRef<"AttendanceSummary", 'String'>
    readonly departmentId: FieldRef<"AttendanceSummary", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AttendanceSummary findUnique
   */
  export type AttendanceSummaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceSummary to fetch.
     */
    where: AttendanceSummaryWhereUniqueInput
  }

  /**
   * AttendanceSummary findUniqueOrThrow
   */
  export type AttendanceSummaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceSummary to fetch.
     */
    where: AttendanceSummaryWhereUniqueInput
  }

  /**
   * AttendanceSummary findFirst
   */
  export type AttendanceSummaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceSummary to fetch.
     */
    where?: AttendanceSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceSummaries to fetch.
     */
    orderBy?: AttendanceSummaryOrderByWithRelationInput | AttendanceSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceSummaries.
     */
    cursor?: AttendanceSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceSummaries.
     */
    distinct?: AttendanceSummaryScalarFieldEnum | AttendanceSummaryScalarFieldEnum[]
  }

  /**
   * AttendanceSummary findFirstOrThrow
   */
  export type AttendanceSummaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceSummary to fetch.
     */
    where?: AttendanceSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceSummaries to fetch.
     */
    orderBy?: AttendanceSummaryOrderByWithRelationInput | AttendanceSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceSummaries.
     */
    cursor?: AttendanceSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceSummaries.
     */
    distinct?: AttendanceSummaryScalarFieldEnum | AttendanceSummaryScalarFieldEnum[]
  }

  /**
   * AttendanceSummary findMany
   */
  export type AttendanceSummaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceSummaries to fetch.
     */
    where?: AttendanceSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceSummaries to fetch.
     */
    orderBy?: AttendanceSummaryOrderByWithRelationInput | AttendanceSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttendanceSummaries.
     */
    cursor?: AttendanceSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceSummaries.
     */
    skip?: number
    distinct?: AttendanceSummaryScalarFieldEnum | AttendanceSummaryScalarFieldEnum[]
  }

  /**
   * AttendanceSummary create
   */
  export type AttendanceSummaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * The data needed to create a AttendanceSummary.
     */
    data: XOR<AttendanceSummaryCreateInput, AttendanceSummaryUncheckedCreateInput>
  }

  /**
   * AttendanceSummary createMany
   */
  export type AttendanceSummaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttendanceSummaries.
     */
    data: AttendanceSummaryCreateManyInput | AttendanceSummaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttendanceSummary update
   */
  export type AttendanceSummaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * The data needed to update a AttendanceSummary.
     */
    data: XOR<AttendanceSummaryUpdateInput, AttendanceSummaryUncheckedUpdateInput>
    /**
     * Choose, which AttendanceSummary to update.
     */
    where: AttendanceSummaryWhereUniqueInput
  }

  /**
   * AttendanceSummary updateMany
   */
  export type AttendanceSummaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttendanceSummaries.
     */
    data: XOR<AttendanceSummaryUpdateManyMutationInput, AttendanceSummaryUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceSummaries to update
     */
    where?: AttendanceSummaryWhereInput
    /**
     * Limit how many AttendanceSummaries to update.
     */
    limit?: number
  }

  /**
   * AttendanceSummary upsert
   */
  export type AttendanceSummaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * The filter to search for the AttendanceSummary to update in case it exists.
     */
    where: AttendanceSummaryWhereUniqueInput
    /**
     * In case the AttendanceSummary found by the `where` argument doesn't exist, create a new AttendanceSummary with this data.
     */
    create: XOR<AttendanceSummaryCreateInput, AttendanceSummaryUncheckedCreateInput>
    /**
     * In case the AttendanceSummary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceSummaryUpdateInput, AttendanceSummaryUncheckedUpdateInput>
  }

  /**
   * AttendanceSummary delete
   */
  export type AttendanceSummaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
    /**
     * Filter which AttendanceSummary to delete.
     */
    where: AttendanceSummaryWhereUniqueInput
  }

  /**
   * AttendanceSummary deleteMany
   */
  export type AttendanceSummaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceSummaries to delete
     */
    where?: AttendanceSummaryWhereInput
    /**
     * Limit how many AttendanceSummaries to delete.
     */
    limit?: number
  }

  /**
   * AttendanceSummary.department
   */
  export type AttendanceSummary$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * AttendanceSummary without action
   */
  export type AttendanceSummaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceSummary
     */
    select?: AttendanceSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AttendanceSummary
     */
    omit?: AttendanceSummaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceSummaryInclude<ExtArgs> | null
  }


  /**
   * Model Leave
   */

  export type AggregateLeave = {
    _count: LeaveCountAggregateOutputType | null
    _avg: LeaveAvgAggregateOutputType | null
    _sum: LeaveSumAggregateOutputType | null
    _min: LeaveMinAggregateOutputType | null
    _max: LeaveMaxAggregateOutputType | null
  }

  export type LeaveAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    approvedBy: number | null
  }

  export type LeaveSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    approvedBy: number | null
  }

  export type LeaveMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    leaveType: $Enums.LeaveType | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.LeaveStatus | null
    reason: string | null
    approvedBy: number | null
    requestedAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    leaveType: $Enums.LeaveType | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.LeaveStatus | null
    reason: string | null
    approvedBy: number | null
    requestedAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveCountAggregateOutputType = {
    id: number
    employeeId: number
    leaveType: number
    startDate: number
    endDate: number
    status: number
    reason: number
    approvedBy: number
    requestedAt: number
    updatedAt: number
    _all: number
  }


  export type LeaveAvgAggregateInputType = {
    id?: true
    employeeId?: true
    approvedBy?: true
  }

  export type LeaveSumAggregateInputType = {
    id?: true
    employeeId?: true
    approvedBy?: true
  }

  export type LeaveMinAggregateInputType = {
    id?: true
    employeeId?: true
    leaveType?: true
    startDate?: true
    endDate?: true
    status?: true
    reason?: true
    approvedBy?: true
    requestedAt?: true
    updatedAt?: true
  }

  export type LeaveMaxAggregateInputType = {
    id?: true
    employeeId?: true
    leaveType?: true
    startDate?: true
    endDate?: true
    status?: true
    reason?: true
    approvedBy?: true
    requestedAt?: true
    updatedAt?: true
  }

  export type LeaveCountAggregateInputType = {
    id?: true
    employeeId?: true
    leaveType?: true
    startDate?: true
    endDate?: true
    status?: true
    reason?: true
    approvedBy?: true
    requestedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeaveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leave to aggregate.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leaves
    **/
    _count?: true | LeaveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveMaxAggregateInputType
  }

  export type GetLeaveAggregateType<T extends LeaveAggregateArgs> = {
        [P in keyof T & keyof AggregateLeave]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeave[P]>
      : GetScalarType<T[P], AggregateLeave[P]>
  }




  export type LeaveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveWhereInput
    orderBy?: LeaveOrderByWithAggregationInput | LeaveOrderByWithAggregationInput[]
    by: LeaveScalarFieldEnum[] | LeaveScalarFieldEnum
    having?: LeaveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveCountAggregateInputType | true
    _avg?: LeaveAvgAggregateInputType
    _sum?: LeaveSumAggregateInputType
    _min?: LeaveMinAggregateInputType
    _max?: LeaveMaxAggregateInputType
  }

  export type LeaveGroupByOutputType = {
    id: number
    employeeId: number
    leaveType: $Enums.LeaveType
    startDate: Date
    endDate: Date
    status: $Enums.LeaveStatus
    reason: string | null
    approvedBy: number | null
    requestedAt: Date
    updatedAt: Date
    _count: LeaveCountAggregateOutputType | null
    _avg: LeaveAvgAggregateOutputType | null
    _sum: LeaveSumAggregateOutputType | null
    _min: LeaveMinAggregateOutputType | null
    _max: LeaveMaxAggregateOutputType | null
  }

  type GetLeaveGroupByPayload<T extends LeaveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveGroupByOutputType[P]>
        }
      >
    >


  export type LeaveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    leaveType?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    reason?: boolean
    approvedBy?: boolean
    requestedAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    approver?: boolean | Leave$approverArgs<ExtArgs>
  }, ExtArgs["result"]["leave"]>



  export type LeaveSelectScalar = {
    id?: boolean
    employeeId?: boolean
    leaveType?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    reason?: boolean
    approvedBy?: boolean
    requestedAt?: boolean
    updatedAt?: boolean
  }

  export type LeaveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "leaveType" | "startDate" | "endDate" | "status" | "reason" | "approvedBy" | "requestedAt" | "updatedAt", ExtArgs["result"]["leave"]>
  export type LeaveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    approver?: boolean | Leave$approverArgs<ExtArgs>
  }

  export type $LeavePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Leave"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      approver: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      leaveType: $Enums.LeaveType
      startDate: Date
      endDate: Date
      status: $Enums.LeaveStatus
      reason: string | null
      approvedBy: number | null
      requestedAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leave"]>
    composites: {}
  }

  type LeaveGetPayload<S extends boolean | null | undefined | LeaveDefaultArgs> = $Result.GetResult<Prisma.$LeavePayload, S>

  type LeaveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeaveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeaveCountAggregateInputType | true
    }

  export interface LeaveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Leave'], meta: { name: 'Leave' } }
    /**
     * Find zero or one Leave that matches the filter.
     * @param {LeaveFindUniqueArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaveFindUniqueArgs>(args: SelectSubset<T, LeaveFindUniqueArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Leave that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeaveFindUniqueOrThrowArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaveFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Leave that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveFindFirstArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaveFindFirstArgs>(args?: SelectSubset<T, LeaveFindFirstArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Leave that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveFindFirstOrThrowArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaveFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaveFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leaves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leaves
     * const leaves = await prisma.leave.findMany()
     * 
     * // Get first 10 Leaves
     * const leaves = await prisma.leave.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveWithIdOnly = await prisma.leave.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaveFindManyArgs>(args?: SelectSubset<T, LeaveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Leave.
     * @param {LeaveCreateArgs} args - Arguments to create a Leave.
     * @example
     * // Create one Leave
     * const Leave = await prisma.leave.create({
     *   data: {
     *     // ... data to create a Leave
     *   }
     * })
     * 
     */
    create<T extends LeaveCreateArgs>(args: SelectSubset<T, LeaveCreateArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leaves.
     * @param {LeaveCreateManyArgs} args - Arguments to create many Leaves.
     * @example
     * // Create many Leaves
     * const leave = await prisma.leave.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaveCreateManyArgs>(args?: SelectSubset<T, LeaveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Leave.
     * @param {LeaveDeleteArgs} args - Arguments to delete one Leave.
     * @example
     * // Delete one Leave
     * const Leave = await prisma.leave.delete({
     *   where: {
     *     // ... filter to delete one Leave
     *   }
     * })
     * 
     */
    delete<T extends LeaveDeleteArgs>(args: SelectSubset<T, LeaveDeleteArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Leave.
     * @param {LeaveUpdateArgs} args - Arguments to update one Leave.
     * @example
     * // Update one Leave
     * const leave = await prisma.leave.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaveUpdateArgs>(args: SelectSubset<T, LeaveUpdateArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leaves.
     * @param {LeaveDeleteManyArgs} args - Arguments to filter Leaves to delete.
     * @example
     * // Delete a few Leaves
     * const { count } = await prisma.leave.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaveDeleteManyArgs>(args?: SelectSubset<T, LeaveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leaves
     * const leave = await prisma.leave.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaveUpdateManyArgs>(args: SelectSubset<T, LeaveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Leave.
     * @param {LeaveUpsertArgs} args - Arguments to update or create a Leave.
     * @example
     * // Update or create a Leave
     * const leave = await prisma.leave.upsert({
     *   create: {
     *     // ... data to create a Leave
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Leave we want to update
     *   }
     * })
     */
    upsert<T extends LeaveUpsertArgs>(args: SelectSubset<T, LeaveUpsertArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveCountArgs} args - Arguments to filter Leaves to count.
     * @example
     * // Count the number of Leaves
     * const count = await prisma.leave.count({
     *   where: {
     *     // ... the filter for the Leaves we want to count
     *   }
     * })
    **/
    count<T extends LeaveCountArgs>(
      args?: Subset<T, LeaveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Leave.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveAggregateArgs>(args: Subset<T, LeaveAggregateArgs>): Prisma.PrismaPromise<GetLeaveAggregateType<T>>

    /**
     * Group by Leave.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveGroupByArgs['orderBy'] }
        : { orderBy?: LeaveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Leave model
   */
  readonly fields: LeaveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Leave.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approver<T extends Leave$approverArgs<ExtArgs> = {}>(args?: Subset<T, Leave$approverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Leave model
   */
  interface LeaveFieldRefs {
    readonly id: FieldRef<"Leave", 'Int'>
    readonly employeeId: FieldRef<"Leave", 'Int'>
    readonly leaveType: FieldRef<"Leave", 'LeaveType'>
    readonly startDate: FieldRef<"Leave", 'DateTime'>
    readonly endDate: FieldRef<"Leave", 'DateTime'>
    readonly status: FieldRef<"Leave", 'LeaveStatus'>
    readonly reason: FieldRef<"Leave", 'String'>
    readonly approvedBy: FieldRef<"Leave", 'Int'>
    readonly requestedAt: FieldRef<"Leave", 'DateTime'>
    readonly updatedAt: FieldRef<"Leave", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Leave findUnique
   */
  export type LeaveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave findUniqueOrThrow
   */
  export type LeaveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave findFirst
   */
  export type LeaveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leaves.
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leaves.
     */
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Leave findFirstOrThrow
   */
  export type LeaveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leaves.
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leaves.
     */
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Leave findMany
   */
  export type LeaveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leaves to fetch.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leaves.
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Leave create
   */
  export type LeaveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * The data needed to create a Leave.
     */
    data: XOR<LeaveCreateInput, LeaveUncheckedCreateInput>
  }

  /**
   * Leave createMany
   */
  export type LeaveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leaves.
     */
    data: LeaveCreateManyInput | LeaveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Leave update
   */
  export type LeaveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * The data needed to update a Leave.
     */
    data: XOR<LeaveUpdateInput, LeaveUncheckedUpdateInput>
    /**
     * Choose, which Leave to update.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave updateMany
   */
  export type LeaveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leaves.
     */
    data: XOR<LeaveUpdateManyMutationInput, LeaveUncheckedUpdateManyInput>
    /**
     * Filter which Leaves to update
     */
    where?: LeaveWhereInput
    /**
     * Limit how many Leaves to update.
     */
    limit?: number
  }

  /**
   * Leave upsert
   */
  export type LeaveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * The filter to search for the Leave to update in case it exists.
     */
    where: LeaveWhereUniqueInput
    /**
     * In case the Leave found by the `where` argument doesn't exist, create a new Leave with this data.
     */
    create: XOR<LeaveCreateInput, LeaveUncheckedCreateInput>
    /**
     * In case the Leave was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveUpdateInput, LeaveUncheckedUpdateInput>
  }

  /**
   * Leave delete
   */
  export type LeaveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter which Leave to delete.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave deleteMany
   */
  export type LeaveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leaves to delete
     */
    where?: LeaveWhereInput
    /**
     * Limit how many Leaves to delete.
     */
    limit?: number
  }

  /**
   * Leave.approver
   */
  export type Leave$approverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Leave without action
   */
  export type LeaveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
  }


  /**
   * Model Holiday
   */

  export type AggregateHoliday = {
    _count: HolidayCountAggregateOutputType | null
    _avg: HolidayAvgAggregateOutputType | null
    _sum: HolidaySumAggregateOutputType | null
    _min: HolidayMinAggregateOutputType | null
    _max: HolidayMaxAggregateOutputType | null
  }

  export type HolidayAvgAggregateOutputType = {
    id: number | null
  }

  export type HolidaySumAggregateOutputType = {
    id: number | null
  }

  export type HolidayMinAggregateOutputType = {
    id: number | null
    name: string | null
    date: Date | null
    isPublic: boolean | null
    description: string | null
  }

  export type HolidayMaxAggregateOutputType = {
    id: number | null
    name: string | null
    date: Date | null
    isPublic: boolean | null
    description: string | null
  }

  export type HolidayCountAggregateOutputType = {
    id: number
    name: number
    date: number
    isPublic: number
    description: number
    _all: number
  }


  export type HolidayAvgAggregateInputType = {
    id?: true
  }

  export type HolidaySumAggregateInputType = {
    id?: true
  }

  export type HolidayMinAggregateInputType = {
    id?: true
    name?: true
    date?: true
    isPublic?: true
    description?: true
  }

  export type HolidayMaxAggregateInputType = {
    id?: true
    name?: true
    date?: true
    isPublic?: true
    description?: true
  }

  export type HolidayCountAggregateInputType = {
    id?: true
    name?: true
    date?: true
    isPublic?: true
    description?: true
    _all?: true
  }

  export type HolidayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Holiday to aggregate.
     */
    where?: HolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holidays to fetch.
     */
    orderBy?: HolidayOrderByWithRelationInput | HolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Holidays
    **/
    _count?: true | HolidayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HolidayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HolidaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HolidayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HolidayMaxAggregateInputType
  }

  export type GetHolidayAggregateType<T extends HolidayAggregateArgs> = {
        [P in keyof T & keyof AggregateHoliday]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHoliday[P]>
      : GetScalarType<T[P], AggregateHoliday[P]>
  }




  export type HolidayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HolidayWhereInput
    orderBy?: HolidayOrderByWithAggregationInput | HolidayOrderByWithAggregationInput[]
    by: HolidayScalarFieldEnum[] | HolidayScalarFieldEnum
    having?: HolidayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HolidayCountAggregateInputType | true
    _avg?: HolidayAvgAggregateInputType
    _sum?: HolidaySumAggregateInputType
    _min?: HolidayMinAggregateInputType
    _max?: HolidayMaxAggregateInputType
  }

  export type HolidayGroupByOutputType = {
    id: number
    name: string
    date: Date
    isPublic: boolean
    description: string | null
    _count: HolidayCountAggregateOutputType | null
    _avg: HolidayAvgAggregateOutputType | null
    _sum: HolidaySumAggregateOutputType | null
    _min: HolidayMinAggregateOutputType | null
    _max: HolidayMaxAggregateOutputType | null
  }

  type GetHolidayGroupByPayload<T extends HolidayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HolidayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HolidayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HolidayGroupByOutputType[P]>
            : GetScalarType<T[P], HolidayGroupByOutputType[P]>
        }
      >
    >


  export type HolidaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    date?: boolean
    isPublic?: boolean
    description?: boolean
  }, ExtArgs["result"]["holiday"]>



  export type HolidaySelectScalar = {
    id?: boolean
    name?: boolean
    date?: boolean
    isPublic?: boolean
    description?: boolean
  }

  export type HolidayOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "date" | "isPublic" | "description", ExtArgs["result"]["holiday"]>

  export type $HolidayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Holiday"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      date: Date
      isPublic: boolean
      description: string | null
    }, ExtArgs["result"]["holiday"]>
    composites: {}
  }

  type HolidayGetPayload<S extends boolean | null | undefined | HolidayDefaultArgs> = $Result.GetResult<Prisma.$HolidayPayload, S>

  type HolidayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HolidayFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HolidayCountAggregateInputType | true
    }

  export interface HolidayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Holiday'], meta: { name: 'Holiday' } }
    /**
     * Find zero or one Holiday that matches the filter.
     * @param {HolidayFindUniqueArgs} args - Arguments to find a Holiday
     * @example
     * // Get one Holiday
     * const holiday = await prisma.holiday.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HolidayFindUniqueArgs>(args: SelectSubset<T, HolidayFindUniqueArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Holiday that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HolidayFindUniqueOrThrowArgs} args - Arguments to find a Holiday
     * @example
     * // Get one Holiday
     * const holiday = await prisma.holiday.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HolidayFindUniqueOrThrowArgs>(args: SelectSubset<T, HolidayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Holiday that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayFindFirstArgs} args - Arguments to find a Holiday
     * @example
     * // Get one Holiday
     * const holiday = await prisma.holiday.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HolidayFindFirstArgs>(args?: SelectSubset<T, HolidayFindFirstArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Holiday that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayFindFirstOrThrowArgs} args - Arguments to find a Holiday
     * @example
     * // Get one Holiday
     * const holiday = await prisma.holiday.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HolidayFindFirstOrThrowArgs>(args?: SelectSubset<T, HolidayFindFirstOrThrowArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Holidays that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Holidays
     * const holidays = await prisma.holiday.findMany()
     * 
     * // Get first 10 Holidays
     * const holidays = await prisma.holiday.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const holidayWithIdOnly = await prisma.holiday.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HolidayFindManyArgs>(args?: SelectSubset<T, HolidayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Holiday.
     * @param {HolidayCreateArgs} args - Arguments to create a Holiday.
     * @example
     * // Create one Holiday
     * const Holiday = await prisma.holiday.create({
     *   data: {
     *     // ... data to create a Holiday
     *   }
     * })
     * 
     */
    create<T extends HolidayCreateArgs>(args: SelectSubset<T, HolidayCreateArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Holidays.
     * @param {HolidayCreateManyArgs} args - Arguments to create many Holidays.
     * @example
     * // Create many Holidays
     * const holiday = await prisma.holiday.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HolidayCreateManyArgs>(args?: SelectSubset<T, HolidayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Holiday.
     * @param {HolidayDeleteArgs} args - Arguments to delete one Holiday.
     * @example
     * // Delete one Holiday
     * const Holiday = await prisma.holiday.delete({
     *   where: {
     *     // ... filter to delete one Holiday
     *   }
     * })
     * 
     */
    delete<T extends HolidayDeleteArgs>(args: SelectSubset<T, HolidayDeleteArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Holiday.
     * @param {HolidayUpdateArgs} args - Arguments to update one Holiday.
     * @example
     * // Update one Holiday
     * const holiday = await prisma.holiday.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HolidayUpdateArgs>(args: SelectSubset<T, HolidayUpdateArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Holidays.
     * @param {HolidayDeleteManyArgs} args - Arguments to filter Holidays to delete.
     * @example
     * // Delete a few Holidays
     * const { count } = await prisma.holiday.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HolidayDeleteManyArgs>(args?: SelectSubset<T, HolidayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Holidays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Holidays
     * const holiday = await prisma.holiday.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HolidayUpdateManyArgs>(args: SelectSubset<T, HolidayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Holiday.
     * @param {HolidayUpsertArgs} args - Arguments to update or create a Holiday.
     * @example
     * // Update or create a Holiday
     * const holiday = await prisma.holiday.upsert({
     *   create: {
     *     // ... data to create a Holiday
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Holiday we want to update
     *   }
     * })
     */
    upsert<T extends HolidayUpsertArgs>(args: SelectSubset<T, HolidayUpsertArgs<ExtArgs>>): Prisma__HolidayClient<$Result.GetResult<Prisma.$HolidayPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Holidays.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayCountArgs} args - Arguments to filter Holidays to count.
     * @example
     * // Count the number of Holidays
     * const count = await prisma.holiday.count({
     *   where: {
     *     // ... the filter for the Holidays we want to count
     *   }
     * })
    **/
    count<T extends HolidayCountArgs>(
      args?: Subset<T, HolidayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HolidayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Holiday.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HolidayAggregateArgs>(args: Subset<T, HolidayAggregateArgs>): Prisma.PrismaPromise<GetHolidayAggregateType<T>>

    /**
     * Group by Holiday.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HolidayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HolidayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HolidayGroupByArgs['orderBy'] }
        : { orderBy?: HolidayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HolidayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHolidayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Holiday model
   */
  readonly fields: HolidayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Holiday.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HolidayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Holiday model
   */
  interface HolidayFieldRefs {
    readonly id: FieldRef<"Holiday", 'Int'>
    readonly name: FieldRef<"Holiday", 'String'>
    readonly date: FieldRef<"Holiday", 'DateTime'>
    readonly isPublic: FieldRef<"Holiday", 'Boolean'>
    readonly description: FieldRef<"Holiday", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Holiday findUnique
   */
  export type HolidayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * Filter, which Holiday to fetch.
     */
    where: HolidayWhereUniqueInput
  }

  /**
   * Holiday findUniqueOrThrow
   */
  export type HolidayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * Filter, which Holiday to fetch.
     */
    where: HolidayWhereUniqueInput
  }

  /**
   * Holiday findFirst
   */
  export type HolidayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * Filter, which Holiday to fetch.
     */
    where?: HolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holidays to fetch.
     */
    orderBy?: HolidayOrderByWithRelationInput | HolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Holidays.
     */
    cursor?: HolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Holidays.
     */
    distinct?: HolidayScalarFieldEnum | HolidayScalarFieldEnum[]
  }

  /**
   * Holiday findFirstOrThrow
   */
  export type HolidayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * Filter, which Holiday to fetch.
     */
    where?: HolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holidays to fetch.
     */
    orderBy?: HolidayOrderByWithRelationInput | HolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Holidays.
     */
    cursor?: HolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holidays.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Holidays.
     */
    distinct?: HolidayScalarFieldEnum | HolidayScalarFieldEnum[]
  }

  /**
   * Holiday findMany
   */
  export type HolidayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * Filter, which Holidays to fetch.
     */
    where?: HolidayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Holidays to fetch.
     */
    orderBy?: HolidayOrderByWithRelationInput | HolidayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Holidays.
     */
    cursor?: HolidayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Holidays from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Holidays.
     */
    skip?: number
    distinct?: HolidayScalarFieldEnum | HolidayScalarFieldEnum[]
  }

  /**
   * Holiday create
   */
  export type HolidayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * The data needed to create a Holiday.
     */
    data: XOR<HolidayCreateInput, HolidayUncheckedCreateInput>
  }

  /**
   * Holiday createMany
   */
  export type HolidayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Holidays.
     */
    data: HolidayCreateManyInput | HolidayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Holiday update
   */
  export type HolidayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * The data needed to update a Holiday.
     */
    data: XOR<HolidayUpdateInput, HolidayUncheckedUpdateInput>
    /**
     * Choose, which Holiday to update.
     */
    where: HolidayWhereUniqueInput
  }

  /**
   * Holiday updateMany
   */
  export type HolidayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Holidays.
     */
    data: XOR<HolidayUpdateManyMutationInput, HolidayUncheckedUpdateManyInput>
    /**
     * Filter which Holidays to update
     */
    where?: HolidayWhereInput
    /**
     * Limit how many Holidays to update.
     */
    limit?: number
  }

  /**
   * Holiday upsert
   */
  export type HolidayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * The filter to search for the Holiday to update in case it exists.
     */
    where: HolidayWhereUniqueInput
    /**
     * In case the Holiday found by the `where` argument doesn't exist, create a new Holiday with this data.
     */
    create: XOR<HolidayCreateInput, HolidayUncheckedCreateInput>
    /**
     * In case the Holiday was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HolidayUpdateInput, HolidayUncheckedUpdateInput>
  }

  /**
   * Holiday delete
   */
  export type HolidayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
    /**
     * Filter which Holiday to delete.
     */
    where: HolidayWhereUniqueInput
  }

  /**
   * Holiday deleteMany
   */
  export type HolidayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Holidays to delete
     */
    where?: HolidayWhereInput
    /**
     * Limit how many Holidays to delete.
     */
    limit?: number
  }

  /**
   * Holiday without action
   */
  export type HolidayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Holiday
     */
    select?: HolidaySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Holiday
     */
    omit?: HolidayOmit<ExtArgs> | null
  }


  /**
   * Model OvertimeLog
   */

  export type AggregateOvertimeLog = {
    _count: OvertimeLogCountAggregateOutputType | null
    _avg: OvertimeLogAvgAggregateOutputType | null
    _sum: OvertimeLogSumAggregateOutputType | null
    _min: OvertimeLogMinAggregateOutputType | null
    _max: OvertimeLogMaxAggregateOutputType | null
  }

  export type OvertimeLogAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    hours: Decimal | null
    approvedBy: number | null
  }

  export type OvertimeLogSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    hours: Decimal | null
    approvedBy: number | null
  }

  export type OvertimeLogMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    date: Date | null
    hours: Decimal | null
    startTime: Date | null
    endTime: Date | null
    reason: string | null
    approvedBy: number | null
    approvalStatus: $Enums.OvertimeApprovalStatus | null
    compensationMethod: $Enums.CompensationMethod | null
  }

  export type OvertimeLogMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    date: Date | null
    hours: Decimal | null
    startTime: Date | null
    endTime: Date | null
    reason: string | null
    approvedBy: number | null
    approvalStatus: $Enums.OvertimeApprovalStatus | null
    compensationMethod: $Enums.CompensationMethod | null
  }

  export type OvertimeLogCountAggregateOutputType = {
    id: number
    employeeId: number
    date: number
    hours: number
    startTime: number
    endTime: number
    reason: number
    approvedBy: number
    approvalStatus: number
    compensationMethod: number
    _all: number
  }


  export type OvertimeLogAvgAggregateInputType = {
    id?: true
    employeeId?: true
    hours?: true
    approvedBy?: true
  }

  export type OvertimeLogSumAggregateInputType = {
    id?: true
    employeeId?: true
    hours?: true
    approvedBy?: true
  }

  export type OvertimeLogMinAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    hours?: true
    startTime?: true
    endTime?: true
    reason?: true
    approvedBy?: true
    approvalStatus?: true
    compensationMethod?: true
  }

  export type OvertimeLogMaxAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    hours?: true
    startTime?: true
    endTime?: true
    reason?: true
    approvedBy?: true
    approvalStatus?: true
    compensationMethod?: true
  }

  export type OvertimeLogCountAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    hours?: true
    startTime?: true
    endTime?: true
    reason?: true
    approvedBy?: true
    approvalStatus?: true
    compensationMethod?: true
    _all?: true
  }

  export type OvertimeLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OvertimeLog to aggregate.
     */
    where?: OvertimeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OvertimeLogs to fetch.
     */
    orderBy?: OvertimeLogOrderByWithRelationInput | OvertimeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OvertimeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OvertimeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OvertimeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OvertimeLogs
    **/
    _count?: true | OvertimeLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OvertimeLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OvertimeLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OvertimeLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OvertimeLogMaxAggregateInputType
  }

  export type GetOvertimeLogAggregateType<T extends OvertimeLogAggregateArgs> = {
        [P in keyof T & keyof AggregateOvertimeLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOvertimeLog[P]>
      : GetScalarType<T[P], AggregateOvertimeLog[P]>
  }




  export type OvertimeLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OvertimeLogWhereInput
    orderBy?: OvertimeLogOrderByWithAggregationInput | OvertimeLogOrderByWithAggregationInput[]
    by: OvertimeLogScalarFieldEnum[] | OvertimeLogScalarFieldEnum
    having?: OvertimeLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OvertimeLogCountAggregateInputType | true
    _avg?: OvertimeLogAvgAggregateInputType
    _sum?: OvertimeLogSumAggregateInputType
    _min?: OvertimeLogMinAggregateInputType
    _max?: OvertimeLogMaxAggregateInputType
  }

  export type OvertimeLogGroupByOutputType = {
    id: number
    employeeId: number
    date: Date
    hours: Decimal | null
    startTime: Date
    endTime: Date
    reason: string | null
    approvedBy: number | null
    approvalStatus: $Enums.OvertimeApprovalStatus
    compensationMethod: $Enums.CompensationMethod
    _count: OvertimeLogCountAggregateOutputType | null
    _avg: OvertimeLogAvgAggregateOutputType | null
    _sum: OvertimeLogSumAggregateOutputType | null
    _min: OvertimeLogMinAggregateOutputType | null
    _max: OvertimeLogMaxAggregateOutputType | null
  }

  type GetOvertimeLogGroupByPayload<T extends OvertimeLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OvertimeLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OvertimeLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OvertimeLogGroupByOutputType[P]>
            : GetScalarType<T[P], OvertimeLogGroupByOutputType[P]>
        }
      >
    >


  export type OvertimeLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    date?: boolean
    hours?: boolean
    startTime?: boolean
    endTime?: boolean
    reason?: boolean
    approvedBy?: boolean
    approvalStatus?: boolean
    compensationMethod?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    approver?: boolean | OvertimeLog$approverArgs<ExtArgs>
  }, ExtArgs["result"]["overtimeLog"]>



  export type OvertimeLogSelectScalar = {
    id?: boolean
    employeeId?: boolean
    date?: boolean
    hours?: boolean
    startTime?: boolean
    endTime?: boolean
    reason?: boolean
    approvedBy?: boolean
    approvalStatus?: boolean
    compensationMethod?: boolean
  }

  export type OvertimeLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "date" | "hours" | "startTime" | "endTime" | "reason" | "approvedBy" | "approvalStatus" | "compensationMethod", ExtArgs["result"]["overtimeLog"]>
  export type OvertimeLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    approver?: boolean | OvertimeLog$approverArgs<ExtArgs>
  }

  export type $OvertimeLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OvertimeLog"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      approver: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      date: Date
      hours: Prisma.Decimal | null
      startTime: Date
      endTime: Date
      reason: string | null
      approvedBy: number | null
      approvalStatus: $Enums.OvertimeApprovalStatus
      compensationMethod: $Enums.CompensationMethod
    }, ExtArgs["result"]["overtimeLog"]>
    composites: {}
  }

  type OvertimeLogGetPayload<S extends boolean | null | undefined | OvertimeLogDefaultArgs> = $Result.GetResult<Prisma.$OvertimeLogPayload, S>

  type OvertimeLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OvertimeLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OvertimeLogCountAggregateInputType | true
    }

  export interface OvertimeLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OvertimeLog'], meta: { name: 'OvertimeLog' } }
    /**
     * Find zero or one OvertimeLog that matches the filter.
     * @param {OvertimeLogFindUniqueArgs} args - Arguments to find a OvertimeLog
     * @example
     * // Get one OvertimeLog
     * const overtimeLog = await prisma.overtimeLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OvertimeLogFindUniqueArgs>(args: SelectSubset<T, OvertimeLogFindUniqueArgs<ExtArgs>>): Prisma__OvertimeLogClient<$Result.GetResult<Prisma.$OvertimeLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OvertimeLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OvertimeLogFindUniqueOrThrowArgs} args - Arguments to find a OvertimeLog
     * @example
     * // Get one OvertimeLog
     * const overtimeLog = await prisma.overtimeLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OvertimeLogFindUniqueOrThrowArgs>(args: SelectSubset<T, OvertimeLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OvertimeLogClient<$Result.GetResult<Prisma.$OvertimeLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OvertimeLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimeLogFindFirstArgs} args - Arguments to find a OvertimeLog
     * @example
     * // Get one OvertimeLog
     * const overtimeLog = await prisma.overtimeLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OvertimeLogFindFirstArgs>(args?: SelectSubset<T, OvertimeLogFindFirstArgs<ExtArgs>>): Prisma__OvertimeLogClient<$Result.GetResult<Prisma.$OvertimeLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OvertimeLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimeLogFindFirstOrThrowArgs} args - Arguments to find a OvertimeLog
     * @example
     * // Get one OvertimeLog
     * const overtimeLog = await prisma.overtimeLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OvertimeLogFindFirstOrThrowArgs>(args?: SelectSubset<T, OvertimeLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__OvertimeLogClient<$Result.GetResult<Prisma.$OvertimeLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OvertimeLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimeLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OvertimeLogs
     * const overtimeLogs = await prisma.overtimeLog.findMany()
     * 
     * // Get first 10 OvertimeLogs
     * const overtimeLogs = await prisma.overtimeLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const overtimeLogWithIdOnly = await prisma.overtimeLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OvertimeLogFindManyArgs>(args?: SelectSubset<T, OvertimeLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OvertimeLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OvertimeLog.
     * @param {OvertimeLogCreateArgs} args - Arguments to create a OvertimeLog.
     * @example
     * // Create one OvertimeLog
     * const OvertimeLog = await prisma.overtimeLog.create({
     *   data: {
     *     // ... data to create a OvertimeLog
     *   }
     * })
     * 
     */
    create<T extends OvertimeLogCreateArgs>(args: SelectSubset<T, OvertimeLogCreateArgs<ExtArgs>>): Prisma__OvertimeLogClient<$Result.GetResult<Prisma.$OvertimeLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OvertimeLogs.
     * @param {OvertimeLogCreateManyArgs} args - Arguments to create many OvertimeLogs.
     * @example
     * // Create many OvertimeLogs
     * const overtimeLog = await prisma.overtimeLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OvertimeLogCreateManyArgs>(args?: SelectSubset<T, OvertimeLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OvertimeLog.
     * @param {OvertimeLogDeleteArgs} args - Arguments to delete one OvertimeLog.
     * @example
     * // Delete one OvertimeLog
     * const OvertimeLog = await prisma.overtimeLog.delete({
     *   where: {
     *     // ... filter to delete one OvertimeLog
     *   }
     * })
     * 
     */
    delete<T extends OvertimeLogDeleteArgs>(args: SelectSubset<T, OvertimeLogDeleteArgs<ExtArgs>>): Prisma__OvertimeLogClient<$Result.GetResult<Prisma.$OvertimeLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OvertimeLog.
     * @param {OvertimeLogUpdateArgs} args - Arguments to update one OvertimeLog.
     * @example
     * // Update one OvertimeLog
     * const overtimeLog = await prisma.overtimeLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OvertimeLogUpdateArgs>(args: SelectSubset<T, OvertimeLogUpdateArgs<ExtArgs>>): Prisma__OvertimeLogClient<$Result.GetResult<Prisma.$OvertimeLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OvertimeLogs.
     * @param {OvertimeLogDeleteManyArgs} args - Arguments to filter OvertimeLogs to delete.
     * @example
     * // Delete a few OvertimeLogs
     * const { count } = await prisma.overtimeLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OvertimeLogDeleteManyArgs>(args?: SelectSubset<T, OvertimeLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OvertimeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimeLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OvertimeLogs
     * const overtimeLog = await prisma.overtimeLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OvertimeLogUpdateManyArgs>(args: SelectSubset<T, OvertimeLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OvertimeLog.
     * @param {OvertimeLogUpsertArgs} args - Arguments to update or create a OvertimeLog.
     * @example
     * // Update or create a OvertimeLog
     * const overtimeLog = await prisma.overtimeLog.upsert({
     *   create: {
     *     // ... data to create a OvertimeLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OvertimeLog we want to update
     *   }
     * })
     */
    upsert<T extends OvertimeLogUpsertArgs>(args: SelectSubset<T, OvertimeLogUpsertArgs<ExtArgs>>): Prisma__OvertimeLogClient<$Result.GetResult<Prisma.$OvertimeLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OvertimeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimeLogCountArgs} args - Arguments to filter OvertimeLogs to count.
     * @example
     * // Count the number of OvertimeLogs
     * const count = await prisma.overtimeLog.count({
     *   where: {
     *     // ... the filter for the OvertimeLogs we want to count
     *   }
     * })
    **/
    count<T extends OvertimeLogCountArgs>(
      args?: Subset<T, OvertimeLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OvertimeLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OvertimeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimeLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OvertimeLogAggregateArgs>(args: Subset<T, OvertimeLogAggregateArgs>): Prisma.PrismaPromise<GetOvertimeLogAggregateType<T>>

    /**
     * Group by OvertimeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimeLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OvertimeLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OvertimeLogGroupByArgs['orderBy'] }
        : { orderBy?: OvertimeLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OvertimeLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOvertimeLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OvertimeLog model
   */
  readonly fields: OvertimeLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OvertimeLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OvertimeLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approver<T extends OvertimeLog$approverArgs<ExtArgs> = {}>(args?: Subset<T, OvertimeLog$approverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OvertimeLog model
   */
  interface OvertimeLogFieldRefs {
    readonly id: FieldRef<"OvertimeLog", 'Int'>
    readonly employeeId: FieldRef<"OvertimeLog", 'Int'>
    readonly date: FieldRef<"OvertimeLog", 'DateTime'>
    readonly hours: FieldRef<"OvertimeLog", 'Decimal'>
    readonly startTime: FieldRef<"OvertimeLog", 'DateTime'>
    readonly endTime: FieldRef<"OvertimeLog", 'DateTime'>
    readonly reason: FieldRef<"OvertimeLog", 'String'>
    readonly approvedBy: FieldRef<"OvertimeLog", 'Int'>
    readonly approvalStatus: FieldRef<"OvertimeLog", 'OvertimeApprovalStatus'>
    readonly compensationMethod: FieldRef<"OvertimeLog", 'CompensationMethod'>
  }
    

  // Custom InputTypes
  /**
   * OvertimeLog findUnique
   */
  export type OvertimeLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OvertimeLog
     */
    select?: OvertimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OvertimeLog
     */
    omit?: OvertimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeLogInclude<ExtArgs> | null
    /**
     * Filter, which OvertimeLog to fetch.
     */
    where: OvertimeLogWhereUniqueInput
  }

  /**
   * OvertimeLog findUniqueOrThrow
   */
  export type OvertimeLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OvertimeLog
     */
    select?: OvertimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OvertimeLog
     */
    omit?: OvertimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeLogInclude<ExtArgs> | null
    /**
     * Filter, which OvertimeLog to fetch.
     */
    where: OvertimeLogWhereUniqueInput
  }

  /**
   * OvertimeLog findFirst
   */
  export type OvertimeLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OvertimeLog
     */
    select?: OvertimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OvertimeLog
     */
    omit?: OvertimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeLogInclude<ExtArgs> | null
    /**
     * Filter, which OvertimeLog to fetch.
     */
    where?: OvertimeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OvertimeLogs to fetch.
     */
    orderBy?: OvertimeLogOrderByWithRelationInput | OvertimeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OvertimeLogs.
     */
    cursor?: OvertimeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OvertimeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OvertimeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OvertimeLogs.
     */
    distinct?: OvertimeLogScalarFieldEnum | OvertimeLogScalarFieldEnum[]
  }

  /**
   * OvertimeLog findFirstOrThrow
   */
  export type OvertimeLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OvertimeLog
     */
    select?: OvertimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OvertimeLog
     */
    omit?: OvertimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeLogInclude<ExtArgs> | null
    /**
     * Filter, which OvertimeLog to fetch.
     */
    where?: OvertimeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OvertimeLogs to fetch.
     */
    orderBy?: OvertimeLogOrderByWithRelationInput | OvertimeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OvertimeLogs.
     */
    cursor?: OvertimeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OvertimeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OvertimeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OvertimeLogs.
     */
    distinct?: OvertimeLogScalarFieldEnum | OvertimeLogScalarFieldEnum[]
  }

  /**
   * OvertimeLog findMany
   */
  export type OvertimeLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OvertimeLog
     */
    select?: OvertimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OvertimeLog
     */
    omit?: OvertimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeLogInclude<ExtArgs> | null
    /**
     * Filter, which OvertimeLogs to fetch.
     */
    where?: OvertimeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OvertimeLogs to fetch.
     */
    orderBy?: OvertimeLogOrderByWithRelationInput | OvertimeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OvertimeLogs.
     */
    cursor?: OvertimeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OvertimeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OvertimeLogs.
     */
    skip?: number
    distinct?: OvertimeLogScalarFieldEnum | OvertimeLogScalarFieldEnum[]
  }

  /**
   * OvertimeLog create
   */
  export type OvertimeLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OvertimeLog
     */
    select?: OvertimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OvertimeLog
     */
    omit?: OvertimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeLogInclude<ExtArgs> | null
    /**
     * The data needed to create a OvertimeLog.
     */
    data: XOR<OvertimeLogCreateInput, OvertimeLogUncheckedCreateInput>
  }

  /**
   * OvertimeLog createMany
   */
  export type OvertimeLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OvertimeLogs.
     */
    data: OvertimeLogCreateManyInput | OvertimeLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OvertimeLog update
   */
  export type OvertimeLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OvertimeLog
     */
    select?: OvertimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OvertimeLog
     */
    omit?: OvertimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeLogInclude<ExtArgs> | null
    /**
     * The data needed to update a OvertimeLog.
     */
    data: XOR<OvertimeLogUpdateInput, OvertimeLogUncheckedUpdateInput>
    /**
     * Choose, which OvertimeLog to update.
     */
    where: OvertimeLogWhereUniqueInput
  }

  /**
   * OvertimeLog updateMany
   */
  export type OvertimeLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OvertimeLogs.
     */
    data: XOR<OvertimeLogUpdateManyMutationInput, OvertimeLogUncheckedUpdateManyInput>
    /**
     * Filter which OvertimeLogs to update
     */
    where?: OvertimeLogWhereInput
    /**
     * Limit how many OvertimeLogs to update.
     */
    limit?: number
  }

  /**
   * OvertimeLog upsert
   */
  export type OvertimeLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OvertimeLog
     */
    select?: OvertimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OvertimeLog
     */
    omit?: OvertimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeLogInclude<ExtArgs> | null
    /**
     * The filter to search for the OvertimeLog to update in case it exists.
     */
    where: OvertimeLogWhereUniqueInput
    /**
     * In case the OvertimeLog found by the `where` argument doesn't exist, create a new OvertimeLog with this data.
     */
    create: XOR<OvertimeLogCreateInput, OvertimeLogUncheckedCreateInput>
    /**
     * In case the OvertimeLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OvertimeLogUpdateInput, OvertimeLogUncheckedUpdateInput>
  }

  /**
   * OvertimeLog delete
   */
  export type OvertimeLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OvertimeLog
     */
    select?: OvertimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OvertimeLog
     */
    omit?: OvertimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeLogInclude<ExtArgs> | null
    /**
     * Filter which OvertimeLog to delete.
     */
    where: OvertimeLogWhereUniqueInput
  }

  /**
   * OvertimeLog deleteMany
   */
  export type OvertimeLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OvertimeLogs to delete
     */
    where?: OvertimeLogWhereInput
    /**
     * Limit how many OvertimeLogs to delete.
     */
    limit?: number
  }

  /**
   * OvertimeLog.approver
   */
  export type OvertimeLog$approverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * OvertimeLog without action
   */
  export type OvertimeLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OvertimeLog
     */
    select?: OvertimeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OvertimeLog
     */
    omit?: OvertimeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeLogInclude<ExtArgs> | null
  }


  /**
   * Model Salary
   */

  export type AggregateSalary = {
    _count: SalaryCountAggregateOutputType | null
    _avg: SalaryAvgAggregateOutputType | null
    _sum: SalarySumAggregateOutputType | null
    _min: SalaryMinAggregateOutputType | null
    _max: SalaryMaxAggregateOutputType | null
  }

  export type SalaryAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    amount: Decimal | null
    overtimeHours: Decimal | null
    overtimePay: Decimal | null
  }

  export type SalarySumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    amount: Decimal | null
    overtimeHours: Decimal | null
    overtimePay: Decimal | null
  }

  export type SalaryMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    salaryMonth: Date | null
    amount: Decimal | null
    status: $Enums.SalaryStatus | null
    overtimeHours: Decimal | null
    overtimePay: Decimal | null
    paidAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalaryMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    salaryMonth: Date | null
    amount: Decimal | null
    status: $Enums.SalaryStatus | null
    overtimeHours: Decimal | null
    overtimePay: Decimal | null
    paidAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalaryCountAggregateOutputType = {
    id: number
    employeeId: number
    salaryMonth: number
    amount: number
    status: number
    overtimeHours: number
    overtimePay: number
    paidAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SalaryAvgAggregateInputType = {
    id?: true
    employeeId?: true
    amount?: true
    overtimeHours?: true
    overtimePay?: true
  }

  export type SalarySumAggregateInputType = {
    id?: true
    employeeId?: true
    amount?: true
    overtimeHours?: true
    overtimePay?: true
  }

  export type SalaryMinAggregateInputType = {
    id?: true
    employeeId?: true
    salaryMonth?: true
    amount?: true
    status?: true
    overtimeHours?: true
    overtimePay?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalaryMaxAggregateInputType = {
    id?: true
    employeeId?: true
    salaryMonth?: true
    amount?: true
    status?: true
    overtimeHours?: true
    overtimePay?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalaryCountAggregateInputType = {
    id?: true
    employeeId?: true
    salaryMonth?: true
    amount?: true
    status?: true
    overtimeHours?: true
    overtimePay?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Salary to aggregate.
     */
    where?: SalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salaries to fetch.
     */
    orderBy?: SalaryOrderByWithRelationInput | SalaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Salaries
    **/
    _count?: true | SalaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalaryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalaryMaxAggregateInputType
  }

  export type GetSalaryAggregateType<T extends SalaryAggregateArgs> = {
        [P in keyof T & keyof AggregateSalary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalary[P]>
      : GetScalarType<T[P], AggregateSalary[P]>
  }




  export type SalaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryWhereInput
    orderBy?: SalaryOrderByWithAggregationInput | SalaryOrderByWithAggregationInput[]
    by: SalaryScalarFieldEnum[] | SalaryScalarFieldEnum
    having?: SalaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalaryCountAggregateInputType | true
    _avg?: SalaryAvgAggregateInputType
    _sum?: SalarySumAggregateInputType
    _min?: SalaryMinAggregateInputType
    _max?: SalaryMaxAggregateInputType
  }

  export type SalaryGroupByOutputType = {
    id: number
    employeeId: number
    salaryMonth: Date
    amount: Decimal
    status: $Enums.SalaryStatus
    overtimeHours: Decimal
    overtimePay: Decimal
    paidAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SalaryCountAggregateOutputType | null
    _avg: SalaryAvgAggregateOutputType | null
    _sum: SalarySumAggregateOutputType | null
    _min: SalaryMinAggregateOutputType | null
    _max: SalaryMaxAggregateOutputType | null
  }

  type GetSalaryGroupByPayload<T extends SalaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalaryGroupByOutputType[P]>
            : GetScalarType<T[P], SalaryGroupByOutputType[P]>
        }
      >
    >


  export type SalarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    salaryMonth?: boolean
    amount?: boolean
    status?: boolean
    overtimeHours?: boolean
    overtimePay?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salary"]>



  export type SalarySelectScalar = {
    id?: boolean
    employeeId?: boolean
    salaryMonth?: boolean
    amount?: boolean
    status?: boolean
    overtimeHours?: boolean
    overtimePay?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SalaryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "salaryMonth" | "amount" | "status" | "overtimeHours" | "overtimePay" | "paidAt" | "createdAt" | "updatedAt", ExtArgs["result"]["salary"]>
  export type SalaryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $SalaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Salary"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      salaryMonth: Date
      amount: Prisma.Decimal
      status: $Enums.SalaryStatus
      overtimeHours: Prisma.Decimal
      overtimePay: Prisma.Decimal
      paidAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["salary"]>
    composites: {}
  }

  type SalaryGetPayload<S extends boolean | null | undefined | SalaryDefaultArgs> = $Result.GetResult<Prisma.$SalaryPayload, S>

  type SalaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalaryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalaryCountAggregateInputType | true
    }

  export interface SalaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Salary'], meta: { name: 'Salary' } }
    /**
     * Find zero or one Salary that matches the filter.
     * @param {SalaryFindUniqueArgs} args - Arguments to find a Salary
     * @example
     * // Get one Salary
     * const salary = await prisma.salary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalaryFindUniqueArgs>(args: SelectSubset<T, SalaryFindUniqueArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Salary that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalaryFindUniqueOrThrowArgs} args - Arguments to find a Salary
     * @example
     * // Get one Salary
     * const salary = await prisma.salary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalaryFindUniqueOrThrowArgs>(args: SelectSubset<T, SalaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Salary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryFindFirstArgs} args - Arguments to find a Salary
     * @example
     * // Get one Salary
     * const salary = await prisma.salary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalaryFindFirstArgs>(args?: SelectSubset<T, SalaryFindFirstArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Salary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryFindFirstOrThrowArgs} args - Arguments to find a Salary
     * @example
     * // Get one Salary
     * const salary = await prisma.salary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalaryFindFirstOrThrowArgs>(args?: SelectSubset<T, SalaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Salaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Salaries
     * const salaries = await prisma.salary.findMany()
     * 
     * // Get first 10 Salaries
     * const salaries = await prisma.salary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salaryWithIdOnly = await prisma.salary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalaryFindManyArgs>(args?: SelectSubset<T, SalaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Salary.
     * @param {SalaryCreateArgs} args - Arguments to create a Salary.
     * @example
     * // Create one Salary
     * const Salary = await prisma.salary.create({
     *   data: {
     *     // ... data to create a Salary
     *   }
     * })
     * 
     */
    create<T extends SalaryCreateArgs>(args: SelectSubset<T, SalaryCreateArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Salaries.
     * @param {SalaryCreateManyArgs} args - Arguments to create many Salaries.
     * @example
     * // Create many Salaries
     * const salary = await prisma.salary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalaryCreateManyArgs>(args?: SelectSubset<T, SalaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Salary.
     * @param {SalaryDeleteArgs} args - Arguments to delete one Salary.
     * @example
     * // Delete one Salary
     * const Salary = await prisma.salary.delete({
     *   where: {
     *     // ... filter to delete one Salary
     *   }
     * })
     * 
     */
    delete<T extends SalaryDeleteArgs>(args: SelectSubset<T, SalaryDeleteArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Salary.
     * @param {SalaryUpdateArgs} args - Arguments to update one Salary.
     * @example
     * // Update one Salary
     * const salary = await prisma.salary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalaryUpdateArgs>(args: SelectSubset<T, SalaryUpdateArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Salaries.
     * @param {SalaryDeleteManyArgs} args - Arguments to filter Salaries to delete.
     * @example
     * // Delete a few Salaries
     * const { count } = await prisma.salary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalaryDeleteManyArgs>(args?: SelectSubset<T, SalaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Salaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Salaries
     * const salary = await prisma.salary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalaryUpdateManyArgs>(args: SelectSubset<T, SalaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Salary.
     * @param {SalaryUpsertArgs} args - Arguments to update or create a Salary.
     * @example
     * // Update or create a Salary
     * const salary = await prisma.salary.upsert({
     *   create: {
     *     // ... data to create a Salary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Salary we want to update
     *   }
     * })
     */
    upsert<T extends SalaryUpsertArgs>(args: SelectSubset<T, SalaryUpsertArgs<ExtArgs>>): Prisma__SalaryClient<$Result.GetResult<Prisma.$SalaryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Salaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryCountArgs} args - Arguments to filter Salaries to count.
     * @example
     * // Count the number of Salaries
     * const count = await prisma.salary.count({
     *   where: {
     *     // ... the filter for the Salaries we want to count
     *   }
     * })
    **/
    count<T extends SalaryCountArgs>(
      args?: Subset<T, SalaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Salary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalaryAggregateArgs>(args: Subset<T, SalaryAggregateArgs>): Prisma.PrismaPromise<GetSalaryAggregateType<T>>

    /**
     * Group by Salary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalaryGroupByArgs['orderBy'] }
        : { orderBy?: SalaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Salary model
   */
  readonly fields: SalaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Salary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Salary model
   */
  interface SalaryFieldRefs {
    readonly id: FieldRef<"Salary", 'Int'>
    readonly employeeId: FieldRef<"Salary", 'Int'>
    readonly salaryMonth: FieldRef<"Salary", 'DateTime'>
    readonly amount: FieldRef<"Salary", 'Decimal'>
    readonly status: FieldRef<"Salary", 'SalaryStatus'>
    readonly overtimeHours: FieldRef<"Salary", 'Decimal'>
    readonly overtimePay: FieldRef<"Salary", 'Decimal'>
    readonly paidAt: FieldRef<"Salary", 'DateTime'>
    readonly createdAt: FieldRef<"Salary", 'DateTime'>
    readonly updatedAt: FieldRef<"Salary", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Salary findUnique
   */
  export type SalaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * Filter, which Salary to fetch.
     */
    where: SalaryWhereUniqueInput
  }

  /**
   * Salary findUniqueOrThrow
   */
  export type SalaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * Filter, which Salary to fetch.
     */
    where: SalaryWhereUniqueInput
  }

  /**
   * Salary findFirst
   */
  export type SalaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * Filter, which Salary to fetch.
     */
    where?: SalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salaries to fetch.
     */
    orderBy?: SalaryOrderByWithRelationInput | SalaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Salaries.
     */
    cursor?: SalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Salaries.
     */
    distinct?: SalaryScalarFieldEnum | SalaryScalarFieldEnum[]
  }

  /**
   * Salary findFirstOrThrow
   */
  export type SalaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * Filter, which Salary to fetch.
     */
    where?: SalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salaries to fetch.
     */
    orderBy?: SalaryOrderByWithRelationInput | SalaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Salaries.
     */
    cursor?: SalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Salaries.
     */
    distinct?: SalaryScalarFieldEnum | SalaryScalarFieldEnum[]
  }

  /**
   * Salary findMany
   */
  export type SalaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * Filter, which Salaries to fetch.
     */
    where?: SalaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salaries to fetch.
     */
    orderBy?: SalaryOrderByWithRelationInput | SalaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Salaries.
     */
    cursor?: SalaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salaries.
     */
    skip?: number
    distinct?: SalaryScalarFieldEnum | SalaryScalarFieldEnum[]
  }

  /**
   * Salary create
   */
  export type SalaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * The data needed to create a Salary.
     */
    data: XOR<SalaryCreateInput, SalaryUncheckedCreateInput>
  }

  /**
   * Salary createMany
   */
  export type SalaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Salaries.
     */
    data: SalaryCreateManyInput | SalaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Salary update
   */
  export type SalaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * The data needed to update a Salary.
     */
    data: XOR<SalaryUpdateInput, SalaryUncheckedUpdateInput>
    /**
     * Choose, which Salary to update.
     */
    where: SalaryWhereUniqueInput
  }

  /**
   * Salary updateMany
   */
  export type SalaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Salaries.
     */
    data: XOR<SalaryUpdateManyMutationInput, SalaryUncheckedUpdateManyInput>
    /**
     * Filter which Salaries to update
     */
    where?: SalaryWhereInput
    /**
     * Limit how many Salaries to update.
     */
    limit?: number
  }

  /**
   * Salary upsert
   */
  export type SalaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * The filter to search for the Salary to update in case it exists.
     */
    where: SalaryWhereUniqueInput
    /**
     * In case the Salary found by the `where` argument doesn't exist, create a new Salary with this data.
     */
    create: XOR<SalaryCreateInput, SalaryUncheckedCreateInput>
    /**
     * In case the Salary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalaryUpdateInput, SalaryUncheckedUpdateInput>
  }

  /**
   * Salary delete
   */
  export type SalaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
    /**
     * Filter which Salary to delete.
     */
    where: SalaryWhereUniqueInput
  }

  /**
   * Salary deleteMany
   */
  export type SalaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Salaries to delete
     */
    where?: SalaryWhereInput
    /**
     * Limit how many Salaries to delete.
     */
    limit?: number
  }

  /**
   * Salary without action
   */
  export type SalaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salary
     */
    select?: SalarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salary
     */
    omit?: SalaryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryInclude<ExtArgs> | null
  }


  /**
   * Model Complaint
   */

  export type AggregateComplaint = {
    _count: ComplaintCountAggregateOutputType | null
    _avg: ComplaintAvgAggregateOutputType | null
    _sum: ComplaintSumAggregateOutputType | null
    _min: ComplaintMinAggregateOutputType | null
    _max: ComplaintMaxAggregateOutputType | null
  }

  export type ComplaintAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
  }

  export type ComplaintSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
  }

  export type ComplaintMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    subject: string | null
    description: string | null
    status: $Enums.ComplaintStatus | null
    response: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComplaintMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    subject: string | null
    description: string | null
    status: $Enums.ComplaintStatus | null
    response: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComplaintCountAggregateOutputType = {
    id: number
    employeeId: number
    subject: number
    description: number
    status: number
    response: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ComplaintAvgAggregateInputType = {
    id?: true
    employeeId?: true
  }

  export type ComplaintSumAggregateInputType = {
    id?: true
    employeeId?: true
  }

  export type ComplaintMinAggregateInputType = {
    id?: true
    employeeId?: true
    subject?: true
    description?: true
    status?: true
    response?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComplaintMaxAggregateInputType = {
    id?: true
    employeeId?: true
    subject?: true
    description?: true
    status?: true
    response?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComplaintCountAggregateInputType = {
    id?: true
    employeeId?: true
    subject?: true
    description?: true
    status?: true
    response?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ComplaintAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Complaint to aggregate.
     */
    where?: ComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Complaints
    **/
    _count?: true | ComplaintCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComplaintAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComplaintSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplaintMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplaintMaxAggregateInputType
  }

  export type GetComplaintAggregateType<T extends ComplaintAggregateArgs> = {
        [P in keyof T & keyof AggregateComplaint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplaint[P]>
      : GetScalarType<T[P], AggregateComplaint[P]>
  }




  export type ComplaintGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintWhereInput
    orderBy?: ComplaintOrderByWithAggregationInput | ComplaintOrderByWithAggregationInput[]
    by: ComplaintScalarFieldEnum[] | ComplaintScalarFieldEnum
    having?: ComplaintScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplaintCountAggregateInputType | true
    _avg?: ComplaintAvgAggregateInputType
    _sum?: ComplaintSumAggregateInputType
    _min?: ComplaintMinAggregateInputType
    _max?: ComplaintMaxAggregateInputType
  }

  export type ComplaintGroupByOutputType = {
    id: number
    employeeId: number
    subject: string
    description: string
    status: $Enums.ComplaintStatus
    response: string | null
    createdAt: Date
    updatedAt: Date
    _count: ComplaintCountAggregateOutputType | null
    _avg: ComplaintAvgAggregateOutputType | null
    _sum: ComplaintSumAggregateOutputType | null
    _min: ComplaintMinAggregateOutputType | null
    _max: ComplaintMaxAggregateOutputType | null
  }

  type GetComplaintGroupByPayload<T extends ComplaintGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplaintGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplaintGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplaintGroupByOutputType[P]>
            : GetScalarType<T[P], ComplaintGroupByOutputType[P]>
        }
      >
    >


  export type ComplaintSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    subject?: boolean
    description?: boolean
    status?: boolean
    response?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["complaint"]>



  export type ComplaintSelectScalar = {
    id?: boolean
    employeeId?: boolean
    subject?: boolean
    description?: boolean
    status?: boolean
    response?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ComplaintOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "subject" | "description" | "status" | "response" | "createdAt" | "updatedAt", ExtArgs["result"]["complaint"]>
  export type ComplaintInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $ComplaintPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Complaint"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      subject: string
      description: string
      status: $Enums.ComplaintStatus
      response: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["complaint"]>
    composites: {}
  }

  type ComplaintGetPayload<S extends boolean | null | undefined | ComplaintDefaultArgs> = $Result.GetResult<Prisma.$ComplaintPayload, S>

  type ComplaintCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComplaintFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComplaintCountAggregateInputType | true
    }

  export interface ComplaintDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Complaint'], meta: { name: 'Complaint' } }
    /**
     * Find zero or one Complaint that matches the filter.
     * @param {ComplaintFindUniqueArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComplaintFindUniqueArgs>(args: SelectSubset<T, ComplaintFindUniqueArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Complaint that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComplaintFindUniqueOrThrowArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComplaintFindUniqueOrThrowArgs>(args: SelectSubset<T, ComplaintFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Complaint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintFindFirstArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComplaintFindFirstArgs>(args?: SelectSubset<T, ComplaintFindFirstArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Complaint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintFindFirstOrThrowArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComplaintFindFirstOrThrowArgs>(args?: SelectSubset<T, ComplaintFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Complaints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Complaints
     * const complaints = await prisma.complaint.findMany()
     * 
     * // Get first 10 Complaints
     * const complaints = await prisma.complaint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const complaintWithIdOnly = await prisma.complaint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComplaintFindManyArgs>(args?: SelectSubset<T, ComplaintFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Complaint.
     * @param {ComplaintCreateArgs} args - Arguments to create a Complaint.
     * @example
     * // Create one Complaint
     * const Complaint = await prisma.complaint.create({
     *   data: {
     *     // ... data to create a Complaint
     *   }
     * })
     * 
     */
    create<T extends ComplaintCreateArgs>(args: SelectSubset<T, ComplaintCreateArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Complaints.
     * @param {ComplaintCreateManyArgs} args - Arguments to create many Complaints.
     * @example
     * // Create many Complaints
     * const complaint = await prisma.complaint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComplaintCreateManyArgs>(args?: SelectSubset<T, ComplaintCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Complaint.
     * @param {ComplaintDeleteArgs} args - Arguments to delete one Complaint.
     * @example
     * // Delete one Complaint
     * const Complaint = await prisma.complaint.delete({
     *   where: {
     *     // ... filter to delete one Complaint
     *   }
     * })
     * 
     */
    delete<T extends ComplaintDeleteArgs>(args: SelectSubset<T, ComplaintDeleteArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Complaint.
     * @param {ComplaintUpdateArgs} args - Arguments to update one Complaint.
     * @example
     * // Update one Complaint
     * const complaint = await prisma.complaint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComplaintUpdateArgs>(args: SelectSubset<T, ComplaintUpdateArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Complaints.
     * @param {ComplaintDeleteManyArgs} args - Arguments to filter Complaints to delete.
     * @example
     * // Delete a few Complaints
     * const { count } = await prisma.complaint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComplaintDeleteManyArgs>(args?: SelectSubset<T, ComplaintDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Complaints
     * const complaint = await prisma.complaint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComplaintUpdateManyArgs>(args: SelectSubset<T, ComplaintUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Complaint.
     * @param {ComplaintUpsertArgs} args - Arguments to update or create a Complaint.
     * @example
     * // Update or create a Complaint
     * const complaint = await prisma.complaint.upsert({
     *   create: {
     *     // ... data to create a Complaint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Complaint we want to update
     *   }
     * })
     */
    upsert<T extends ComplaintUpsertArgs>(args: SelectSubset<T, ComplaintUpsertArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintCountArgs} args - Arguments to filter Complaints to count.
     * @example
     * // Count the number of Complaints
     * const count = await prisma.complaint.count({
     *   where: {
     *     // ... the filter for the Complaints we want to count
     *   }
     * })
    **/
    count<T extends ComplaintCountArgs>(
      args?: Subset<T, ComplaintCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplaintCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Complaint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplaintAggregateArgs>(args: Subset<T, ComplaintAggregateArgs>): Prisma.PrismaPromise<GetComplaintAggregateType<T>>

    /**
     * Group by Complaint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComplaintGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComplaintGroupByArgs['orderBy'] }
        : { orderBy?: ComplaintGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComplaintGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplaintGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Complaint model
   */
  readonly fields: ComplaintFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Complaint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComplaintClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Complaint model
   */
  interface ComplaintFieldRefs {
    readonly id: FieldRef<"Complaint", 'Int'>
    readonly employeeId: FieldRef<"Complaint", 'Int'>
    readonly subject: FieldRef<"Complaint", 'String'>
    readonly description: FieldRef<"Complaint", 'String'>
    readonly status: FieldRef<"Complaint", 'ComplaintStatus'>
    readonly response: FieldRef<"Complaint", 'String'>
    readonly createdAt: FieldRef<"Complaint", 'DateTime'>
    readonly updatedAt: FieldRef<"Complaint", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Complaint findUnique
   */
  export type ComplaintFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaint to fetch.
     */
    where: ComplaintWhereUniqueInput
  }

  /**
   * Complaint findUniqueOrThrow
   */
  export type ComplaintFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaint to fetch.
     */
    where: ComplaintWhereUniqueInput
  }

  /**
   * Complaint findFirst
   */
  export type ComplaintFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaint to fetch.
     */
    where?: ComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Complaints.
     */
    cursor?: ComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Complaints.
     */
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * Complaint findFirstOrThrow
   */
  export type ComplaintFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaint to fetch.
     */
    where?: ComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Complaints.
     */
    cursor?: ComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Complaints.
     */
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * Complaint findMany
   */
  export type ComplaintFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaints to fetch.
     */
    where?: ComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Complaints.
     */
    cursor?: ComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * Complaint create
   */
  export type ComplaintCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * The data needed to create a Complaint.
     */
    data: XOR<ComplaintCreateInput, ComplaintUncheckedCreateInput>
  }

  /**
   * Complaint createMany
   */
  export type ComplaintCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Complaints.
     */
    data: ComplaintCreateManyInput | ComplaintCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Complaint update
   */
  export type ComplaintUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * The data needed to update a Complaint.
     */
    data: XOR<ComplaintUpdateInput, ComplaintUncheckedUpdateInput>
    /**
     * Choose, which Complaint to update.
     */
    where: ComplaintWhereUniqueInput
  }

  /**
   * Complaint updateMany
   */
  export type ComplaintUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Complaints.
     */
    data: XOR<ComplaintUpdateManyMutationInput, ComplaintUncheckedUpdateManyInput>
    /**
     * Filter which Complaints to update
     */
    where?: ComplaintWhereInput
    /**
     * Limit how many Complaints to update.
     */
    limit?: number
  }

  /**
   * Complaint upsert
   */
  export type ComplaintUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * The filter to search for the Complaint to update in case it exists.
     */
    where: ComplaintWhereUniqueInput
    /**
     * In case the Complaint found by the `where` argument doesn't exist, create a new Complaint with this data.
     */
    create: XOR<ComplaintCreateInput, ComplaintUncheckedCreateInput>
    /**
     * In case the Complaint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComplaintUpdateInput, ComplaintUncheckedUpdateInput>
  }

  /**
   * Complaint delete
   */
  export type ComplaintDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter which Complaint to delete.
     */
    where: ComplaintWhereUniqueInput
  }

  /**
   * Complaint deleteMany
   */
  export type ComplaintDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Complaints to delete
     */
    where?: ComplaintWhereInput
    /**
     * Limit how many Complaints to delete.
     */
    limit?: number
  }

  /**
   * Complaint without action
   */
  export type ComplaintDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
  }


  /**
   * Model Interview
   */

  export type AggregateInterview = {
    _count: InterviewCountAggregateOutputType | null
    _avg: InterviewAvgAggregateOutputType | null
    _sum: InterviewSumAggregateOutputType | null
    _min: InterviewMinAggregateOutputType | null
    _max: InterviewMaxAggregateOutputType | null
  }

  export type InterviewAvgAggregateOutputType = {
    id: number | null
  }

  export type InterviewSumAggregateOutputType = {
    id: number | null
  }

  export type InterviewMinAggregateOutputType = {
    id: number | null
    candidateName: string | null
    position: string | null
    interviewDate: Date | null
    result: $Enums.InterviewResult | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InterviewMaxAggregateOutputType = {
    id: number | null
    candidateName: string | null
    position: string | null
    interviewDate: Date | null
    result: $Enums.InterviewResult | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InterviewCountAggregateOutputType = {
    id: number
    candidateName: number
    position: number
    interviewDate: number
    result: number
    comments: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InterviewAvgAggregateInputType = {
    id?: true
  }

  export type InterviewSumAggregateInputType = {
    id?: true
  }

  export type InterviewMinAggregateInputType = {
    id?: true
    candidateName?: true
    position?: true
    interviewDate?: true
    result?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InterviewMaxAggregateInputType = {
    id?: true
    candidateName?: true
    position?: true
    interviewDate?: true
    result?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InterviewCountAggregateInputType = {
    id?: true
    candidateName?: true
    position?: true
    interviewDate?: true
    result?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InterviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interview to aggregate.
     */
    where?: InterviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interviews to fetch.
     */
    orderBy?: InterviewOrderByWithRelationInput | InterviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Interviews
    **/
    _count?: true | InterviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InterviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InterviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterviewMaxAggregateInputType
  }

  export type GetInterviewAggregateType<T extends InterviewAggregateArgs> = {
        [P in keyof T & keyof AggregateInterview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterview[P]>
      : GetScalarType<T[P], AggregateInterview[P]>
  }




  export type InterviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterviewWhereInput
    orderBy?: InterviewOrderByWithAggregationInput | InterviewOrderByWithAggregationInput[]
    by: InterviewScalarFieldEnum[] | InterviewScalarFieldEnum
    having?: InterviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterviewCountAggregateInputType | true
    _avg?: InterviewAvgAggregateInputType
    _sum?: InterviewSumAggregateInputType
    _min?: InterviewMinAggregateInputType
    _max?: InterviewMaxAggregateInputType
  }

  export type InterviewGroupByOutputType = {
    id: number
    candidateName: string
    position: string | null
    interviewDate: Date | null
    result: $Enums.InterviewResult
    comments: string | null
    createdAt: Date
    updatedAt: Date
    _count: InterviewCountAggregateOutputType | null
    _avg: InterviewAvgAggregateOutputType | null
    _sum: InterviewSumAggregateOutputType | null
    _min: InterviewMinAggregateOutputType | null
    _max: InterviewMaxAggregateOutputType | null
  }

  type GetInterviewGroupByPayload<T extends InterviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterviewGroupByOutputType[P]>
            : GetScalarType<T[P], InterviewGroupByOutputType[P]>
        }
      >
    >


  export type InterviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    candidateName?: boolean
    position?: boolean
    interviewDate?: boolean
    result?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["interview"]>



  export type InterviewSelectScalar = {
    id?: boolean
    candidateName?: boolean
    position?: boolean
    interviewDate?: boolean
    result?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InterviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "candidateName" | "position" | "interviewDate" | "result" | "comments" | "createdAt" | "updatedAt", ExtArgs["result"]["interview"]>

  export type $InterviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Interview"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      candidateName: string
      position: string | null
      interviewDate: Date | null
      result: $Enums.InterviewResult
      comments: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["interview"]>
    composites: {}
  }

  type InterviewGetPayload<S extends boolean | null | undefined | InterviewDefaultArgs> = $Result.GetResult<Prisma.$InterviewPayload, S>

  type InterviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InterviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InterviewCountAggregateInputType | true
    }

  export interface InterviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Interview'], meta: { name: 'Interview' } }
    /**
     * Find zero or one Interview that matches the filter.
     * @param {InterviewFindUniqueArgs} args - Arguments to find a Interview
     * @example
     * // Get one Interview
     * const interview = await prisma.interview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterviewFindUniqueArgs>(args: SelectSubset<T, InterviewFindUniqueArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Interview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InterviewFindUniqueOrThrowArgs} args - Arguments to find a Interview
     * @example
     * // Get one Interview
     * const interview = await prisma.interview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterviewFindUniqueOrThrowArgs>(args: SelectSubset<T, InterviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Interview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewFindFirstArgs} args - Arguments to find a Interview
     * @example
     * // Get one Interview
     * const interview = await prisma.interview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterviewFindFirstArgs>(args?: SelectSubset<T, InterviewFindFirstArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Interview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewFindFirstOrThrowArgs} args - Arguments to find a Interview
     * @example
     * // Get one Interview
     * const interview = await prisma.interview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterviewFindFirstOrThrowArgs>(args?: SelectSubset<T, InterviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Interviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Interviews
     * const interviews = await prisma.interview.findMany()
     * 
     * // Get first 10 Interviews
     * const interviews = await prisma.interview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interviewWithIdOnly = await prisma.interview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterviewFindManyArgs>(args?: SelectSubset<T, InterviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Interview.
     * @param {InterviewCreateArgs} args - Arguments to create a Interview.
     * @example
     * // Create one Interview
     * const Interview = await prisma.interview.create({
     *   data: {
     *     // ... data to create a Interview
     *   }
     * })
     * 
     */
    create<T extends InterviewCreateArgs>(args: SelectSubset<T, InterviewCreateArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Interviews.
     * @param {InterviewCreateManyArgs} args - Arguments to create many Interviews.
     * @example
     * // Create many Interviews
     * const interview = await prisma.interview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterviewCreateManyArgs>(args?: SelectSubset<T, InterviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Interview.
     * @param {InterviewDeleteArgs} args - Arguments to delete one Interview.
     * @example
     * // Delete one Interview
     * const Interview = await prisma.interview.delete({
     *   where: {
     *     // ... filter to delete one Interview
     *   }
     * })
     * 
     */
    delete<T extends InterviewDeleteArgs>(args: SelectSubset<T, InterviewDeleteArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Interview.
     * @param {InterviewUpdateArgs} args - Arguments to update one Interview.
     * @example
     * // Update one Interview
     * const interview = await prisma.interview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterviewUpdateArgs>(args: SelectSubset<T, InterviewUpdateArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Interviews.
     * @param {InterviewDeleteManyArgs} args - Arguments to filter Interviews to delete.
     * @example
     * // Delete a few Interviews
     * const { count } = await prisma.interview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterviewDeleteManyArgs>(args?: SelectSubset<T, InterviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Interviews
     * const interview = await prisma.interview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterviewUpdateManyArgs>(args: SelectSubset<T, InterviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Interview.
     * @param {InterviewUpsertArgs} args - Arguments to update or create a Interview.
     * @example
     * // Update or create a Interview
     * const interview = await prisma.interview.upsert({
     *   create: {
     *     // ... data to create a Interview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Interview we want to update
     *   }
     * })
     */
    upsert<T extends InterviewUpsertArgs>(args: SelectSubset<T, InterviewUpsertArgs<ExtArgs>>): Prisma__InterviewClient<$Result.GetResult<Prisma.$InterviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Interviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewCountArgs} args - Arguments to filter Interviews to count.
     * @example
     * // Count the number of Interviews
     * const count = await prisma.interview.count({
     *   where: {
     *     // ... the filter for the Interviews we want to count
     *   }
     * })
    **/
    count<T extends InterviewCountArgs>(
      args?: Subset<T, InterviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Interview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterviewAggregateArgs>(args: Subset<T, InterviewAggregateArgs>): Prisma.PrismaPromise<GetInterviewAggregateType<T>>

    /**
     * Group by Interview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterviewGroupByArgs['orderBy'] }
        : { orderBy?: InterviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Interview model
   */
  readonly fields: InterviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Interview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Interview model
   */
  interface InterviewFieldRefs {
    readonly id: FieldRef<"Interview", 'Int'>
    readonly candidateName: FieldRef<"Interview", 'String'>
    readonly position: FieldRef<"Interview", 'String'>
    readonly interviewDate: FieldRef<"Interview", 'DateTime'>
    readonly result: FieldRef<"Interview", 'InterviewResult'>
    readonly comments: FieldRef<"Interview", 'String'>
    readonly createdAt: FieldRef<"Interview", 'DateTime'>
    readonly updatedAt: FieldRef<"Interview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Interview findUnique
   */
  export type InterviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * Filter, which Interview to fetch.
     */
    where: InterviewWhereUniqueInput
  }

  /**
   * Interview findUniqueOrThrow
   */
  export type InterviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * Filter, which Interview to fetch.
     */
    where: InterviewWhereUniqueInput
  }

  /**
   * Interview findFirst
   */
  export type InterviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * Filter, which Interview to fetch.
     */
    where?: InterviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interviews to fetch.
     */
    orderBy?: InterviewOrderByWithRelationInput | InterviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interviews.
     */
    cursor?: InterviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interviews.
     */
    distinct?: InterviewScalarFieldEnum | InterviewScalarFieldEnum[]
  }

  /**
   * Interview findFirstOrThrow
   */
  export type InterviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * Filter, which Interview to fetch.
     */
    where?: InterviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interviews to fetch.
     */
    orderBy?: InterviewOrderByWithRelationInput | InterviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interviews.
     */
    cursor?: InterviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interviews.
     */
    distinct?: InterviewScalarFieldEnum | InterviewScalarFieldEnum[]
  }

  /**
   * Interview findMany
   */
  export type InterviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * Filter, which Interviews to fetch.
     */
    where?: InterviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interviews to fetch.
     */
    orderBy?: InterviewOrderByWithRelationInput | InterviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Interviews.
     */
    cursor?: InterviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interviews.
     */
    skip?: number
    distinct?: InterviewScalarFieldEnum | InterviewScalarFieldEnum[]
  }

  /**
   * Interview create
   */
  export type InterviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * The data needed to create a Interview.
     */
    data: XOR<InterviewCreateInput, InterviewUncheckedCreateInput>
  }

  /**
   * Interview createMany
   */
  export type InterviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Interviews.
     */
    data: InterviewCreateManyInput | InterviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Interview update
   */
  export type InterviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * The data needed to update a Interview.
     */
    data: XOR<InterviewUpdateInput, InterviewUncheckedUpdateInput>
    /**
     * Choose, which Interview to update.
     */
    where: InterviewWhereUniqueInput
  }

  /**
   * Interview updateMany
   */
  export type InterviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Interviews.
     */
    data: XOR<InterviewUpdateManyMutationInput, InterviewUncheckedUpdateManyInput>
    /**
     * Filter which Interviews to update
     */
    where?: InterviewWhereInput
    /**
     * Limit how many Interviews to update.
     */
    limit?: number
  }

  /**
   * Interview upsert
   */
  export type InterviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * The filter to search for the Interview to update in case it exists.
     */
    where: InterviewWhereUniqueInput
    /**
     * In case the Interview found by the `where` argument doesn't exist, create a new Interview with this data.
     */
    create: XOR<InterviewCreateInput, InterviewUncheckedCreateInput>
    /**
     * In case the Interview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterviewUpdateInput, InterviewUncheckedUpdateInput>
  }

  /**
   * Interview delete
   */
  export type InterviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
    /**
     * Filter which Interview to delete.
     */
    where: InterviewWhereUniqueInput
  }

  /**
   * Interview deleteMany
   */
  export type InterviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interviews to delete
     */
    where?: InterviewWhereInput
    /**
     * Limit how many Interviews to delete.
     */
    limit?: number
  }

  /**
   * Interview without action
   */
  export type InterviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interview
     */
    select?: InterviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interview
     */
    omit?: InterviewOmit<ExtArgs> | null
  }


  /**
   * Model PerformanceReview
   */

  export type AggregatePerformanceReview = {
    _count: PerformanceReviewCountAggregateOutputType | null
    _avg: PerformanceReviewAvgAggregateOutputType | null
    _sum: PerformanceReviewSumAggregateOutputType | null
    _min: PerformanceReviewMinAggregateOutputType | null
    _max: PerformanceReviewMaxAggregateOutputType | null
  }

  export type PerformanceReviewAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
    score: number | null
  }

  export type PerformanceReviewSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
    score: number | null
  }

  export type PerformanceReviewMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    reviewDate: Date | null
    reviewerName: string | null
    score: number | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PerformanceReviewMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    reviewDate: Date | null
    reviewerName: string | null
    score: number | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PerformanceReviewCountAggregateOutputType = {
    id: number
    employeeId: number
    reviewDate: number
    reviewerName: number
    score: number
    comments: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PerformanceReviewAvgAggregateInputType = {
    id?: true
    employeeId?: true
    score?: true
  }

  export type PerformanceReviewSumAggregateInputType = {
    id?: true
    employeeId?: true
    score?: true
  }

  export type PerformanceReviewMinAggregateInputType = {
    id?: true
    employeeId?: true
    reviewDate?: true
    reviewerName?: true
    score?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PerformanceReviewMaxAggregateInputType = {
    id?: true
    employeeId?: true
    reviewDate?: true
    reviewerName?: true
    score?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PerformanceReviewCountAggregateInputType = {
    id?: true
    employeeId?: true
    reviewDate?: true
    reviewerName?: true
    score?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PerformanceReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceReview to aggregate.
     */
    where?: PerformanceReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceReviews to fetch.
     */
    orderBy?: PerformanceReviewOrderByWithRelationInput | PerformanceReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PerformanceReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PerformanceReviews
    **/
    _count?: true | PerformanceReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerformanceReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerformanceReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerformanceReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerformanceReviewMaxAggregateInputType
  }

  export type GetPerformanceReviewAggregateType<T extends PerformanceReviewAggregateArgs> = {
        [P in keyof T & keyof AggregatePerformanceReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerformanceReview[P]>
      : GetScalarType<T[P], AggregatePerformanceReview[P]>
  }




  export type PerformanceReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceReviewWhereInput
    orderBy?: PerformanceReviewOrderByWithAggregationInput | PerformanceReviewOrderByWithAggregationInput[]
    by: PerformanceReviewScalarFieldEnum[] | PerformanceReviewScalarFieldEnum
    having?: PerformanceReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerformanceReviewCountAggregateInputType | true
    _avg?: PerformanceReviewAvgAggregateInputType
    _sum?: PerformanceReviewSumAggregateInputType
    _min?: PerformanceReviewMinAggregateInputType
    _max?: PerformanceReviewMaxAggregateInputType
  }

  export type PerformanceReviewGroupByOutputType = {
    id: number
    employeeId: number
    reviewDate: Date
    reviewerName: string | null
    score: number | null
    comments: string | null
    createdAt: Date
    updatedAt: Date
    _count: PerformanceReviewCountAggregateOutputType | null
    _avg: PerformanceReviewAvgAggregateOutputType | null
    _sum: PerformanceReviewSumAggregateOutputType | null
    _min: PerformanceReviewMinAggregateOutputType | null
    _max: PerformanceReviewMaxAggregateOutputType | null
  }

  type GetPerformanceReviewGroupByPayload<T extends PerformanceReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerformanceReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerformanceReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerformanceReviewGroupByOutputType[P]>
            : GetScalarType<T[P], PerformanceReviewGroupByOutputType[P]>
        }
      >
    >


  export type PerformanceReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    reviewDate?: boolean
    reviewerName?: boolean
    score?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceReview"]>



  export type PerformanceReviewSelectScalar = {
    id?: boolean
    employeeId?: boolean
    reviewDate?: boolean
    reviewerName?: boolean
    score?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PerformanceReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "reviewDate" | "reviewerName" | "score" | "comments" | "createdAt" | "updatedAt", ExtArgs["result"]["performanceReview"]>
  export type PerformanceReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $PerformanceReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PerformanceReview"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      reviewDate: Date
      reviewerName: string | null
      score: number | null
      comments: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["performanceReview"]>
    composites: {}
  }

  type PerformanceReviewGetPayload<S extends boolean | null | undefined | PerformanceReviewDefaultArgs> = $Result.GetResult<Prisma.$PerformanceReviewPayload, S>

  type PerformanceReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PerformanceReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PerformanceReviewCountAggregateInputType | true
    }

  export interface PerformanceReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PerformanceReview'], meta: { name: 'PerformanceReview' } }
    /**
     * Find zero or one PerformanceReview that matches the filter.
     * @param {PerformanceReviewFindUniqueArgs} args - Arguments to find a PerformanceReview
     * @example
     * // Get one PerformanceReview
     * const performanceReview = await prisma.performanceReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PerformanceReviewFindUniqueArgs>(args: SelectSubset<T, PerformanceReviewFindUniqueArgs<ExtArgs>>): Prisma__PerformanceReviewClient<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PerformanceReview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PerformanceReviewFindUniqueOrThrowArgs} args - Arguments to find a PerformanceReview
     * @example
     * // Get one PerformanceReview
     * const performanceReview = await prisma.performanceReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PerformanceReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, PerformanceReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PerformanceReviewClient<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PerformanceReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReviewFindFirstArgs} args - Arguments to find a PerformanceReview
     * @example
     * // Get one PerformanceReview
     * const performanceReview = await prisma.performanceReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PerformanceReviewFindFirstArgs>(args?: SelectSubset<T, PerformanceReviewFindFirstArgs<ExtArgs>>): Prisma__PerformanceReviewClient<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PerformanceReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReviewFindFirstOrThrowArgs} args - Arguments to find a PerformanceReview
     * @example
     * // Get one PerformanceReview
     * const performanceReview = await prisma.performanceReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PerformanceReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, PerformanceReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__PerformanceReviewClient<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PerformanceReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PerformanceReviews
     * const performanceReviews = await prisma.performanceReview.findMany()
     * 
     * // Get first 10 PerformanceReviews
     * const performanceReviews = await prisma.performanceReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const performanceReviewWithIdOnly = await prisma.performanceReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PerformanceReviewFindManyArgs>(args?: SelectSubset<T, PerformanceReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PerformanceReview.
     * @param {PerformanceReviewCreateArgs} args - Arguments to create a PerformanceReview.
     * @example
     * // Create one PerformanceReview
     * const PerformanceReview = await prisma.performanceReview.create({
     *   data: {
     *     // ... data to create a PerformanceReview
     *   }
     * })
     * 
     */
    create<T extends PerformanceReviewCreateArgs>(args: SelectSubset<T, PerformanceReviewCreateArgs<ExtArgs>>): Prisma__PerformanceReviewClient<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PerformanceReviews.
     * @param {PerformanceReviewCreateManyArgs} args - Arguments to create many PerformanceReviews.
     * @example
     * // Create many PerformanceReviews
     * const performanceReview = await prisma.performanceReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PerformanceReviewCreateManyArgs>(args?: SelectSubset<T, PerformanceReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PerformanceReview.
     * @param {PerformanceReviewDeleteArgs} args - Arguments to delete one PerformanceReview.
     * @example
     * // Delete one PerformanceReview
     * const PerformanceReview = await prisma.performanceReview.delete({
     *   where: {
     *     // ... filter to delete one PerformanceReview
     *   }
     * })
     * 
     */
    delete<T extends PerformanceReviewDeleteArgs>(args: SelectSubset<T, PerformanceReviewDeleteArgs<ExtArgs>>): Prisma__PerformanceReviewClient<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PerformanceReview.
     * @param {PerformanceReviewUpdateArgs} args - Arguments to update one PerformanceReview.
     * @example
     * // Update one PerformanceReview
     * const performanceReview = await prisma.performanceReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PerformanceReviewUpdateArgs>(args: SelectSubset<T, PerformanceReviewUpdateArgs<ExtArgs>>): Prisma__PerformanceReviewClient<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PerformanceReviews.
     * @param {PerformanceReviewDeleteManyArgs} args - Arguments to filter PerformanceReviews to delete.
     * @example
     * // Delete a few PerformanceReviews
     * const { count } = await prisma.performanceReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PerformanceReviewDeleteManyArgs>(args?: SelectSubset<T, PerformanceReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PerformanceReviews
     * const performanceReview = await prisma.performanceReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PerformanceReviewUpdateManyArgs>(args: SelectSubset<T, PerformanceReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PerformanceReview.
     * @param {PerformanceReviewUpsertArgs} args - Arguments to update or create a PerformanceReview.
     * @example
     * // Update or create a PerformanceReview
     * const performanceReview = await prisma.performanceReview.upsert({
     *   create: {
     *     // ... data to create a PerformanceReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PerformanceReview we want to update
     *   }
     * })
     */
    upsert<T extends PerformanceReviewUpsertArgs>(args: SelectSubset<T, PerformanceReviewUpsertArgs<ExtArgs>>): Prisma__PerformanceReviewClient<$Result.GetResult<Prisma.$PerformanceReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PerformanceReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReviewCountArgs} args - Arguments to filter PerformanceReviews to count.
     * @example
     * // Count the number of PerformanceReviews
     * const count = await prisma.performanceReview.count({
     *   where: {
     *     // ... the filter for the PerformanceReviews we want to count
     *   }
     * })
    **/
    count<T extends PerformanceReviewCountArgs>(
      args?: Subset<T, PerformanceReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerformanceReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PerformanceReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerformanceReviewAggregateArgs>(args: Subset<T, PerformanceReviewAggregateArgs>): Prisma.PrismaPromise<GetPerformanceReviewAggregateType<T>>

    /**
     * Group by PerformanceReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerformanceReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerformanceReviewGroupByArgs['orderBy'] }
        : { orderBy?: PerformanceReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerformanceReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerformanceReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PerformanceReview model
   */
  readonly fields: PerformanceReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PerformanceReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PerformanceReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PerformanceReview model
   */
  interface PerformanceReviewFieldRefs {
    readonly id: FieldRef<"PerformanceReview", 'Int'>
    readonly employeeId: FieldRef<"PerformanceReview", 'Int'>
    readonly reviewDate: FieldRef<"PerformanceReview", 'DateTime'>
    readonly reviewerName: FieldRef<"PerformanceReview", 'String'>
    readonly score: FieldRef<"PerformanceReview", 'Int'>
    readonly comments: FieldRef<"PerformanceReview", 'String'>
    readonly createdAt: FieldRef<"PerformanceReview", 'DateTime'>
    readonly updatedAt: FieldRef<"PerformanceReview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PerformanceReview findUnique
   */
  export type PerformanceReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceReview to fetch.
     */
    where: PerformanceReviewWhereUniqueInput
  }

  /**
   * PerformanceReview findUniqueOrThrow
   */
  export type PerformanceReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceReview to fetch.
     */
    where: PerformanceReviewWhereUniqueInput
  }

  /**
   * PerformanceReview findFirst
   */
  export type PerformanceReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceReview to fetch.
     */
    where?: PerformanceReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceReviews to fetch.
     */
    orderBy?: PerformanceReviewOrderByWithRelationInput | PerformanceReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceReviews.
     */
    cursor?: PerformanceReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceReviews.
     */
    distinct?: PerformanceReviewScalarFieldEnum | PerformanceReviewScalarFieldEnum[]
  }

  /**
   * PerformanceReview findFirstOrThrow
   */
  export type PerformanceReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceReview to fetch.
     */
    where?: PerformanceReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceReviews to fetch.
     */
    orderBy?: PerformanceReviewOrderByWithRelationInput | PerformanceReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceReviews.
     */
    cursor?: PerformanceReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceReviews.
     */
    distinct?: PerformanceReviewScalarFieldEnum | PerformanceReviewScalarFieldEnum[]
  }

  /**
   * PerformanceReview findMany
   */
  export type PerformanceReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceReviews to fetch.
     */
    where?: PerformanceReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceReviews to fetch.
     */
    orderBy?: PerformanceReviewOrderByWithRelationInput | PerformanceReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PerformanceReviews.
     */
    cursor?: PerformanceReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceReviews.
     */
    skip?: number
    distinct?: PerformanceReviewScalarFieldEnum | PerformanceReviewScalarFieldEnum[]
  }

  /**
   * PerformanceReview create
   */
  export type PerformanceReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a PerformanceReview.
     */
    data: XOR<PerformanceReviewCreateInput, PerformanceReviewUncheckedCreateInput>
  }

  /**
   * PerformanceReview createMany
   */
  export type PerformanceReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PerformanceReviews.
     */
    data: PerformanceReviewCreateManyInput | PerformanceReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PerformanceReview update
   */
  export type PerformanceReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a PerformanceReview.
     */
    data: XOR<PerformanceReviewUpdateInput, PerformanceReviewUncheckedUpdateInput>
    /**
     * Choose, which PerformanceReview to update.
     */
    where: PerformanceReviewWhereUniqueInput
  }

  /**
   * PerformanceReview updateMany
   */
  export type PerformanceReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PerformanceReviews.
     */
    data: XOR<PerformanceReviewUpdateManyMutationInput, PerformanceReviewUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceReviews to update
     */
    where?: PerformanceReviewWhereInput
    /**
     * Limit how many PerformanceReviews to update.
     */
    limit?: number
  }

  /**
   * PerformanceReview upsert
   */
  export type PerformanceReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the PerformanceReview to update in case it exists.
     */
    where: PerformanceReviewWhereUniqueInput
    /**
     * In case the PerformanceReview found by the `where` argument doesn't exist, create a new PerformanceReview with this data.
     */
    create: XOR<PerformanceReviewCreateInput, PerformanceReviewUncheckedCreateInput>
    /**
     * In case the PerformanceReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PerformanceReviewUpdateInput, PerformanceReviewUncheckedUpdateInput>
  }

  /**
   * PerformanceReview delete
   */
  export type PerformanceReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
    /**
     * Filter which PerformanceReview to delete.
     */
    where: PerformanceReviewWhereUniqueInput
  }

  /**
   * PerformanceReview deleteMany
   */
  export type PerformanceReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceReviews to delete
     */
    where?: PerformanceReviewWhereInput
    /**
     * Limit how many PerformanceReviews to delete.
     */
    limit?: number
  }

  /**
   * PerformanceReview without action
   */
  export type PerformanceReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceReview
     */
    select?: PerformanceReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceReview
     */
    omit?: PerformanceReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceReviewInclude<ExtArgs> | null
  }


  /**
   * Model Termination
   */

  export type AggregateTermination = {
    _count: TerminationCountAggregateOutputType | null
    _avg: TerminationAvgAggregateOutputType | null
    _sum: TerminationSumAggregateOutputType | null
    _min: TerminationMinAggregateOutputType | null
    _max: TerminationMaxAggregateOutputType | null
  }

  export type TerminationAvgAggregateOutputType = {
    id: number | null
    employeeId: number | null
  }

  export type TerminationSumAggregateOutputType = {
    id: number | null
    employeeId: number | null
  }

  export type TerminationMinAggregateOutputType = {
    id: number | null
    employeeId: number | null
    terminationDate: Date | null
    reason: string | null
    status: $Enums.TerminationStatus | null
    workflowStatus: $Enums.WorkflowStatus | null
    remarks: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TerminationMaxAggregateOutputType = {
    id: number | null
    employeeId: number | null
    terminationDate: Date | null
    reason: string | null
    status: $Enums.TerminationStatus | null
    workflowStatus: $Enums.WorkflowStatus | null
    remarks: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TerminationCountAggregateOutputType = {
    id: number
    employeeId: number
    terminationDate: number
    reason: number
    status: number
    workflowStatus: number
    remarks: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TerminationAvgAggregateInputType = {
    id?: true
    employeeId?: true
  }

  export type TerminationSumAggregateInputType = {
    id?: true
    employeeId?: true
  }

  export type TerminationMinAggregateInputType = {
    id?: true
    employeeId?: true
    terminationDate?: true
    reason?: true
    status?: true
    workflowStatus?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TerminationMaxAggregateInputType = {
    id?: true
    employeeId?: true
    terminationDate?: true
    reason?: true
    status?: true
    workflowStatus?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TerminationCountAggregateInputType = {
    id?: true
    employeeId?: true
    terminationDate?: true
    reason?: true
    status?: true
    workflowStatus?: true
    remarks?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TerminationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Termination to aggregate.
     */
    where?: TerminationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Terminations to fetch.
     */
    orderBy?: TerminationOrderByWithRelationInput | TerminationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TerminationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Terminations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Terminations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Terminations
    **/
    _count?: true | TerminationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TerminationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TerminationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TerminationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TerminationMaxAggregateInputType
  }

  export type GetTerminationAggregateType<T extends TerminationAggregateArgs> = {
        [P in keyof T & keyof AggregateTermination]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTermination[P]>
      : GetScalarType<T[P], AggregateTermination[P]>
  }




  export type TerminationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TerminationWhereInput
    orderBy?: TerminationOrderByWithAggregationInput | TerminationOrderByWithAggregationInput[]
    by: TerminationScalarFieldEnum[] | TerminationScalarFieldEnum
    having?: TerminationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TerminationCountAggregateInputType | true
    _avg?: TerminationAvgAggregateInputType
    _sum?: TerminationSumAggregateInputType
    _min?: TerminationMinAggregateInputType
    _max?: TerminationMaxAggregateInputType
  }

  export type TerminationGroupByOutputType = {
    id: number
    employeeId: number
    terminationDate: Date
    reason: string | null
    status: $Enums.TerminationStatus
    workflowStatus: $Enums.WorkflowStatus
    remarks: string | null
    createdAt: Date
    updatedAt: Date
    _count: TerminationCountAggregateOutputType | null
    _avg: TerminationAvgAggregateOutputType | null
    _sum: TerminationSumAggregateOutputType | null
    _min: TerminationMinAggregateOutputType | null
    _max: TerminationMaxAggregateOutputType | null
  }

  type GetTerminationGroupByPayload<T extends TerminationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TerminationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TerminationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TerminationGroupByOutputType[P]>
            : GetScalarType<T[P], TerminationGroupByOutputType[P]>
        }
      >
    >


  export type TerminationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    terminationDate?: boolean
    reason?: boolean
    status?: boolean
    workflowStatus?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["termination"]>



  export type TerminationSelectScalar = {
    id?: boolean
    employeeId?: boolean
    terminationDate?: boolean
    reason?: boolean
    status?: boolean
    workflowStatus?: boolean
    remarks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TerminationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "terminationDate" | "reason" | "status" | "workflowStatus" | "remarks" | "createdAt" | "updatedAt", ExtArgs["result"]["termination"]>
  export type TerminationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $TerminationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Termination"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      employeeId: number
      terminationDate: Date
      reason: string | null
      status: $Enums.TerminationStatus
      workflowStatus: $Enums.WorkflowStatus
      remarks: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["termination"]>
    composites: {}
  }

  type TerminationGetPayload<S extends boolean | null | undefined | TerminationDefaultArgs> = $Result.GetResult<Prisma.$TerminationPayload, S>

  type TerminationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TerminationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TerminationCountAggregateInputType | true
    }

  export interface TerminationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Termination'], meta: { name: 'Termination' } }
    /**
     * Find zero or one Termination that matches the filter.
     * @param {TerminationFindUniqueArgs} args - Arguments to find a Termination
     * @example
     * // Get one Termination
     * const termination = await prisma.termination.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TerminationFindUniqueArgs>(args: SelectSubset<T, TerminationFindUniqueArgs<ExtArgs>>): Prisma__TerminationClient<$Result.GetResult<Prisma.$TerminationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Termination that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TerminationFindUniqueOrThrowArgs} args - Arguments to find a Termination
     * @example
     * // Get one Termination
     * const termination = await prisma.termination.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TerminationFindUniqueOrThrowArgs>(args: SelectSubset<T, TerminationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TerminationClient<$Result.GetResult<Prisma.$TerminationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Termination that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminationFindFirstArgs} args - Arguments to find a Termination
     * @example
     * // Get one Termination
     * const termination = await prisma.termination.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TerminationFindFirstArgs>(args?: SelectSubset<T, TerminationFindFirstArgs<ExtArgs>>): Prisma__TerminationClient<$Result.GetResult<Prisma.$TerminationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Termination that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminationFindFirstOrThrowArgs} args - Arguments to find a Termination
     * @example
     * // Get one Termination
     * const termination = await prisma.termination.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TerminationFindFirstOrThrowArgs>(args?: SelectSubset<T, TerminationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TerminationClient<$Result.GetResult<Prisma.$TerminationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Terminations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Terminations
     * const terminations = await prisma.termination.findMany()
     * 
     * // Get first 10 Terminations
     * const terminations = await prisma.termination.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const terminationWithIdOnly = await prisma.termination.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TerminationFindManyArgs>(args?: SelectSubset<T, TerminationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TerminationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Termination.
     * @param {TerminationCreateArgs} args - Arguments to create a Termination.
     * @example
     * // Create one Termination
     * const Termination = await prisma.termination.create({
     *   data: {
     *     // ... data to create a Termination
     *   }
     * })
     * 
     */
    create<T extends TerminationCreateArgs>(args: SelectSubset<T, TerminationCreateArgs<ExtArgs>>): Prisma__TerminationClient<$Result.GetResult<Prisma.$TerminationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Terminations.
     * @param {TerminationCreateManyArgs} args - Arguments to create many Terminations.
     * @example
     * // Create many Terminations
     * const termination = await prisma.termination.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TerminationCreateManyArgs>(args?: SelectSubset<T, TerminationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Termination.
     * @param {TerminationDeleteArgs} args - Arguments to delete one Termination.
     * @example
     * // Delete one Termination
     * const Termination = await prisma.termination.delete({
     *   where: {
     *     // ... filter to delete one Termination
     *   }
     * })
     * 
     */
    delete<T extends TerminationDeleteArgs>(args: SelectSubset<T, TerminationDeleteArgs<ExtArgs>>): Prisma__TerminationClient<$Result.GetResult<Prisma.$TerminationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Termination.
     * @param {TerminationUpdateArgs} args - Arguments to update one Termination.
     * @example
     * // Update one Termination
     * const termination = await prisma.termination.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TerminationUpdateArgs>(args: SelectSubset<T, TerminationUpdateArgs<ExtArgs>>): Prisma__TerminationClient<$Result.GetResult<Prisma.$TerminationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Terminations.
     * @param {TerminationDeleteManyArgs} args - Arguments to filter Terminations to delete.
     * @example
     * // Delete a few Terminations
     * const { count } = await prisma.termination.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TerminationDeleteManyArgs>(args?: SelectSubset<T, TerminationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Terminations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Terminations
     * const termination = await prisma.termination.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TerminationUpdateManyArgs>(args: SelectSubset<T, TerminationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Termination.
     * @param {TerminationUpsertArgs} args - Arguments to update or create a Termination.
     * @example
     * // Update or create a Termination
     * const termination = await prisma.termination.upsert({
     *   create: {
     *     // ... data to create a Termination
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Termination we want to update
     *   }
     * })
     */
    upsert<T extends TerminationUpsertArgs>(args: SelectSubset<T, TerminationUpsertArgs<ExtArgs>>): Prisma__TerminationClient<$Result.GetResult<Prisma.$TerminationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Terminations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminationCountArgs} args - Arguments to filter Terminations to count.
     * @example
     * // Count the number of Terminations
     * const count = await prisma.termination.count({
     *   where: {
     *     // ... the filter for the Terminations we want to count
     *   }
     * })
    **/
    count<T extends TerminationCountArgs>(
      args?: Subset<T, TerminationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TerminationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Termination.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TerminationAggregateArgs>(args: Subset<T, TerminationAggregateArgs>): Prisma.PrismaPromise<GetTerminationAggregateType<T>>

    /**
     * Group by Termination.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TerminationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TerminationGroupByArgs['orderBy'] }
        : { orderBy?: TerminationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TerminationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTerminationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Termination model
   */
  readonly fields: TerminationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Termination.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TerminationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Termination model
   */
  interface TerminationFieldRefs {
    readonly id: FieldRef<"Termination", 'Int'>
    readonly employeeId: FieldRef<"Termination", 'Int'>
    readonly terminationDate: FieldRef<"Termination", 'DateTime'>
    readonly reason: FieldRef<"Termination", 'String'>
    readonly status: FieldRef<"Termination", 'TerminationStatus'>
    readonly workflowStatus: FieldRef<"Termination", 'WorkflowStatus'>
    readonly remarks: FieldRef<"Termination", 'String'>
    readonly createdAt: FieldRef<"Termination", 'DateTime'>
    readonly updatedAt: FieldRef<"Termination", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Termination findUnique
   */
  export type TerminationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Termination
     */
    select?: TerminationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Termination
     */
    omit?: TerminationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminationInclude<ExtArgs> | null
    /**
     * Filter, which Termination to fetch.
     */
    where: TerminationWhereUniqueInput
  }

  /**
   * Termination findUniqueOrThrow
   */
  export type TerminationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Termination
     */
    select?: TerminationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Termination
     */
    omit?: TerminationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminationInclude<ExtArgs> | null
    /**
     * Filter, which Termination to fetch.
     */
    where: TerminationWhereUniqueInput
  }

  /**
   * Termination findFirst
   */
  export type TerminationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Termination
     */
    select?: TerminationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Termination
     */
    omit?: TerminationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminationInclude<ExtArgs> | null
    /**
     * Filter, which Termination to fetch.
     */
    where?: TerminationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Terminations to fetch.
     */
    orderBy?: TerminationOrderByWithRelationInput | TerminationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Terminations.
     */
    cursor?: TerminationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Terminations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Terminations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Terminations.
     */
    distinct?: TerminationScalarFieldEnum | TerminationScalarFieldEnum[]
  }

  /**
   * Termination findFirstOrThrow
   */
  export type TerminationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Termination
     */
    select?: TerminationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Termination
     */
    omit?: TerminationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminationInclude<ExtArgs> | null
    /**
     * Filter, which Termination to fetch.
     */
    where?: TerminationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Terminations to fetch.
     */
    orderBy?: TerminationOrderByWithRelationInput | TerminationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Terminations.
     */
    cursor?: TerminationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Terminations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Terminations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Terminations.
     */
    distinct?: TerminationScalarFieldEnum | TerminationScalarFieldEnum[]
  }

  /**
   * Termination findMany
   */
  export type TerminationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Termination
     */
    select?: TerminationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Termination
     */
    omit?: TerminationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminationInclude<ExtArgs> | null
    /**
     * Filter, which Terminations to fetch.
     */
    where?: TerminationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Terminations to fetch.
     */
    orderBy?: TerminationOrderByWithRelationInput | TerminationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Terminations.
     */
    cursor?: TerminationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Terminations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Terminations.
     */
    skip?: number
    distinct?: TerminationScalarFieldEnum | TerminationScalarFieldEnum[]
  }

  /**
   * Termination create
   */
  export type TerminationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Termination
     */
    select?: TerminationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Termination
     */
    omit?: TerminationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminationInclude<ExtArgs> | null
    /**
     * The data needed to create a Termination.
     */
    data: XOR<TerminationCreateInput, TerminationUncheckedCreateInput>
  }

  /**
   * Termination createMany
   */
  export type TerminationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Terminations.
     */
    data: TerminationCreateManyInput | TerminationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Termination update
   */
  export type TerminationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Termination
     */
    select?: TerminationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Termination
     */
    omit?: TerminationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminationInclude<ExtArgs> | null
    /**
     * The data needed to update a Termination.
     */
    data: XOR<TerminationUpdateInput, TerminationUncheckedUpdateInput>
    /**
     * Choose, which Termination to update.
     */
    where: TerminationWhereUniqueInput
  }

  /**
   * Termination updateMany
   */
  export type TerminationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Terminations.
     */
    data: XOR<TerminationUpdateManyMutationInput, TerminationUncheckedUpdateManyInput>
    /**
     * Filter which Terminations to update
     */
    where?: TerminationWhereInput
    /**
     * Limit how many Terminations to update.
     */
    limit?: number
  }

  /**
   * Termination upsert
   */
  export type TerminationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Termination
     */
    select?: TerminationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Termination
     */
    omit?: TerminationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminationInclude<ExtArgs> | null
    /**
     * The filter to search for the Termination to update in case it exists.
     */
    where: TerminationWhereUniqueInput
    /**
     * In case the Termination found by the `where` argument doesn't exist, create a new Termination with this data.
     */
    create: XOR<TerminationCreateInput, TerminationUncheckedCreateInput>
    /**
     * In case the Termination was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TerminationUpdateInput, TerminationUncheckedUpdateInput>
  }

  /**
   * Termination delete
   */
  export type TerminationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Termination
     */
    select?: TerminationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Termination
     */
    omit?: TerminationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminationInclude<ExtArgs> | null
    /**
     * Filter which Termination to delete.
     */
    where: TerminationWhereUniqueInput
  }

  /**
   * Termination deleteMany
   */
  export type TerminationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Terminations to delete
     */
    where?: TerminationWhereInput
    /**
     * Limit how many Terminations to delete.
     */
    limit?: number
  }

  /**
   * Termination without action
   */
  export type TerminationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Termination
     */
    select?: TerminationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Termination
     */
    omit?: TerminationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    password: 'password',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    notifyOnComplaint: 'notifyOnComplaint'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    userId: 'userId',
    roleId: 'roleId'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    parentId: 'parentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const PositionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PositionScalarFieldEnum = (typeof PositionScalarFieldEnum)[keyof typeof PositionScalarFieldEnum]


  export const MaritalStatusScalarFieldEnum: {
    id: 'id',
    status: 'status'
  };

  export type MaritalStatusScalarFieldEnum = (typeof MaritalStatusScalarFieldEnum)[keyof typeof MaritalStatusScalarFieldEnum]


  export const EmploymentTypeScalarFieldEnum: {
    id: 'id',
    type: 'type'
  };

  export type EmploymentTypeScalarFieldEnum = (typeof EmploymentTypeScalarFieldEnum)[keyof typeof EmploymentTypeScalarFieldEnum]


  export const JobStatusScalarFieldEnum: {
    id: 'id',
    status: 'status'
  };

  export type JobStatusScalarFieldEnum = (typeof JobStatusScalarFieldEnum)[keyof typeof JobStatusScalarFieldEnum]


  export const AgreementStatusScalarFieldEnum: {
    id: 'id',
    status: 'status'
  };

  export type AgreementStatusScalarFieldEnum = (typeof AgreementStatusScalarFieldEnum)[keyof typeof AgreementStatusScalarFieldEnum]


  export const MeetingScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    date: 'date',
    time: 'time',
    creatorId: 'creatorId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MeetingScalarFieldEnum = (typeof MeetingScalarFieldEnum)[keyof typeof MeetingScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    baptismalName: 'baptismalName',
    dateOfBirth: 'dateOfBirth',
    sex: 'sex',
    nationality: 'nationality',
    maritalStatusId: 'maritalStatusId',
    departmentId: 'departmentId',
    subDepartmentId: 'subDepartmentId',
    positionId: 'positionId',
    employmentTypeId: 'employmentTypeId',
    employmentDate: 'employmentDate',
    jobStatusId: 'jobStatusId',
    phone: 'phone',
    address: 'address',
    subCity: 'subCity',
    emergencyContactName: 'emergencyContactName',
    emergencyContactPhone: 'emergencyContactPhone',
    repentanceFatherName: 'repentanceFatherName',
    repentanceFatherChurch: 'repentanceFatherChurch',
    repentanceFatherPhone: 'repentanceFatherPhone',
    academicQualification: 'academicQualification',
    educationalInstitution: 'educationalInstitution',
    salary: 'salary',
    bonusSalary: 'bonusSalary',
    accountNumber: 'accountNumber',
    agreementStatusId: 'agreementStatusId',
    photo: 'photo',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const ShiftScalarFieldEnum: {
    id: 'id',
    name: 'name',
    startTime: 'startTime',
    endTime: 'endTime',
    isFlexible: 'isFlexible',
    description: 'description'
  };

  export type ShiftScalarFieldEnum = (typeof ShiftScalarFieldEnum)[keyof typeof ShiftScalarFieldEnum]


  export const EmployeeShiftScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    shiftId: 'shiftId',
    effectiveFrom: 'effectiveFrom',
    effectiveTo: 'effectiveTo'
  };

  export type EmployeeShiftScalarFieldEnum = (typeof EmployeeShiftScalarFieldEnum)[keyof typeof EmployeeShiftScalarFieldEnum]


  export const SessionDefinitionScalarFieldEnum: {
    id: 'id',
    sessionNumber: 'sessionNumber',
    expectedClockIn: 'expectedClockIn',
    expectedClockOut: 'expectedClockOut'
  };

  export type SessionDefinitionScalarFieldEnum = (typeof SessionDefinitionScalarFieldEnum)[keyof typeof SessionDefinitionScalarFieldEnum]


  export const AttendanceLogScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    date: 'date',
    sessionId: 'sessionId',
    actualClockIn: 'actualClockIn',
    actualClockOut: 'actualClockOut',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type AttendanceLogScalarFieldEnum = (typeof AttendanceLogScalarFieldEnum)[keyof typeof AttendanceLogScalarFieldEnum]


  export const AttendanceSummaryScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    date: 'date',
    status: 'status',
    lateArrival: 'lateArrival',
    earlyDeparture: 'earlyDeparture',
    unplannedAbsence: 'unplannedAbsence',
    totalWorkHours: 'totalWorkHours',
    remarks: 'remarks',
    departmentId: 'departmentId'
  };

  export type AttendanceSummaryScalarFieldEnum = (typeof AttendanceSummaryScalarFieldEnum)[keyof typeof AttendanceSummaryScalarFieldEnum]


  export const LeaveScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    leaveType: 'leaveType',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    reason: 'reason',
    approvedBy: 'approvedBy',
    requestedAt: 'requestedAt',
    updatedAt: 'updatedAt'
  };

  export type LeaveScalarFieldEnum = (typeof LeaveScalarFieldEnum)[keyof typeof LeaveScalarFieldEnum]


  export const HolidayScalarFieldEnum: {
    id: 'id',
    name: 'name',
    date: 'date',
    isPublic: 'isPublic',
    description: 'description'
  };

  export type HolidayScalarFieldEnum = (typeof HolidayScalarFieldEnum)[keyof typeof HolidayScalarFieldEnum]


  export const OvertimeLogScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    date: 'date',
    hours: 'hours',
    startTime: 'startTime',
    endTime: 'endTime',
    reason: 'reason',
    approvedBy: 'approvedBy',
    approvalStatus: 'approvalStatus',
    compensationMethod: 'compensationMethod'
  };

  export type OvertimeLogScalarFieldEnum = (typeof OvertimeLogScalarFieldEnum)[keyof typeof OvertimeLogScalarFieldEnum]


  export const SalaryScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    salaryMonth: 'salaryMonth',
    amount: 'amount',
    status: 'status',
    overtimeHours: 'overtimeHours',
    overtimePay: 'overtimePay',
    paidAt: 'paidAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SalaryScalarFieldEnum = (typeof SalaryScalarFieldEnum)[keyof typeof SalaryScalarFieldEnum]


  export const ComplaintScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    subject: 'subject',
    description: 'description',
    status: 'status',
    response: 'response',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ComplaintScalarFieldEnum = (typeof ComplaintScalarFieldEnum)[keyof typeof ComplaintScalarFieldEnum]


  export const InterviewScalarFieldEnum: {
    id: 'id',
    candidateName: 'candidateName',
    position: 'position',
    interviewDate: 'interviewDate',
    result: 'result',
    comments: 'comments',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InterviewScalarFieldEnum = (typeof InterviewScalarFieldEnum)[keyof typeof InterviewScalarFieldEnum]


  export const PerformanceReviewScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    reviewDate: 'reviewDate',
    reviewerName: 'reviewerName',
    score: 'score',
    comments: 'comments',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PerformanceReviewScalarFieldEnum = (typeof PerformanceReviewScalarFieldEnum)[keyof typeof PerformanceReviewScalarFieldEnum]


  export const TerminationScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    terminationDate: 'terminationDate',
    reason: 'reason',
    status: 'status',
    workflowStatus: 'workflowStatus',
    remarks: 'remarks',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TerminationScalarFieldEnum = (typeof TerminationScalarFieldEnum)[keyof typeof TerminationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const RoleOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description'
  };

  export type RoleOrderByRelevanceFieldEnum = (typeof RoleOrderByRelevanceFieldEnum)[keyof typeof RoleOrderByRelevanceFieldEnum]


  export const UserOrderByRelevanceFieldEnum: {
    username: 'username',
    email: 'email',
    password: 'password'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const DepartmentOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description'
  };

  export type DepartmentOrderByRelevanceFieldEnum = (typeof DepartmentOrderByRelevanceFieldEnum)[keyof typeof DepartmentOrderByRelevanceFieldEnum]


  export const PositionOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description'
  };

  export type PositionOrderByRelevanceFieldEnum = (typeof PositionOrderByRelevanceFieldEnum)[keyof typeof PositionOrderByRelevanceFieldEnum]


  export const MaritalStatusOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type MaritalStatusOrderByRelevanceFieldEnum = (typeof MaritalStatusOrderByRelevanceFieldEnum)[keyof typeof MaritalStatusOrderByRelevanceFieldEnum]


  export const EmploymentTypeOrderByRelevanceFieldEnum: {
    type: 'type'
  };

  export type EmploymentTypeOrderByRelevanceFieldEnum = (typeof EmploymentTypeOrderByRelevanceFieldEnum)[keyof typeof EmploymentTypeOrderByRelevanceFieldEnum]


  export const JobStatusOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type JobStatusOrderByRelevanceFieldEnum = (typeof JobStatusOrderByRelevanceFieldEnum)[keyof typeof JobStatusOrderByRelevanceFieldEnum]


  export const AgreementStatusOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type AgreementStatusOrderByRelevanceFieldEnum = (typeof AgreementStatusOrderByRelevanceFieldEnum)[keyof typeof AgreementStatusOrderByRelevanceFieldEnum]


  export const MeetingOrderByRelevanceFieldEnum: {
    title: 'title',
    description: 'description',
    date: 'date',
    time: 'time'
  };

  export type MeetingOrderByRelevanceFieldEnum = (typeof MeetingOrderByRelevanceFieldEnum)[keyof typeof MeetingOrderByRelevanceFieldEnum]


  export const EmployeeOrderByRelevanceFieldEnum: {
    firstName: 'firstName',
    lastName: 'lastName',
    baptismalName: 'baptismalName',
    nationality: 'nationality',
    phone: 'phone',
    address: 'address',
    subCity: 'subCity',
    emergencyContactName: 'emergencyContactName',
    emergencyContactPhone: 'emergencyContactPhone',
    repentanceFatherName: 'repentanceFatherName',
    repentanceFatherChurch: 'repentanceFatherChurch',
    repentanceFatherPhone: 'repentanceFatherPhone',
    academicQualification: 'academicQualification',
    educationalInstitution: 'educationalInstitution',
    accountNumber: 'accountNumber',
    photo: 'photo'
  };

  export type EmployeeOrderByRelevanceFieldEnum = (typeof EmployeeOrderByRelevanceFieldEnum)[keyof typeof EmployeeOrderByRelevanceFieldEnum]


  export const ShiftOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description'
  };

  export type ShiftOrderByRelevanceFieldEnum = (typeof ShiftOrderByRelevanceFieldEnum)[keyof typeof ShiftOrderByRelevanceFieldEnum]


  export const AttendanceSummaryOrderByRelevanceFieldEnum: {
    remarks: 'remarks'
  };

  export type AttendanceSummaryOrderByRelevanceFieldEnum = (typeof AttendanceSummaryOrderByRelevanceFieldEnum)[keyof typeof AttendanceSummaryOrderByRelevanceFieldEnum]


  export const LeaveOrderByRelevanceFieldEnum: {
    reason: 'reason'
  };

  export type LeaveOrderByRelevanceFieldEnum = (typeof LeaveOrderByRelevanceFieldEnum)[keyof typeof LeaveOrderByRelevanceFieldEnum]


  export const HolidayOrderByRelevanceFieldEnum: {
    name: 'name',
    description: 'description'
  };

  export type HolidayOrderByRelevanceFieldEnum = (typeof HolidayOrderByRelevanceFieldEnum)[keyof typeof HolidayOrderByRelevanceFieldEnum]


  export const OvertimeLogOrderByRelevanceFieldEnum: {
    reason: 'reason'
  };

  export type OvertimeLogOrderByRelevanceFieldEnum = (typeof OvertimeLogOrderByRelevanceFieldEnum)[keyof typeof OvertimeLogOrderByRelevanceFieldEnum]


  export const ComplaintOrderByRelevanceFieldEnum: {
    subject: 'subject',
    description: 'description',
    response: 'response'
  };

  export type ComplaintOrderByRelevanceFieldEnum = (typeof ComplaintOrderByRelevanceFieldEnum)[keyof typeof ComplaintOrderByRelevanceFieldEnum]


  export const InterviewOrderByRelevanceFieldEnum: {
    candidateName: 'candidateName',
    position: 'position',
    comments: 'comments'
  };

  export type InterviewOrderByRelevanceFieldEnum = (typeof InterviewOrderByRelevanceFieldEnum)[keyof typeof InterviewOrderByRelevanceFieldEnum]


  export const PerformanceReviewOrderByRelevanceFieldEnum: {
    reviewerName: 'reviewerName',
    comments: 'comments'
  };

  export type PerformanceReviewOrderByRelevanceFieldEnum = (typeof PerformanceReviewOrderByRelevanceFieldEnum)[keyof typeof PerformanceReviewOrderByRelevanceFieldEnum]


  export const TerminationOrderByRelevanceFieldEnum: {
    reason: 'reason',
    remarks: 'remarks'
  };

  export type TerminationOrderByRelevanceFieldEnum = (typeof TerminationOrderByRelevanceFieldEnum)[keyof typeof TerminationOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Sex'
   */
  export type EnumSexFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Sex'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'AttendanceStatus'
   */
  export type EnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus'>
    


  /**
   * Reference to a field of type 'SummaryStatus'
   */
  export type EnumSummaryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SummaryStatus'>
    


  /**
   * Reference to a field of type 'LeaveType'
   */
  export type EnumLeaveTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveType'>
    


  /**
   * Reference to a field of type 'LeaveStatus'
   */
  export type EnumLeaveStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveStatus'>
    


  /**
   * Reference to a field of type 'OvertimeApprovalStatus'
   */
  export type EnumOvertimeApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OvertimeApprovalStatus'>
    


  /**
   * Reference to a field of type 'CompensationMethod'
   */
  export type EnumCompensationMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompensationMethod'>
    


  /**
   * Reference to a field of type 'SalaryStatus'
   */
  export type EnumSalaryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SalaryStatus'>
    


  /**
   * Reference to a field of type 'ComplaintStatus'
   */
  export type EnumComplaintStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplaintStatus'>
    


  /**
   * Reference to a field of type 'InterviewResult'
   */
  export type EnumInterviewResultFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InterviewResult'>
    


  /**
   * Reference to a field of type 'TerminationStatus'
   */
  export type EnumTerminationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TerminationStatus'>
    


  /**
   * Reference to a field of type 'WorkflowStatus'
   */
  export type EnumWorkflowStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowStatus'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: IntFilter<"Role"> | number
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    users?: UserRoleListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserRoleOrderByRelationAggregateInput
    _relevance?: RoleOrderByRelevanceInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    users?: UserRoleListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _avg?: RoleAvgOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
    _sum?: RoleSumOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Role"> | number
    name?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    notifyOnComplaint?: BoolFilter<"User"> | boolean
    roles?: UserRoleListRelationFilter
    employees?: EmployeeListRelationFilter
    approvedLeaves?: LeaveListRelationFilter
    approvedOvertimes?: OvertimeLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notifyOnComplaint?: SortOrder
    roles?: UserRoleOrderByRelationAggregateInput
    employees?: EmployeeOrderByRelationAggregateInput
    approvedLeaves?: LeaveOrderByRelationAggregateInput
    approvedOvertimes?: OvertimeLogOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    notifyOnComplaint?: BoolFilter<"User"> | boolean
    roles?: UserRoleListRelationFilter
    employees?: EmployeeListRelationFilter
    approvedLeaves?: LeaveListRelationFilter
    approvedOvertimes?: OvertimeLogListRelationFilter
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notifyOnComplaint?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    username?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    notifyOnComplaint?: BoolWithAggregatesFilter<"User"> | boolean
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: IntFilter<"UserRole"> | number
    roleId?: IntFilter<"UserRole"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }

  export type UserRoleOrderByWithRelationInput = {
    userId?: SortOrder
    roleId?: SortOrder
    user?: UserOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    userId_roleId?: UserRoleUserIdRoleIdCompoundUniqueInput
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: IntFilter<"UserRole"> | number
    roleId?: IntFilter<"UserRole"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }, "userId_roleId">

  export type UserRoleOrderByWithAggregationInput = {
    userId?: SortOrder
    roleId?: SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _avg?: UserRoleAvgOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
    _sum?: UserRoleSumOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"UserRole"> | number
    roleId?: IntWithAggregatesFilter<"UserRole"> | number
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: IntFilter<"Department"> | number
    name?: StringFilter<"Department"> | string
    description?: StringNullableFilter<"Department"> | string | null
    parentId?: IntNullableFilter<"Department"> | number | null
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    parent?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    subDepartments?: DepartmentListRelationFilter
    employees?: EmployeeListRelationFilter
    attendanceSummaries?: AttendanceSummaryListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parent?: DepartmentOrderByWithRelationInput
    subDepartments?: DepartmentOrderByRelationAggregateInput
    employees?: EmployeeOrderByRelationAggregateInput
    attendanceSummaries?: AttendanceSummaryOrderByRelationAggregateInput
    _relevance?: DepartmentOrderByRelevanceInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    description?: StringNullableFilter<"Department"> | string | null
    parentId?: IntNullableFilter<"Department"> | number | null
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    parent?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    subDepartments?: DepartmentListRelationFilter
    employees?: EmployeeListRelationFilter
    attendanceSummaries?: AttendanceSummaryListRelationFilter
  }, "id" | "name">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _avg?: DepartmentAvgOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
    _sum?: DepartmentSumOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Department"> | number
    name?: StringWithAggregatesFilter<"Department"> | string
    description?: StringNullableWithAggregatesFilter<"Department"> | string | null
    parentId?: IntNullableWithAggregatesFilter<"Department"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
  }

  export type PositionWhereInput = {
    AND?: PositionWhereInput | PositionWhereInput[]
    OR?: PositionWhereInput[]
    NOT?: PositionWhereInput | PositionWhereInput[]
    id?: IntFilter<"Position"> | number
    name?: StringFilter<"Position"> | string
    description?: StringNullableFilter<"Position"> | string | null
    createdAt?: DateTimeFilter<"Position"> | Date | string
    updatedAt?: DateTimeFilter<"Position"> | Date | string
    employees?: EmployeeListRelationFilter
  }

  export type PositionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employees?: EmployeeOrderByRelationAggregateInput
    _relevance?: PositionOrderByRelevanceInput
  }

  export type PositionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: PositionWhereInput | PositionWhereInput[]
    OR?: PositionWhereInput[]
    NOT?: PositionWhereInput | PositionWhereInput[]
    description?: StringNullableFilter<"Position"> | string | null
    createdAt?: DateTimeFilter<"Position"> | Date | string
    updatedAt?: DateTimeFilter<"Position"> | Date | string
    employees?: EmployeeListRelationFilter
  }, "id" | "name">

  export type PositionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PositionCountOrderByAggregateInput
    _avg?: PositionAvgOrderByAggregateInput
    _max?: PositionMaxOrderByAggregateInput
    _min?: PositionMinOrderByAggregateInput
    _sum?: PositionSumOrderByAggregateInput
  }

  export type PositionScalarWhereWithAggregatesInput = {
    AND?: PositionScalarWhereWithAggregatesInput | PositionScalarWhereWithAggregatesInput[]
    OR?: PositionScalarWhereWithAggregatesInput[]
    NOT?: PositionScalarWhereWithAggregatesInput | PositionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Position"> | number
    name?: StringWithAggregatesFilter<"Position"> | string
    description?: StringNullableWithAggregatesFilter<"Position"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Position"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Position"> | Date | string
  }

  export type MaritalStatusWhereInput = {
    AND?: MaritalStatusWhereInput | MaritalStatusWhereInput[]
    OR?: MaritalStatusWhereInput[]
    NOT?: MaritalStatusWhereInput | MaritalStatusWhereInput[]
    id?: IntFilter<"MaritalStatus"> | number
    status?: StringFilter<"MaritalStatus"> | string
    employees?: EmployeeListRelationFilter
  }

  export type MaritalStatusOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    employees?: EmployeeOrderByRelationAggregateInput
    _relevance?: MaritalStatusOrderByRelevanceInput
  }

  export type MaritalStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    status?: string
    AND?: MaritalStatusWhereInput | MaritalStatusWhereInput[]
    OR?: MaritalStatusWhereInput[]
    NOT?: MaritalStatusWhereInput | MaritalStatusWhereInput[]
    employees?: EmployeeListRelationFilter
  }, "id" | "status">

  export type MaritalStatusOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    _count?: MaritalStatusCountOrderByAggregateInput
    _avg?: MaritalStatusAvgOrderByAggregateInput
    _max?: MaritalStatusMaxOrderByAggregateInput
    _min?: MaritalStatusMinOrderByAggregateInput
    _sum?: MaritalStatusSumOrderByAggregateInput
  }

  export type MaritalStatusScalarWhereWithAggregatesInput = {
    AND?: MaritalStatusScalarWhereWithAggregatesInput | MaritalStatusScalarWhereWithAggregatesInput[]
    OR?: MaritalStatusScalarWhereWithAggregatesInput[]
    NOT?: MaritalStatusScalarWhereWithAggregatesInput | MaritalStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MaritalStatus"> | number
    status?: StringWithAggregatesFilter<"MaritalStatus"> | string
  }

  export type EmploymentTypeWhereInput = {
    AND?: EmploymentTypeWhereInput | EmploymentTypeWhereInput[]
    OR?: EmploymentTypeWhereInput[]
    NOT?: EmploymentTypeWhereInput | EmploymentTypeWhereInput[]
    id?: IntFilter<"EmploymentType"> | number
    type?: StringFilter<"EmploymentType"> | string
    employees?: EmployeeListRelationFilter
  }

  export type EmploymentTypeOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    employees?: EmployeeOrderByRelationAggregateInput
    _relevance?: EmploymentTypeOrderByRelevanceInput
  }

  export type EmploymentTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    type?: string
    AND?: EmploymentTypeWhereInput | EmploymentTypeWhereInput[]
    OR?: EmploymentTypeWhereInput[]
    NOT?: EmploymentTypeWhereInput | EmploymentTypeWhereInput[]
    employees?: EmployeeListRelationFilter
  }, "id" | "type">

  export type EmploymentTypeOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    _count?: EmploymentTypeCountOrderByAggregateInput
    _avg?: EmploymentTypeAvgOrderByAggregateInput
    _max?: EmploymentTypeMaxOrderByAggregateInput
    _min?: EmploymentTypeMinOrderByAggregateInput
    _sum?: EmploymentTypeSumOrderByAggregateInput
  }

  export type EmploymentTypeScalarWhereWithAggregatesInput = {
    AND?: EmploymentTypeScalarWhereWithAggregatesInput | EmploymentTypeScalarWhereWithAggregatesInput[]
    OR?: EmploymentTypeScalarWhereWithAggregatesInput[]
    NOT?: EmploymentTypeScalarWhereWithAggregatesInput | EmploymentTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmploymentType"> | number
    type?: StringWithAggregatesFilter<"EmploymentType"> | string
  }

  export type JobStatusWhereInput = {
    AND?: JobStatusWhereInput | JobStatusWhereInput[]
    OR?: JobStatusWhereInput[]
    NOT?: JobStatusWhereInput | JobStatusWhereInput[]
    id?: IntFilter<"JobStatus"> | number
    status?: StringFilter<"JobStatus"> | string
    employees?: EmployeeListRelationFilter
  }

  export type JobStatusOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    employees?: EmployeeOrderByRelationAggregateInput
    _relevance?: JobStatusOrderByRelevanceInput
  }

  export type JobStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    status?: string
    AND?: JobStatusWhereInput | JobStatusWhereInput[]
    OR?: JobStatusWhereInput[]
    NOT?: JobStatusWhereInput | JobStatusWhereInput[]
    employees?: EmployeeListRelationFilter
  }, "id" | "status">

  export type JobStatusOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    _count?: JobStatusCountOrderByAggregateInput
    _avg?: JobStatusAvgOrderByAggregateInput
    _max?: JobStatusMaxOrderByAggregateInput
    _min?: JobStatusMinOrderByAggregateInput
    _sum?: JobStatusSumOrderByAggregateInput
  }

  export type JobStatusScalarWhereWithAggregatesInput = {
    AND?: JobStatusScalarWhereWithAggregatesInput | JobStatusScalarWhereWithAggregatesInput[]
    OR?: JobStatusScalarWhereWithAggregatesInput[]
    NOT?: JobStatusScalarWhereWithAggregatesInput | JobStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"JobStatus"> | number
    status?: StringWithAggregatesFilter<"JobStatus"> | string
  }

  export type AgreementStatusWhereInput = {
    AND?: AgreementStatusWhereInput | AgreementStatusWhereInput[]
    OR?: AgreementStatusWhereInput[]
    NOT?: AgreementStatusWhereInput | AgreementStatusWhereInput[]
    id?: IntFilter<"AgreementStatus"> | number
    status?: StringFilter<"AgreementStatus"> | string
    employees?: EmployeeListRelationFilter
  }

  export type AgreementStatusOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    employees?: EmployeeOrderByRelationAggregateInput
    _relevance?: AgreementStatusOrderByRelevanceInput
  }

  export type AgreementStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    status?: string
    AND?: AgreementStatusWhereInput | AgreementStatusWhereInput[]
    OR?: AgreementStatusWhereInput[]
    NOT?: AgreementStatusWhereInput | AgreementStatusWhereInput[]
    employees?: EmployeeListRelationFilter
  }, "id" | "status">

  export type AgreementStatusOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    _count?: AgreementStatusCountOrderByAggregateInput
    _avg?: AgreementStatusAvgOrderByAggregateInput
    _max?: AgreementStatusMaxOrderByAggregateInput
    _min?: AgreementStatusMinOrderByAggregateInput
    _sum?: AgreementStatusSumOrderByAggregateInput
  }

  export type AgreementStatusScalarWhereWithAggregatesInput = {
    AND?: AgreementStatusScalarWhereWithAggregatesInput | AgreementStatusScalarWhereWithAggregatesInput[]
    OR?: AgreementStatusScalarWhereWithAggregatesInput[]
    NOT?: AgreementStatusScalarWhereWithAggregatesInput | AgreementStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AgreementStatus"> | number
    status?: StringWithAggregatesFilter<"AgreementStatus"> | string
  }

  export type MeetingWhereInput = {
    AND?: MeetingWhereInput | MeetingWhereInput[]
    OR?: MeetingWhereInput[]
    NOT?: MeetingWhereInput | MeetingWhereInput[]
    id?: IntFilter<"Meeting"> | number
    title?: StringFilter<"Meeting"> | string
    description?: StringNullableFilter<"Meeting"> | string | null
    date?: StringFilter<"Meeting"> | string
    time?: StringFilter<"Meeting"> | string
    creatorId?: IntNullableFilter<"Meeting"> | number | null
    createdAt?: DateTimeFilter<"Meeting"> | Date | string
    updatedAt?: DateTimeFilter<"Meeting"> | Date | string
    creator?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
  }

  export type MeetingOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    time?: SortOrder
    creatorId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: EmployeeOrderByWithRelationInput
    _relevance?: MeetingOrderByRelevanceInput
  }

  export type MeetingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MeetingWhereInput | MeetingWhereInput[]
    OR?: MeetingWhereInput[]
    NOT?: MeetingWhereInput | MeetingWhereInput[]
    title?: StringFilter<"Meeting"> | string
    description?: StringNullableFilter<"Meeting"> | string | null
    date?: StringFilter<"Meeting"> | string
    time?: StringFilter<"Meeting"> | string
    creatorId?: IntNullableFilter<"Meeting"> | number | null
    createdAt?: DateTimeFilter<"Meeting"> | Date | string
    updatedAt?: DateTimeFilter<"Meeting"> | Date | string
    creator?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
  }, "id">

  export type MeetingOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    time?: SortOrder
    creatorId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MeetingCountOrderByAggregateInput
    _avg?: MeetingAvgOrderByAggregateInput
    _max?: MeetingMaxOrderByAggregateInput
    _min?: MeetingMinOrderByAggregateInput
    _sum?: MeetingSumOrderByAggregateInput
  }

  export type MeetingScalarWhereWithAggregatesInput = {
    AND?: MeetingScalarWhereWithAggregatesInput | MeetingScalarWhereWithAggregatesInput[]
    OR?: MeetingScalarWhereWithAggregatesInput[]
    NOT?: MeetingScalarWhereWithAggregatesInput | MeetingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Meeting"> | number
    title?: StringWithAggregatesFilter<"Meeting"> | string
    description?: StringNullableWithAggregatesFilter<"Meeting"> | string | null
    date?: StringWithAggregatesFilter<"Meeting"> | string
    time?: StringWithAggregatesFilter<"Meeting"> | string
    creatorId?: IntNullableWithAggregatesFilter<"Meeting"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Meeting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Meeting"> | Date | string
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: IntFilter<"Employee"> | number
    userId?: IntNullableFilter<"Employee"> | number | null
    firstName?: StringFilter<"Employee"> | string
    lastName?: StringFilter<"Employee"> | string
    baptismalName?: StringNullableFilter<"Employee"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Employee"> | Date | string | null
    sex?: EnumSexFilter<"Employee"> | $Enums.Sex
    nationality?: StringNullableFilter<"Employee"> | string | null
    maritalStatusId?: IntNullableFilter<"Employee"> | number | null
    departmentId?: IntNullableFilter<"Employee"> | number | null
    subDepartmentId?: IntNullableFilter<"Employee"> | number | null
    positionId?: IntNullableFilter<"Employee"> | number | null
    employmentTypeId?: IntNullableFilter<"Employee"> | number | null
    employmentDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    jobStatusId?: IntNullableFilter<"Employee"> | number | null
    phone?: StringNullableFilter<"Employee"> | string | null
    address?: StringNullableFilter<"Employee"> | string | null
    subCity?: StringNullableFilter<"Employee"> | string | null
    emergencyContactName?: StringNullableFilter<"Employee"> | string | null
    emergencyContactPhone?: StringNullableFilter<"Employee"> | string | null
    repentanceFatherName?: StringNullableFilter<"Employee"> | string | null
    repentanceFatherChurch?: StringNullableFilter<"Employee"> | string | null
    repentanceFatherPhone?: StringNullableFilter<"Employee"> | string | null
    academicQualification?: StringNullableFilter<"Employee"> | string | null
    educationalInstitution?: StringNullableFilter<"Employee"> | string | null
    salary?: DecimalFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    accountNumber?: StringNullableFilter<"Employee"> | string | null
    agreementStatusId?: IntNullableFilter<"Employee"> | number | null
    photo?: StringNullableFilter<"Employee"> | string | null
    deletedAt?: DateTimeNullableFilter<"Employee"> | Date | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    position?: XOR<PositionNullableScalarRelationFilter, PositionWhereInput> | null
    maritalStatus?: XOR<MaritalStatusNullableScalarRelationFilter, MaritalStatusWhereInput> | null
    employmentType?: XOR<EmploymentTypeNullableScalarRelationFilter, EmploymentTypeWhereInput> | null
    jobStatus?: XOR<JobStatusNullableScalarRelationFilter, JobStatusWhereInput> | null
    agreementStatus?: XOR<AgreementStatusNullableScalarRelationFilter, AgreementStatusWhereInput> | null
    createdMeetings?: MeetingListRelationFilter
    shifts?: EmployeeShiftListRelationFilter
    attendanceLogs?: AttendanceLogListRelationFilter
    attendanceSummaries?: AttendanceSummaryListRelationFilter
    leaves?: LeaveListRelationFilter
    complaints?: ComplaintListRelationFilter
    performanceReviews?: PerformanceReviewListRelationFilter
    terminations?: TerminationListRelationFilter
    salaries?: SalaryListRelationFilter
    overtimes?: OvertimeLogListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    baptismalName?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    sex?: SortOrder
    nationality?: SortOrderInput | SortOrder
    maritalStatusId?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    subDepartmentId?: SortOrderInput | SortOrder
    positionId?: SortOrderInput | SortOrder
    employmentTypeId?: SortOrderInput | SortOrder
    employmentDate?: SortOrderInput | SortOrder
    jobStatusId?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    subCity?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    repentanceFatherName?: SortOrderInput | SortOrder
    repentanceFatherChurch?: SortOrderInput | SortOrder
    repentanceFatherPhone?: SortOrderInput | SortOrder
    academicQualification?: SortOrderInput | SortOrder
    educationalInstitution?: SortOrderInput | SortOrder
    salary?: SortOrder
    bonusSalary?: SortOrder
    accountNumber?: SortOrderInput | SortOrder
    agreementStatusId?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    department?: DepartmentOrderByWithRelationInput
    position?: PositionOrderByWithRelationInput
    maritalStatus?: MaritalStatusOrderByWithRelationInput
    employmentType?: EmploymentTypeOrderByWithRelationInput
    jobStatus?: JobStatusOrderByWithRelationInput
    agreementStatus?: AgreementStatusOrderByWithRelationInput
    createdMeetings?: MeetingOrderByRelationAggregateInput
    shifts?: EmployeeShiftOrderByRelationAggregateInput
    attendanceLogs?: AttendanceLogOrderByRelationAggregateInput
    attendanceSummaries?: AttendanceSummaryOrderByRelationAggregateInput
    leaves?: LeaveOrderByRelationAggregateInput
    complaints?: ComplaintOrderByRelationAggregateInput
    performanceReviews?: PerformanceReviewOrderByRelationAggregateInput
    terminations?: TerminationOrderByRelationAggregateInput
    salaries?: SalaryOrderByRelationAggregateInput
    overtimes?: OvertimeLogOrderByRelationAggregateInput
    _relevance?: EmployeeOrderByRelevanceInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    firstName?: StringFilter<"Employee"> | string
    lastName?: StringFilter<"Employee"> | string
    baptismalName?: StringNullableFilter<"Employee"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Employee"> | Date | string | null
    sex?: EnumSexFilter<"Employee"> | $Enums.Sex
    nationality?: StringNullableFilter<"Employee"> | string | null
    maritalStatusId?: IntNullableFilter<"Employee"> | number | null
    departmentId?: IntNullableFilter<"Employee"> | number | null
    subDepartmentId?: IntNullableFilter<"Employee"> | number | null
    positionId?: IntNullableFilter<"Employee"> | number | null
    employmentTypeId?: IntNullableFilter<"Employee"> | number | null
    employmentDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    jobStatusId?: IntNullableFilter<"Employee"> | number | null
    phone?: StringNullableFilter<"Employee"> | string | null
    address?: StringNullableFilter<"Employee"> | string | null
    subCity?: StringNullableFilter<"Employee"> | string | null
    emergencyContactName?: StringNullableFilter<"Employee"> | string | null
    emergencyContactPhone?: StringNullableFilter<"Employee"> | string | null
    repentanceFatherName?: StringNullableFilter<"Employee"> | string | null
    repentanceFatherChurch?: StringNullableFilter<"Employee"> | string | null
    repentanceFatherPhone?: StringNullableFilter<"Employee"> | string | null
    academicQualification?: StringNullableFilter<"Employee"> | string | null
    educationalInstitution?: StringNullableFilter<"Employee"> | string | null
    salary?: DecimalFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    accountNumber?: StringNullableFilter<"Employee"> | string | null
    agreementStatusId?: IntNullableFilter<"Employee"> | number | null
    photo?: StringNullableFilter<"Employee"> | string | null
    deletedAt?: DateTimeNullableFilter<"Employee"> | Date | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    position?: XOR<PositionNullableScalarRelationFilter, PositionWhereInput> | null
    maritalStatus?: XOR<MaritalStatusNullableScalarRelationFilter, MaritalStatusWhereInput> | null
    employmentType?: XOR<EmploymentTypeNullableScalarRelationFilter, EmploymentTypeWhereInput> | null
    jobStatus?: XOR<JobStatusNullableScalarRelationFilter, JobStatusWhereInput> | null
    agreementStatus?: XOR<AgreementStatusNullableScalarRelationFilter, AgreementStatusWhereInput> | null
    createdMeetings?: MeetingListRelationFilter
    shifts?: EmployeeShiftListRelationFilter
    attendanceLogs?: AttendanceLogListRelationFilter
    attendanceSummaries?: AttendanceSummaryListRelationFilter
    leaves?: LeaveListRelationFilter
    complaints?: ComplaintListRelationFilter
    performanceReviews?: PerformanceReviewListRelationFilter
    terminations?: TerminationListRelationFilter
    salaries?: SalaryListRelationFilter
    overtimes?: OvertimeLogListRelationFilter
  }, "id" | "userId">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    baptismalName?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    sex?: SortOrder
    nationality?: SortOrderInput | SortOrder
    maritalStatusId?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    subDepartmentId?: SortOrderInput | SortOrder
    positionId?: SortOrderInput | SortOrder
    employmentTypeId?: SortOrderInput | SortOrder
    employmentDate?: SortOrderInput | SortOrder
    jobStatusId?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    subCity?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    repentanceFatherName?: SortOrderInput | SortOrder
    repentanceFatherChurch?: SortOrderInput | SortOrder
    repentanceFatherPhone?: SortOrderInput | SortOrder
    academicQualification?: SortOrderInput | SortOrder
    educationalInstitution?: SortOrderInput | SortOrder
    salary?: SortOrder
    bonusSalary?: SortOrder
    accountNumber?: SortOrderInput | SortOrder
    agreementStatusId?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _avg?: EmployeeAvgOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
    _sum?: EmployeeSumOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Employee"> | number
    userId?: IntNullableWithAggregatesFilter<"Employee"> | number | null
    firstName?: StringWithAggregatesFilter<"Employee"> | string
    lastName?: StringWithAggregatesFilter<"Employee"> | string
    baptismalName?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
    sex?: EnumSexWithAggregatesFilter<"Employee"> | $Enums.Sex
    nationality?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    maritalStatusId?: IntNullableWithAggregatesFilter<"Employee"> | number | null
    departmentId?: IntNullableWithAggregatesFilter<"Employee"> | number | null
    subDepartmentId?: IntNullableWithAggregatesFilter<"Employee"> | number | null
    positionId?: IntNullableWithAggregatesFilter<"Employee"> | number | null
    employmentTypeId?: IntNullableWithAggregatesFilter<"Employee"> | number | null
    employmentDate?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
    jobStatusId?: IntNullableWithAggregatesFilter<"Employee"> | number | null
    phone?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    address?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    subCity?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    emergencyContactName?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    emergencyContactPhone?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    repentanceFatherName?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    repentanceFatherChurch?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    repentanceFatherPhone?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    academicQualification?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    educationalInstitution?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    salary?: DecimalWithAggregatesFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalWithAggregatesFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    accountNumber?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    agreementStatusId?: IntNullableWithAggregatesFilter<"Employee"> | number | null
    photo?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
  }

  export type ShiftWhereInput = {
    AND?: ShiftWhereInput | ShiftWhereInput[]
    OR?: ShiftWhereInput[]
    NOT?: ShiftWhereInput | ShiftWhereInput[]
    id?: IntFilter<"Shift"> | number
    name?: StringFilter<"Shift"> | string
    startTime?: DateTimeFilter<"Shift"> | Date | string
    endTime?: DateTimeFilter<"Shift"> | Date | string
    isFlexible?: BoolFilter<"Shift"> | boolean
    description?: StringNullableFilter<"Shift"> | string | null
    assignments?: EmployeeShiftListRelationFilter
  }

  export type ShiftOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isFlexible?: SortOrder
    description?: SortOrderInput | SortOrder
    assignments?: EmployeeShiftOrderByRelationAggregateInput
    _relevance?: ShiftOrderByRelevanceInput
  }

  export type ShiftWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ShiftWhereInput | ShiftWhereInput[]
    OR?: ShiftWhereInput[]
    NOT?: ShiftWhereInput | ShiftWhereInput[]
    name?: StringFilter<"Shift"> | string
    startTime?: DateTimeFilter<"Shift"> | Date | string
    endTime?: DateTimeFilter<"Shift"> | Date | string
    isFlexible?: BoolFilter<"Shift"> | boolean
    description?: StringNullableFilter<"Shift"> | string | null
    assignments?: EmployeeShiftListRelationFilter
  }, "id">

  export type ShiftOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isFlexible?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: ShiftCountOrderByAggregateInput
    _avg?: ShiftAvgOrderByAggregateInput
    _max?: ShiftMaxOrderByAggregateInput
    _min?: ShiftMinOrderByAggregateInput
    _sum?: ShiftSumOrderByAggregateInput
  }

  export type ShiftScalarWhereWithAggregatesInput = {
    AND?: ShiftScalarWhereWithAggregatesInput | ShiftScalarWhereWithAggregatesInput[]
    OR?: ShiftScalarWhereWithAggregatesInput[]
    NOT?: ShiftScalarWhereWithAggregatesInput | ShiftScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Shift"> | number
    name?: StringWithAggregatesFilter<"Shift"> | string
    startTime?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
    isFlexible?: BoolWithAggregatesFilter<"Shift"> | boolean
    description?: StringNullableWithAggregatesFilter<"Shift"> | string | null
  }

  export type EmployeeShiftWhereInput = {
    AND?: EmployeeShiftWhereInput | EmployeeShiftWhereInput[]
    OR?: EmployeeShiftWhereInput[]
    NOT?: EmployeeShiftWhereInput | EmployeeShiftWhereInput[]
    id?: IntFilter<"EmployeeShift"> | number
    employeeId?: IntFilter<"EmployeeShift"> | number
    shiftId?: IntFilter<"EmployeeShift"> | number
    effectiveFrom?: DateTimeFilter<"EmployeeShift"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"EmployeeShift"> | Date | string | null
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    shift?: XOR<ShiftScalarRelationFilter, ShiftWhereInput>
  }

  export type EmployeeShiftOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    employee?: EmployeeOrderByWithRelationInput
    shift?: ShiftOrderByWithRelationInput
  }

  export type EmployeeShiftWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmployeeShiftWhereInput | EmployeeShiftWhereInput[]
    OR?: EmployeeShiftWhereInput[]
    NOT?: EmployeeShiftWhereInput | EmployeeShiftWhereInput[]
    employeeId?: IntFilter<"EmployeeShift"> | number
    shiftId?: IntFilter<"EmployeeShift"> | number
    effectiveFrom?: DateTimeFilter<"EmployeeShift"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"EmployeeShift"> | Date | string | null
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    shift?: XOR<ShiftScalarRelationFilter, ShiftWhereInput>
  }, "id">

  export type EmployeeShiftOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    _count?: EmployeeShiftCountOrderByAggregateInput
    _avg?: EmployeeShiftAvgOrderByAggregateInput
    _max?: EmployeeShiftMaxOrderByAggregateInput
    _min?: EmployeeShiftMinOrderByAggregateInput
    _sum?: EmployeeShiftSumOrderByAggregateInput
  }

  export type EmployeeShiftScalarWhereWithAggregatesInput = {
    AND?: EmployeeShiftScalarWhereWithAggregatesInput | EmployeeShiftScalarWhereWithAggregatesInput[]
    OR?: EmployeeShiftScalarWhereWithAggregatesInput[]
    NOT?: EmployeeShiftScalarWhereWithAggregatesInput | EmployeeShiftScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmployeeShift"> | number
    employeeId?: IntWithAggregatesFilter<"EmployeeShift"> | number
    shiftId?: IntWithAggregatesFilter<"EmployeeShift"> | number
    effectiveFrom?: DateTimeWithAggregatesFilter<"EmployeeShift"> | Date | string
    effectiveTo?: DateTimeNullableWithAggregatesFilter<"EmployeeShift"> | Date | string | null
  }

  export type SessionDefinitionWhereInput = {
    AND?: SessionDefinitionWhereInput | SessionDefinitionWhereInput[]
    OR?: SessionDefinitionWhereInput[]
    NOT?: SessionDefinitionWhereInput | SessionDefinitionWhereInput[]
    id?: IntFilter<"SessionDefinition"> | number
    sessionNumber?: IntFilter<"SessionDefinition"> | number
    expectedClockIn?: DateTimeFilter<"SessionDefinition"> | Date | string
    expectedClockOut?: DateTimeFilter<"SessionDefinition"> | Date | string
    logs?: AttendanceLogListRelationFilter
  }

  export type SessionDefinitionOrderByWithRelationInput = {
    id?: SortOrder
    sessionNumber?: SortOrder
    expectedClockIn?: SortOrder
    expectedClockOut?: SortOrder
    logs?: AttendanceLogOrderByRelationAggregateInput
  }

  export type SessionDefinitionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sessionNumber?: number
    AND?: SessionDefinitionWhereInput | SessionDefinitionWhereInput[]
    OR?: SessionDefinitionWhereInput[]
    NOT?: SessionDefinitionWhereInput | SessionDefinitionWhereInput[]
    expectedClockIn?: DateTimeFilter<"SessionDefinition"> | Date | string
    expectedClockOut?: DateTimeFilter<"SessionDefinition"> | Date | string
    logs?: AttendanceLogListRelationFilter
  }, "id" | "sessionNumber">

  export type SessionDefinitionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionNumber?: SortOrder
    expectedClockIn?: SortOrder
    expectedClockOut?: SortOrder
    _count?: SessionDefinitionCountOrderByAggregateInput
    _avg?: SessionDefinitionAvgOrderByAggregateInput
    _max?: SessionDefinitionMaxOrderByAggregateInput
    _min?: SessionDefinitionMinOrderByAggregateInput
    _sum?: SessionDefinitionSumOrderByAggregateInput
  }

  export type SessionDefinitionScalarWhereWithAggregatesInput = {
    AND?: SessionDefinitionScalarWhereWithAggregatesInput | SessionDefinitionScalarWhereWithAggregatesInput[]
    OR?: SessionDefinitionScalarWhereWithAggregatesInput[]
    NOT?: SessionDefinitionScalarWhereWithAggregatesInput | SessionDefinitionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SessionDefinition"> | number
    sessionNumber?: IntWithAggregatesFilter<"SessionDefinition"> | number
    expectedClockIn?: DateTimeWithAggregatesFilter<"SessionDefinition"> | Date | string
    expectedClockOut?: DateTimeWithAggregatesFilter<"SessionDefinition"> | Date | string
  }

  export type AttendanceLogWhereInput = {
    AND?: AttendanceLogWhereInput | AttendanceLogWhereInput[]
    OR?: AttendanceLogWhereInput[]
    NOT?: AttendanceLogWhereInput | AttendanceLogWhereInput[]
    id?: IntFilter<"AttendanceLog"> | number
    employeeId?: IntFilter<"AttendanceLog"> | number
    date?: DateTimeFilter<"AttendanceLog"> | Date | string
    sessionId?: IntFilter<"AttendanceLog"> | number
    actualClockIn?: DateTimeNullableFilter<"AttendanceLog"> | Date | string | null
    actualClockOut?: DateTimeNullableFilter<"AttendanceLog"> | Date | string | null
    status?: EnumAttendanceStatusFilter<"AttendanceLog"> | $Enums.AttendanceStatus
    createdAt?: DateTimeFilter<"AttendanceLog"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    session?: XOR<SessionDefinitionScalarRelationFilter, SessionDefinitionWhereInput>
  }

  export type AttendanceLogOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    sessionId?: SortOrder
    actualClockIn?: SortOrderInput | SortOrder
    actualClockOut?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    session?: SessionDefinitionOrderByWithRelationInput
  }

  export type AttendanceLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    employeeId_date_sessionId?: AttendanceLogEmployeeIdDateSessionIdCompoundUniqueInput
    AND?: AttendanceLogWhereInput | AttendanceLogWhereInput[]
    OR?: AttendanceLogWhereInput[]
    NOT?: AttendanceLogWhereInput | AttendanceLogWhereInput[]
    employeeId?: IntFilter<"AttendanceLog"> | number
    date?: DateTimeFilter<"AttendanceLog"> | Date | string
    sessionId?: IntFilter<"AttendanceLog"> | number
    actualClockIn?: DateTimeNullableFilter<"AttendanceLog"> | Date | string | null
    actualClockOut?: DateTimeNullableFilter<"AttendanceLog"> | Date | string | null
    status?: EnumAttendanceStatusFilter<"AttendanceLog"> | $Enums.AttendanceStatus
    createdAt?: DateTimeFilter<"AttendanceLog"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    session?: XOR<SessionDefinitionScalarRelationFilter, SessionDefinitionWhereInput>
  }, "id" | "employeeId_date_sessionId">

  export type AttendanceLogOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    sessionId?: SortOrder
    actualClockIn?: SortOrderInput | SortOrder
    actualClockOut?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: AttendanceLogCountOrderByAggregateInput
    _avg?: AttendanceLogAvgOrderByAggregateInput
    _max?: AttendanceLogMaxOrderByAggregateInput
    _min?: AttendanceLogMinOrderByAggregateInput
    _sum?: AttendanceLogSumOrderByAggregateInput
  }

  export type AttendanceLogScalarWhereWithAggregatesInput = {
    AND?: AttendanceLogScalarWhereWithAggregatesInput | AttendanceLogScalarWhereWithAggregatesInput[]
    OR?: AttendanceLogScalarWhereWithAggregatesInput[]
    NOT?: AttendanceLogScalarWhereWithAggregatesInput | AttendanceLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AttendanceLog"> | number
    employeeId?: IntWithAggregatesFilter<"AttendanceLog"> | number
    date?: DateTimeWithAggregatesFilter<"AttendanceLog"> | Date | string
    sessionId?: IntWithAggregatesFilter<"AttendanceLog"> | number
    actualClockIn?: DateTimeNullableWithAggregatesFilter<"AttendanceLog"> | Date | string | null
    actualClockOut?: DateTimeNullableWithAggregatesFilter<"AttendanceLog"> | Date | string | null
    status?: EnumAttendanceStatusWithAggregatesFilter<"AttendanceLog"> | $Enums.AttendanceStatus
    createdAt?: DateTimeWithAggregatesFilter<"AttendanceLog"> | Date | string
  }

  export type AttendanceSummaryWhereInput = {
    AND?: AttendanceSummaryWhereInput | AttendanceSummaryWhereInput[]
    OR?: AttendanceSummaryWhereInput[]
    NOT?: AttendanceSummaryWhereInput | AttendanceSummaryWhereInput[]
    id?: IntFilter<"AttendanceSummary"> | number
    employeeId?: IntFilter<"AttendanceSummary"> | number
    date?: DateTimeFilter<"AttendanceSummary"> | Date | string
    status?: EnumSummaryStatusFilter<"AttendanceSummary"> | $Enums.SummaryStatus
    lateArrival?: BoolFilter<"AttendanceSummary"> | boolean
    earlyDeparture?: BoolFilter<"AttendanceSummary"> | boolean
    unplannedAbsence?: BoolFilter<"AttendanceSummary"> | boolean
    totalWorkHours?: DecimalNullableFilter<"AttendanceSummary"> | Decimal | DecimalJsLike | number | string | null
    remarks?: StringNullableFilter<"AttendanceSummary"> | string | null
    departmentId?: IntNullableFilter<"AttendanceSummary"> | number | null
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
  }

  export type AttendanceSummaryOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    lateArrival?: SortOrder
    earlyDeparture?: SortOrder
    unplannedAbsence?: SortOrder
    totalWorkHours?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    employee?: EmployeeOrderByWithRelationInput
    department?: DepartmentOrderByWithRelationInput
    _relevance?: AttendanceSummaryOrderByRelevanceInput
  }

  export type AttendanceSummaryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    employeeId_date?: AttendanceSummaryEmployeeIdDateCompoundUniqueInput
    AND?: AttendanceSummaryWhereInput | AttendanceSummaryWhereInput[]
    OR?: AttendanceSummaryWhereInput[]
    NOT?: AttendanceSummaryWhereInput | AttendanceSummaryWhereInput[]
    employeeId?: IntFilter<"AttendanceSummary"> | number
    date?: DateTimeFilter<"AttendanceSummary"> | Date | string
    status?: EnumSummaryStatusFilter<"AttendanceSummary"> | $Enums.SummaryStatus
    lateArrival?: BoolFilter<"AttendanceSummary"> | boolean
    earlyDeparture?: BoolFilter<"AttendanceSummary"> | boolean
    unplannedAbsence?: BoolFilter<"AttendanceSummary"> | boolean
    totalWorkHours?: DecimalNullableFilter<"AttendanceSummary"> | Decimal | DecimalJsLike | number | string | null
    remarks?: StringNullableFilter<"AttendanceSummary"> | string | null
    departmentId?: IntNullableFilter<"AttendanceSummary"> | number | null
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
  }, "id" | "employeeId_date">

  export type AttendanceSummaryOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    lateArrival?: SortOrder
    earlyDeparture?: SortOrder
    unplannedAbsence?: SortOrder
    totalWorkHours?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    _count?: AttendanceSummaryCountOrderByAggregateInput
    _avg?: AttendanceSummaryAvgOrderByAggregateInput
    _max?: AttendanceSummaryMaxOrderByAggregateInput
    _min?: AttendanceSummaryMinOrderByAggregateInput
    _sum?: AttendanceSummarySumOrderByAggregateInput
  }

  export type AttendanceSummaryScalarWhereWithAggregatesInput = {
    AND?: AttendanceSummaryScalarWhereWithAggregatesInput | AttendanceSummaryScalarWhereWithAggregatesInput[]
    OR?: AttendanceSummaryScalarWhereWithAggregatesInput[]
    NOT?: AttendanceSummaryScalarWhereWithAggregatesInput | AttendanceSummaryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AttendanceSummary"> | number
    employeeId?: IntWithAggregatesFilter<"AttendanceSummary"> | number
    date?: DateTimeWithAggregatesFilter<"AttendanceSummary"> | Date | string
    status?: EnumSummaryStatusWithAggregatesFilter<"AttendanceSummary"> | $Enums.SummaryStatus
    lateArrival?: BoolWithAggregatesFilter<"AttendanceSummary"> | boolean
    earlyDeparture?: BoolWithAggregatesFilter<"AttendanceSummary"> | boolean
    unplannedAbsence?: BoolWithAggregatesFilter<"AttendanceSummary"> | boolean
    totalWorkHours?: DecimalNullableWithAggregatesFilter<"AttendanceSummary"> | Decimal | DecimalJsLike | number | string | null
    remarks?: StringNullableWithAggregatesFilter<"AttendanceSummary"> | string | null
    departmentId?: IntNullableWithAggregatesFilter<"AttendanceSummary"> | number | null
  }

  export type LeaveWhereInput = {
    AND?: LeaveWhereInput | LeaveWhereInput[]
    OR?: LeaveWhereInput[]
    NOT?: LeaveWhereInput | LeaveWhereInput[]
    id?: IntFilter<"Leave"> | number
    employeeId?: IntFilter<"Leave"> | number
    leaveType?: EnumLeaveTypeFilter<"Leave"> | $Enums.LeaveType
    startDate?: DateTimeFilter<"Leave"> | Date | string
    endDate?: DateTimeFilter<"Leave"> | Date | string
    status?: EnumLeaveStatusFilter<"Leave"> | $Enums.LeaveStatus
    reason?: StringNullableFilter<"Leave"> | string | null
    approvedBy?: IntNullableFilter<"Leave"> | number | null
    requestedAt?: DateTimeFilter<"Leave"> | Date | string
    updatedAt?: DateTimeFilter<"Leave"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type LeaveOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    reason?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    approver?: UserOrderByWithRelationInput
    _relevance?: LeaveOrderByRelevanceInput
  }

  export type LeaveWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LeaveWhereInput | LeaveWhereInput[]
    OR?: LeaveWhereInput[]
    NOT?: LeaveWhereInput | LeaveWhereInput[]
    employeeId?: IntFilter<"Leave"> | number
    leaveType?: EnumLeaveTypeFilter<"Leave"> | $Enums.LeaveType
    startDate?: DateTimeFilter<"Leave"> | Date | string
    endDate?: DateTimeFilter<"Leave"> | Date | string
    status?: EnumLeaveStatusFilter<"Leave"> | $Enums.LeaveStatus
    reason?: StringNullableFilter<"Leave"> | string | null
    approvedBy?: IntNullableFilter<"Leave"> | number | null
    requestedAt?: DateTimeFilter<"Leave"> | Date | string
    updatedAt?: DateTimeFilter<"Leave"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type LeaveOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    reason?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeaveCountOrderByAggregateInput
    _avg?: LeaveAvgOrderByAggregateInput
    _max?: LeaveMaxOrderByAggregateInput
    _min?: LeaveMinOrderByAggregateInput
    _sum?: LeaveSumOrderByAggregateInput
  }

  export type LeaveScalarWhereWithAggregatesInput = {
    AND?: LeaveScalarWhereWithAggregatesInput | LeaveScalarWhereWithAggregatesInput[]
    OR?: LeaveScalarWhereWithAggregatesInput[]
    NOT?: LeaveScalarWhereWithAggregatesInput | LeaveScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Leave"> | number
    employeeId?: IntWithAggregatesFilter<"Leave"> | number
    leaveType?: EnumLeaveTypeWithAggregatesFilter<"Leave"> | $Enums.LeaveType
    startDate?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
    status?: EnumLeaveStatusWithAggregatesFilter<"Leave"> | $Enums.LeaveStatus
    reason?: StringNullableWithAggregatesFilter<"Leave"> | string | null
    approvedBy?: IntNullableWithAggregatesFilter<"Leave"> | number | null
    requestedAt?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
  }

  export type HolidayWhereInput = {
    AND?: HolidayWhereInput | HolidayWhereInput[]
    OR?: HolidayWhereInput[]
    NOT?: HolidayWhereInput | HolidayWhereInput[]
    id?: IntFilter<"Holiday"> | number
    name?: StringFilter<"Holiday"> | string
    date?: DateTimeFilter<"Holiday"> | Date | string
    isPublic?: BoolFilter<"Holiday"> | boolean
    description?: StringNullableFilter<"Holiday"> | string | null
  }

  export type HolidayOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    isPublic?: SortOrder
    description?: SortOrderInput | SortOrder
    _relevance?: HolidayOrderByRelevanceInput
  }

  export type HolidayWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    date?: Date | string
    AND?: HolidayWhereInput | HolidayWhereInput[]
    OR?: HolidayWhereInput[]
    NOT?: HolidayWhereInput | HolidayWhereInput[]
    name?: StringFilter<"Holiday"> | string
    isPublic?: BoolFilter<"Holiday"> | boolean
    description?: StringNullableFilter<"Holiday"> | string | null
  }, "id" | "date">

  export type HolidayOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    isPublic?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: HolidayCountOrderByAggregateInput
    _avg?: HolidayAvgOrderByAggregateInput
    _max?: HolidayMaxOrderByAggregateInput
    _min?: HolidayMinOrderByAggregateInput
    _sum?: HolidaySumOrderByAggregateInput
  }

  export type HolidayScalarWhereWithAggregatesInput = {
    AND?: HolidayScalarWhereWithAggregatesInput | HolidayScalarWhereWithAggregatesInput[]
    OR?: HolidayScalarWhereWithAggregatesInput[]
    NOT?: HolidayScalarWhereWithAggregatesInput | HolidayScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Holiday"> | number
    name?: StringWithAggregatesFilter<"Holiday"> | string
    date?: DateTimeWithAggregatesFilter<"Holiday"> | Date | string
    isPublic?: BoolWithAggregatesFilter<"Holiday"> | boolean
    description?: StringNullableWithAggregatesFilter<"Holiday"> | string | null
  }

  export type OvertimeLogWhereInput = {
    AND?: OvertimeLogWhereInput | OvertimeLogWhereInput[]
    OR?: OvertimeLogWhereInput[]
    NOT?: OvertimeLogWhereInput | OvertimeLogWhereInput[]
    id?: IntFilter<"OvertimeLog"> | number
    employeeId?: IntFilter<"OvertimeLog"> | number
    date?: DateTimeFilter<"OvertimeLog"> | Date | string
    hours?: DecimalNullableFilter<"OvertimeLog"> | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFilter<"OvertimeLog"> | Date | string
    endTime?: DateTimeFilter<"OvertimeLog"> | Date | string
    reason?: StringNullableFilter<"OvertimeLog"> | string | null
    approvedBy?: IntNullableFilter<"OvertimeLog"> | number | null
    approvalStatus?: EnumOvertimeApprovalStatusFilter<"OvertimeLog"> | $Enums.OvertimeApprovalStatus
    compensationMethod?: EnumCompensationMethodFilter<"OvertimeLog"> | $Enums.CompensationMethod
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type OvertimeLogOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    hours?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    reason?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvalStatus?: SortOrder
    compensationMethod?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    approver?: UserOrderByWithRelationInput
    _relevance?: OvertimeLogOrderByRelevanceInput
  }

  export type OvertimeLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OvertimeLogWhereInput | OvertimeLogWhereInput[]
    OR?: OvertimeLogWhereInput[]
    NOT?: OvertimeLogWhereInput | OvertimeLogWhereInput[]
    employeeId?: IntFilter<"OvertimeLog"> | number
    date?: DateTimeFilter<"OvertimeLog"> | Date | string
    hours?: DecimalNullableFilter<"OvertimeLog"> | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFilter<"OvertimeLog"> | Date | string
    endTime?: DateTimeFilter<"OvertimeLog"> | Date | string
    reason?: StringNullableFilter<"OvertimeLog"> | string | null
    approvedBy?: IntNullableFilter<"OvertimeLog"> | number | null
    approvalStatus?: EnumOvertimeApprovalStatusFilter<"OvertimeLog"> | $Enums.OvertimeApprovalStatus
    compensationMethod?: EnumCompensationMethodFilter<"OvertimeLog"> | $Enums.CompensationMethod
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type OvertimeLogOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    hours?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    reason?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvalStatus?: SortOrder
    compensationMethod?: SortOrder
    _count?: OvertimeLogCountOrderByAggregateInput
    _avg?: OvertimeLogAvgOrderByAggregateInput
    _max?: OvertimeLogMaxOrderByAggregateInput
    _min?: OvertimeLogMinOrderByAggregateInput
    _sum?: OvertimeLogSumOrderByAggregateInput
  }

  export type OvertimeLogScalarWhereWithAggregatesInput = {
    AND?: OvertimeLogScalarWhereWithAggregatesInput | OvertimeLogScalarWhereWithAggregatesInput[]
    OR?: OvertimeLogScalarWhereWithAggregatesInput[]
    NOT?: OvertimeLogScalarWhereWithAggregatesInput | OvertimeLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OvertimeLog"> | number
    employeeId?: IntWithAggregatesFilter<"OvertimeLog"> | number
    date?: DateTimeWithAggregatesFilter<"OvertimeLog"> | Date | string
    hours?: DecimalNullableWithAggregatesFilter<"OvertimeLog"> | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeWithAggregatesFilter<"OvertimeLog"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"OvertimeLog"> | Date | string
    reason?: StringNullableWithAggregatesFilter<"OvertimeLog"> | string | null
    approvedBy?: IntNullableWithAggregatesFilter<"OvertimeLog"> | number | null
    approvalStatus?: EnumOvertimeApprovalStatusWithAggregatesFilter<"OvertimeLog"> | $Enums.OvertimeApprovalStatus
    compensationMethod?: EnumCompensationMethodWithAggregatesFilter<"OvertimeLog"> | $Enums.CompensationMethod
  }

  export type SalaryWhereInput = {
    AND?: SalaryWhereInput | SalaryWhereInput[]
    OR?: SalaryWhereInput[]
    NOT?: SalaryWhereInput | SalaryWhereInput[]
    id?: IntFilter<"Salary"> | number
    employeeId?: IntFilter<"Salary"> | number
    salaryMonth?: DateTimeFilter<"Salary"> | Date | string
    amount?: DecimalFilter<"Salary"> | Decimal | DecimalJsLike | number | string
    status?: EnumSalaryStatusFilter<"Salary"> | $Enums.SalaryStatus
    overtimeHours?: DecimalFilter<"Salary"> | Decimal | DecimalJsLike | number | string
    overtimePay?: DecimalFilter<"Salary"> | Decimal | DecimalJsLike | number | string
    paidAt?: DateTimeNullableFilter<"Salary"> | Date | string | null
    createdAt?: DateTimeFilter<"Salary"> | Date | string
    updatedAt?: DateTimeFilter<"Salary"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type SalaryOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    salaryMonth?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    overtimeHours?: SortOrder
    overtimePay?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type SalaryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    employeeId_salaryMonth?: SalaryEmployeeIdSalaryMonthCompoundUniqueInput
    AND?: SalaryWhereInput | SalaryWhereInput[]
    OR?: SalaryWhereInput[]
    NOT?: SalaryWhereInput | SalaryWhereInput[]
    employeeId?: IntFilter<"Salary"> | number
    salaryMonth?: DateTimeFilter<"Salary"> | Date | string
    amount?: DecimalFilter<"Salary"> | Decimal | DecimalJsLike | number | string
    status?: EnumSalaryStatusFilter<"Salary"> | $Enums.SalaryStatus
    overtimeHours?: DecimalFilter<"Salary"> | Decimal | DecimalJsLike | number | string
    overtimePay?: DecimalFilter<"Salary"> | Decimal | DecimalJsLike | number | string
    paidAt?: DateTimeNullableFilter<"Salary"> | Date | string | null
    createdAt?: DateTimeFilter<"Salary"> | Date | string
    updatedAt?: DateTimeFilter<"Salary"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id" | "employeeId_salaryMonth">

  export type SalaryOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    salaryMonth?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    overtimeHours?: SortOrder
    overtimePay?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SalaryCountOrderByAggregateInput
    _avg?: SalaryAvgOrderByAggregateInput
    _max?: SalaryMaxOrderByAggregateInput
    _min?: SalaryMinOrderByAggregateInput
    _sum?: SalarySumOrderByAggregateInput
  }

  export type SalaryScalarWhereWithAggregatesInput = {
    AND?: SalaryScalarWhereWithAggregatesInput | SalaryScalarWhereWithAggregatesInput[]
    OR?: SalaryScalarWhereWithAggregatesInput[]
    NOT?: SalaryScalarWhereWithAggregatesInput | SalaryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Salary"> | number
    employeeId?: IntWithAggregatesFilter<"Salary"> | number
    salaryMonth?: DateTimeWithAggregatesFilter<"Salary"> | Date | string
    amount?: DecimalWithAggregatesFilter<"Salary"> | Decimal | DecimalJsLike | number | string
    status?: EnumSalaryStatusWithAggregatesFilter<"Salary"> | $Enums.SalaryStatus
    overtimeHours?: DecimalWithAggregatesFilter<"Salary"> | Decimal | DecimalJsLike | number | string
    overtimePay?: DecimalWithAggregatesFilter<"Salary"> | Decimal | DecimalJsLike | number | string
    paidAt?: DateTimeNullableWithAggregatesFilter<"Salary"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Salary"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Salary"> | Date | string
  }

  export type ComplaintWhereInput = {
    AND?: ComplaintWhereInput | ComplaintWhereInput[]
    OR?: ComplaintWhereInput[]
    NOT?: ComplaintWhereInput | ComplaintWhereInput[]
    id?: IntFilter<"Complaint"> | number
    employeeId?: IntFilter<"Complaint"> | number
    subject?: StringFilter<"Complaint"> | string
    description?: StringFilter<"Complaint"> | string
    status?: EnumComplaintStatusFilter<"Complaint"> | $Enums.ComplaintStatus
    response?: StringNullableFilter<"Complaint"> | string | null
    createdAt?: DateTimeFilter<"Complaint"> | Date | string
    updatedAt?: DateTimeFilter<"Complaint"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type ComplaintOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    response?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    _relevance?: ComplaintOrderByRelevanceInput
  }

  export type ComplaintWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ComplaintWhereInput | ComplaintWhereInput[]
    OR?: ComplaintWhereInput[]
    NOT?: ComplaintWhereInput | ComplaintWhereInput[]
    employeeId?: IntFilter<"Complaint"> | number
    subject?: StringFilter<"Complaint"> | string
    description?: StringFilter<"Complaint"> | string
    status?: EnumComplaintStatusFilter<"Complaint"> | $Enums.ComplaintStatus
    response?: StringNullableFilter<"Complaint"> | string | null
    createdAt?: DateTimeFilter<"Complaint"> | Date | string
    updatedAt?: DateTimeFilter<"Complaint"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id">

  export type ComplaintOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    response?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ComplaintCountOrderByAggregateInput
    _avg?: ComplaintAvgOrderByAggregateInput
    _max?: ComplaintMaxOrderByAggregateInput
    _min?: ComplaintMinOrderByAggregateInput
    _sum?: ComplaintSumOrderByAggregateInput
  }

  export type ComplaintScalarWhereWithAggregatesInput = {
    AND?: ComplaintScalarWhereWithAggregatesInput | ComplaintScalarWhereWithAggregatesInput[]
    OR?: ComplaintScalarWhereWithAggregatesInput[]
    NOT?: ComplaintScalarWhereWithAggregatesInput | ComplaintScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Complaint"> | number
    employeeId?: IntWithAggregatesFilter<"Complaint"> | number
    subject?: StringWithAggregatesFilter<"Complaint"> | string
    description?: StringWithAggregatesFilter<"Complaint"> | string
    status?: EnumComplaintStatusWithAggregatesFilter<"Complaint"> | $Enums.ComplaintStatus
    response?: StringNullableWithAggregatesFilter<"Complaint"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Complaint"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Complaint"> | Date | string
  }

  export type InterviewWhereInput = {
    AND?: InterviewWhereInput | InterviewWhereInput[]
    OR?: InterviewWhereInput[]
    NOT?: InterviewWhereInput | InterviewWhereInput[]
    id?: IntFilter<"Interview"> | number
    candidateName?: StringFilter<"Interview"> | string
    position?: StringNullableFilter<"Interview"> | string | null
    interviewDate?: DateTimeNullableFilter<"Interview"> | Date | string | null
    result?: EnumInterviewResultFilter<"Interview"> | $Enums.InterviewResult
    comments?: StringNullableFilter<"Interview"> | string | null
    createdAt?: DateTimeFilter<"Interview"> | Date | string
    updatedAt?: DateTimeFilter<"Interview"> | Date | string
  }

  export type InterviewOrderByWithRelationInput = {
    id?: SortOrder
    candidateName?: SortOrder
    position?: SortOrderInput | SortOrder
    interviewDate?: SortOrderInput | SortOrder
    result?: SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: InterviewOrderByRelevanceInput
  }

  export type InterviewWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InterviewWhereInput | InterviewWhereInput[]
    OR?: InterviewWhereInput[]
    NOT?: InterviewWhereInput | InterviewWhereInput[]
    candidateName?: StringFilter<"Interview"> | string
    position?: StringNullableFilter<"Interview"> | string | null
    interviewDate?: DateTimeNullableFilter<"Interview"> | Date | string | null
    result?: EnumInterviewResultFilter<"Interview"> | $Enums.InterviewResult
    comments?: StringNullableFilter<"Interview"> | string | null
    createdAt?: DateTimeFilter<"Interview"> | Date | string
    updatedAt?: DateTimeFilter<"Interview"> | Date | string
  }, "id">

  export type InterviewOrderByWithAggregationInput = {
    id?: SortOrder
    candidateName?: SortOrder
    position?: SortOrderInput | SortOrder
    interviewDate?: SortOrderInput | SortOrder
    result?: SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InterviewCountOrderByAggregateInput
    _avg?: InterviewAvgOrderByAggregateInput
    _max?: InterviewMaxOrderByAggregateInput
    _min?: InterviewMinOrderByAggregateInput
    _sum?: InterviewSumOrderByAggregateInput
  }

  export type InterviewScalarWhereWithAggregatesInput = {
    AND?: InterviewScalarWhereWithAggregatesInput | InterviewScalarWhereWithAggregatesInput[]
    OR?: InterviewScalarWhereWithAggregatesInput[]
    NOT?: InterviewScalarWhereWithAggregatesInput | InterviewScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Interview"> | number
    candidateName?: StringWithAggregatesFilter<"Interview"> | string
    position?: StringNullableWithAggregatesFilter<"Interview"> | string | null
    interviewDate?: DateTimeNullableWithAggregatesFilter<"Interview"> | Date | string | null
    result?: EnumInterviewResultWithAggregatesFilter<"Interview"> | $Enums.InterviewResult
    comments?: StringNullableWithAggregatesFilter<"Interview"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Interview"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Interview"> | Date | string
  }

  export type PerformanceReviewWhereInput = {
    AND?: PerformanceReviewWhereInput | PerformanceReviewWhereInput[]
    OR?: PerformanceReviewWhereInput[]
    NOT?: PerformanceReviewWhereInput | PerformanceReviewWhereInput[]
    id?: IntFilter<"PerformanceReview"> | number
    employeeId?: IntFilter<"PerformanceReview"> | number
    reviewDate?: DateTimeFilter<"PerformanceReview"> | Date | string
    reviewerName?: StringNullableFilter<"PerformanceReview"> | string | null
    score?: IntNullableFilter<"PerformanceReview"> | number | null
    comments?: StringNullableFilter<"PerformanceReview"> | string | null
    createdAt?: DateTimeFilter<"PerformanceReview"> | Date | string
    updatedAt?: DateTimeFilter<"PerformanceReview"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type PerformanceReviewOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    reviewDate?: SortOrder
    reviewerName?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    _relevance?: PerformanceReviewOrderByRelevanceInput
  }

  export type PerformanceReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PerformanceReviewWhereInput | PerformanceReviewWhereInput[]
    OR?: PerformanceReviewWhereInput[]
    NOT?: PerformanceReviewWhereInput | PerformanceReviewWhereInput[]
    employeeId?: IntFilter<"PerformanceReview"> | number
    reviewDate?: DateTimeFilter<"PerformanceReview"> | Date | string
    reviewerName?: StringNullableFilter<"PerformanceReview"> | string | null
    score?: IntNullableFilter<"PerformanceReview"> | number | null
    comments?: StringNullableFilter<"PerformanceReview"> | string | null
    createdAt?: DateTimeFilter<"PerformanceReview"> | Date | string
    updatedAt?: DateTimeFilter<"PerformanceReview"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id">

  export type PerformanceReviewOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    reviewDate?: SortOrder
    reviewerName?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PerformanceReviewCountOrderByAggregateInput
    _avg?: PerformanceReviewAvgOrderByAggregateInput
    _max?: PerformanceReviewMaxOrderByAggregateInput
    _min?: PerformanceReviewMinOrderByAggregateInput
    _sum?: PerformanceReviewSumOrderByAggregateInput
  }

  export type PerformanceReviewScalarWhereWithAggregatesInput = {
    AND?: PerformanceReviewScalarWhereWithAggregatesInput | PerformanceReviewScalarWhereWithAggregatesInput[]
    OR?: PerformanceReviewScalarWhereWithAggregatesInput[]
    NOT?: PerformanceReviewScalarWhereWithAggregatesInput | PerformanceReviewScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PerformanceReview"> | number
    employeeId?: IntWithAggregatesFilter<"PerformanceReview"> | number
    reviewDate?: DateTimeWithAggregatesFilter<"PerformanceReview"> | Date | string
    reviewerName?: StringNullableWithAggregatesFilter<"PerformanceReview"> | string | null
    score?: IntNullableWithAggregatesFilter<"PerformanceReview"> | number | null
    comments?: StringNullableWithAggregatesFilter<"PerformanceReview"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PerformanceReview"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PerformanceReview"> | Date | string
  }

  export type TerminationWhereInput = {
    AND?: TerminationWhereInput | TerminationWhereInput[]
    OR?: TerminationWhereInput[]
    NOT?: TerminationWhereInput | TerminationWhereInput[]
    id?: IntFilter<"Termination"> | number
    employeeId?: IntFilter<"Termination"> | number
    terminationDate?: DateTimeFilter<"Termination"> | Date | string
    reason?: StringNullableFilter<"Termination"> | string | null
    status?: EnumTerminationStatusFilter<"Termination"> | $Enums.TerminationStatus
    workflowStatus?: EnumWorkflowStatusFilter<"Termination"> | $Enums.WorkflowStatus
    remarks?: StringNullableFilter<"Termination"> | string | null
    createdAt?: DateTimeFilter<"Termination"> | Date | string
    updatedAt?: DateTimeFilter<"Termination"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type TerminationOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    terminationDate?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    workflowStatus?: SortOrder
    remarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    _relevance?: TerminationOrderByRelevanceInput
  }

  export type TerminationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TerminationWhereInput | TerminationWhereInput[]
    OR?: TerminationWhereInput[]
    NOT?: TerminationWhereInput | TerminationWhereInput[]
    employeeId?: IntFilter<"Termination"> | number
    terminationDate?: DateTimeFilter<"Termination"> | Date | string
    reason?: StringNullableFilter<"Termination"> | string | null
    status?: EnumTerminationStatusFilter<"Termination"> | $Enums.TerminationStatus
    workflowStatus?: EnumWorkflowStatusFilter<"Termination"> | $Enums.WorkflowStatus
    remarks?: StringNullableFilter<"Termination"> | string | null
    createdAt?: DateTimeFilter<"Termination"> | Date | string
    updatedAt?: DateTimeFilter<"Termination"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id">

  export type TerminationOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    terminationDate?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    workflowStatus?: SortOrder
    remarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TerminationCountOrderByAggregateInput
    _avg?: TerminationAvgOrderByAggregateInput
    _max?: TerminationMaxOrderByAggregateInput
    _min?: TerminationMinOrderByAggregateInput
    _sum?: TerminationSumOrderByAggregateInput
  }

  export type TerminationScalarWhereWithAggregatesInput = {
    AND?: TerminationScalarWhereWithAggregatesInput | TerminationScalarWhereWithAggregatesInput[]
    OR?: TerminationScalarWhereWithAggregatesInput[]
    NOT?: TerminationScalarWhereWithAggregatesInput | TerminationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Termination"> | number
    employeeId?: IntWithAggregatesFilter<"Termination"> | number
    terminationDate?: DateTimeWithAggregatesFilter<"Termination"> | Date | string
    reason?: StringNullableWithAggregatesFilter<"Termination"> | string | null
    status?: EnumTerminationStatusWithAggregatesFilter<"Termination"> | $Enums.TerminationStatus
    workflowStatus?: EnumWorkflowStatusWithAggregatesFilter<"Termination"> | $Enums.WorkflowStatus
    remarks?: StringNullableWithAggregatesFilter<"Termination"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Termination"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Termination"> | Date | string
  }

  export type RoleCreateInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notifyOnComplaint?: boolean
    roles?: UserRoleCreateNestedManyWithoutUserInput
    employees?: EmployeeCreateNestedManyWithoutUserInput
    approvedLeaves?: LeaveCreateNestedManyWithoutApproverInput
    approvedOvertimes?: OvertimeLogCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notifyOnComplaint?: boolean
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutUserInput
    approvedLeaves?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    approvedOvertimes?: OvertimeLogUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifyOnComplaint?: BoolFieldUpdateOperationsInput | boolean
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    employees?: EmployeeUpdateManyWithoutUserNestedInput
    approvedLeaves?: LeaveUpdateManyWithoutApproverNestedInput
    approvedOvertimes?: OvertimeLogUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifyOnComplaint?: BoolFieldUpdateOperationsInput | boolean
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutUserNestedInput
    approvedLeaves?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    approvedOvertimes?: OvertimeLogUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notifyOnComplaint?: boolean
  }

  export type UserUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifyOnComplaint?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifyOnComplaint?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserRoleCreateInput = {
    user: UserCreateNestedOneWithoutRolesInput
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserRoleUncheckedCreateInput = {
    userId: number
    roleId: number
  }

  export type UserRoleUpdateInput = {
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type UserRoleCreateManyInput = {
    userId: number
    roleId: number
  }

  export type UserRoleUpdateManyMutationInput = {

  }

  export type UserRoleUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type DepartmentCreateInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: DepartmentCreateNestedOneWithoutSubDepartmentsInput
    subDepartments?: DepartmentCreateNestedManyWithoutParentInput
    employees?: EmployeeCreateNestedManyWithoutDepartmentInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subDepartments?: DepartmentUncheckedCreateNestedManyWithoutParentInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutDepartmentInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: DepartmentUpdateOneWithoutSubDepartmentsNestedInput
    subDepartments?: DepartmentUpdateManyWithoutParentNestedInput
    employees?: EmployeeUpdateManyWithoutDepartmentNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subDepartments?: DepartmentUncheckedUpdateManyWithoutParentNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionCreateInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeCreateNestedManyWithoutPositionInput
  }

  export type PositionUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutPositionInput
  }

  export type PositionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUpdateManyWithoutPositionNestedInput
  }

  export type PositionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type PositionCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PositionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaritalStatusCreateInput = {
    status: string
    employees?: EmployeeCreateNestedManyWithoutMaritalStatusInput
  }

  export type MaritalStatusUncheckedCreateInput = {
    id?: number
    status: string
    employees?: EmployeeUncheckedCreateNestedManyWithoutMaritalStatusInput
  }

  export type MaritalStatusUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
    employees?: EmployeeUpdateManyWithoutMaritalStatusNestedInput
  }

  export type MaritalStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    employees?: EmployeeUncheckedUpdateManyWithoutMaritalStatusNestedInput
  }

  export type MaritalStatusCreateManyInput = {
    id?: number
    status: string
  }

  export type MaritalStatusUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
  }

  export type MaritalStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type EmploymentTypeCreateInput = {
    type: string
    employees?: EmployeeCreateNestedManyWithoutEmploymentTypeInput
  }

  export type EmploymentTypeUncheckedCreateInput = {
    id?: number
    type: string
    employees?: EmployeeUncheckedCreateNestedManyWithoutEmploymentTypeInput
  }

  export type EmploymentTypeUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    employees?: EmployeeUpdateManyWithoutEmploymentTypeNestedInput
  }

  export type EmploymentTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    employees?: EmployeeUncheckedUpdateManyWithoutEmploymentTypeNestedInput
  }

  export type EmploymentTypeCreateManyInput = {
    id?: number
    type: string
  }

  export type EmploymentTypeUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
  }

  export type EmploymentTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type JobStatusCreateInput = {
    status: string
    employees?: EmployeeCreateNestedManyWithoutJobStatusInput
  }

  export type JobStatusUncheckedCreateInput = {
    id?: number
    status: string
    employees?: EmployeeUncheckedCreateNestedManyWithoutJobStatusInput
  }

  export type JobStatusUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
    employees?: EmployeeUpdateManyWithoutJobStatusNestedInput
  }

  export type JobStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    employees?: EmployeeUncheckedUpdateManyWithoutJobStatusNestedInput
  }

  export type JobStatusCreateManyInput = {
    id?: number
    status: string
  }

  export type JobStatusUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
  }

  export type JobStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type AgreementStatusCreateInput = {
    status: string
    employees?: EmployeeCreateNestedManyWithoutAgreementStatusInput
  }

  export type AgreementStatusUncheckedCreateInput = {
    id?: number
    status: string
    employees?: EmployeeUncheckedCreateNestedManyWithoutAgreementStatusInput
  }

  export type AgreementStatusUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
    employees?: EmployeeUpdateManyWithoutAgreementStatusNestedInput
  }

  export type AgreementStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    employees?: EmployeeUncheckedUpdateManyWithoutAgreementStatusNestedInput
  }

  export type AgreementStatusCreateManyInput = {
    id?: number
    status: string
  }

  export type AgreementStatusUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
  }

  export type AgreementStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type MeetingCreateInput = {
    title: string
    description?: string | null
    date: string
    time: string
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: EmployeeCreateNestedOneWithoutCreatedMeetingsInput
  }

  export type MeetingUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    date: string
    time: string
    creatorId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeetingUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: EmployeeUpdateOneWithoutCreatedMeetingsNestedInput
  }

  export type MeetingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    date: string
    time: string
    creatorId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeetingUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    subDepartmentId?: number | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    maritalStatus?: MaritalStatusCreateNestedOneWithoutEmployeesInput
    employmentType?: EmploymentTypeCreateNestedOneWithoutEmployeesInput
    jobStatus?: JobStatusCreateNestedOneWithoutEmployeesInput
    agreementStatus?: AgreementStatusCreateNestedOneWithoutEmployeesInput
    createdMeetings?: MeetingCreateNestedManyWithoutCreatorInput
    shifts?: EmployeeShiftCreateNestedManyWithoutEmployeeInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    subDepartmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdMeetings?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    shifts?: EmployeeShiftUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationUncheckedCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryUncheckedCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    maritalStatus?: MaritalStatusUpdateOneWithoutEmployeesNestedInput
    employmentType?: EmploymentTypeUpdateOneWithoutEmployeesNestedInput
    jobStatus?: JobStatusUpdateOneWithoutEmployeesNestedInput
    agreementStatus?: AgreementStatusUpdateOneWithoutEmployeesNestedInput
    createdMeetings?: MeetingUpdateManyWithoutCreatorNestedInput
    shifts?: EmployeeShiftUpdateManyWithoutEmployeeNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdMeetings?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    shifts?: EmployeeShiftUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUncheckedUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateManyInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    subDepartmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftCreateInput = {
    name: string
    startTime: Date | string
    endTime: Date | string
    isFlexible?: boolean
    description?: string | null
    assignments?: EmployeeShiftCreateNestedManyWithoutShiftInput
  }

  export type ShiftUncheckedCreateInput = {
    id?: number
    name: string
    startTime: Date | string
    endTime: Date | string
    isFlexible?: boolean
    description?: string | null
    assignments?: EmployeeShiftUncheckedCreateNestedManyWithoutShiftInput
  }

  export type ShiftUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isFlexible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignments?: EmployeeShiftUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isFlexible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assignments?: EmployeeShiftUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type ShiftCreateManyInput = {
    id?: number
    name: string
    startTime: Date | string
    endTime: Date | string
    isFlexible?: boolean
    description?: string | null
  }

  export type ShiftUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isFlexible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShiftUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isFlexible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeShiftCreateInput = {
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    employee: EmployeeCreateNestedOneWithoutShiftsInput
    shift: ShiftCreateNestedOneWithoutAssignmentsInput
  }

  export type EmployeeShiftUncheckedCreateInput = {
    id?: number
    employeeId: number
    shiftId: number
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
  }

  export type EmployeeShiftUpdateInput = {
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: EmployeeUpdateOneRequiredWithoutShiftsNestedInput
    shift?: ShiftUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type EmployeeShiftUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    shiftId?: IntFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeShiftCreateManyInput = {
    id?: number
    employeeId: number
    shiftId: number
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
  }

  export type EmployeeShiftUpdateManyMutationInput = {
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeShiftUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    shiftId?: IntFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionDefinitionCreateInput = {
    sessionNumber: number
    expectedClockIn: Date | string
    expectedClockOut: Date | string
    logs?: AttendanceLogCreateNestedManyWithoutSessionInput
  }

  export type SessionDefinitionUncheckedCreateInput = {
    id?: number
    sessionNumber: number
    expectedClockIn: Date | string
    expectedClockOut: Date | string
    logs?: AttendanceLogUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionDefinitionUpdateInput = {
    sessionNumber?: IntFieldUpdateOperationsInput | number
    expectedClockIn?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedClockOut?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: AttendanceLogUpdateManyWithoutSessionNestedInput
  }

  export type SessionDefinitionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionNumber?: IntFieldUpdateOperationsInput | number
    expectedClockIn?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedClockOut?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: AttendanceLogUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SessionDefinitionCreateManyInput = {
    id?: number
    sessionNumber: number
    expectedClockIn: Date | string
    expectedClockOut: Date | string
  }

  export type SessionDefinitionUpdateManyMutationInput = {
    sessionNumber?: IntFieldUpdateOperationsInput | number
    expectedClockIn?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedClockOut?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionDefinitionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionNumber?: IntFieldUpdateOperationsInput | number
    expectedClockIn?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedClockOut?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceLogCreateInput = {
    date: Date | string
    actualClockIn?: Date | string | null
    actualClockOut?: Date | string | null
    status: $Enums.AttendanceStatus
    createdAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutAttendanceLogsInput
    session: SessionDefinitionCreateNestedOneWithoutLogsInput
  }

  export type AttendanceLogUncheckedCreateInput = {
    id?: number
    employeeId: number
    date: Date | string
    sessionId: number
    actualClockIn?: Date | string | null
    actualClockOut?: Date | string | null
    status: $Enums.AttendanceStatus
    createdAt?: Date | string
  }

  export type AttendanceLogUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    actualClockIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutAttendanceLogsNestedInput
    session?: SessionDefinitionUpdateOneRequiredWithoutLogsNestedInput
  }

  export type AttendanceLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: IntFieldUpdateOperationsInput | number
    actualClockIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceLogCreateManyInput = {
    id?: number
    employeeId: number
    date: Date | string
    sessionId: number
    actualClockIn?: Date | string | null
    actualClockOut?: Date | string | null
    status: $Enums.AttendanceStatus
    createdAt?: Date | string
  }

  export type AttendanceLogUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    actualClockIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: IntFieldUpdateOperationsInput | number
    actualClockIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceSummaryCreateInput = {
    date: Date | string
    status: $Enums.SummaryStatus
    lateArrival?: boolean
    earlyDeparture?: boolean
    unplannedAbsence?: boolean
    totalWorkHours?: Decimal | DecimalJsLike | number | string | null
    remarks?: string | null
    employee: EmployeeCreateNestedOneWithoutAttendanceSummariesInput
    department?: DepartmentCreateNestedOneWithoutAttendanceSummariesInput
  }

  export type AttendanceSummaryUncheckedCreateInput = {
    id?: number
    employeeId: number
    date: Date | string
    status: $Enums.SummaryStatus
    lateArrival?: boolean
    earlyDeparture?: boolean
    unplannedAbsence?: boolean
    totalWorkHours?: Decimal | DecimalJsLike | number | string | null
    remarks?: string | null
    departmentId?: number | null
  }

  export type AttendanceSummaryUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSummaryStatusFieldUpdateOperationsInput | $Enums.SummaryStatus
    lateArrival?: BoolFieldUpdateOperationsInput | boolean
    earlyDeparture?: BoolFieldUpdateOperationsInput | boolean
    unplannedAbsence?: BoolFieldUpdateOperationsInput | boolean
    totalWorkHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUpdateOneRequiredWithoutAttendanceSummariesNestedInput
    department?: DepartmentUpdateOneWithoutAttendanceSummariesNestedInput
  }

  export type AttendanceSummaryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSummaryStatusFieldUpdateOperationsInput | $Enums.SummaryStatus
    lateArrival?: BoolFieldUpdateOperationsInput | boolean
    earlyDeparture?: BoolFieldUpdateOperationsInput | boolean
    unplannedAbsence?: BoolFieldUpdateOperationsInput | boolean
    totalWorkHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AttendanceSummaryCreateManyInput = {
    id?: number
    employeeId: number
    date: Date | string
    status: $Enums.SummaryStatus
    lateArrival?: boolean
    earlyDeparture?: boolean
    unplannedAbsence?: boolean
    totalWorkHours?: Decimal | DecimalJsLike | number | string | null
    remarks?: string | null
    departmentId?: number | null
  }

  export type AttendanceSummaryUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSummaryStatusFieldUpdateOperationsInput | $Enums.SummaryStatus
    lateArrival?: BoolFieldUpdateOperationsInput | boolean
    earlyDeparture?: BoolFieldUpdateOperationsInput | boolean
    unplannedAbsence?: BoolFieldUpdateOperationsInput | boolean
    totalWorkHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceSummaryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSummaryStatusFieldUpdateOperationsInput | $Enums.SummaryStatus
    lateArrival?: BoolFieldUpdateOperationsInput | boolean
    earlyDeparture?: BoolFieldUpdateOperationsInput | boolean
    unplannedAbsence?: BoolFieldUpdateOperationsInput | boolean
    totalWorkHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LeaveCreateInput = {
    leaveType: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.LeaveStatus
    reason?: string | null
    requestedAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutLeavesInput
    approver?: UserCreateNestedOneWithoutApprovedLeavesInput
  }

  export type LeaveUncheckedCreateInput = {
    id?: number
    employeeId: number
    leaveType: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.LeaveStatus
    reason?: string | null
    approvedBy?: number | null
    requestedAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveUpdateInput = {
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutLeavesNestedInput
    approver?: UserUpdateOneWithoutApprovedLeavesNestedInput
  }

  export type LeaveUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveCreateManyInput = {
    id?: number
    employeeId: number
    leaveType: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.LeaveStatus
    reason?: string | null
    approvedBy?: number | null
    requestedAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveUpdateManyMutationInput = {
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HolidayCreateInput = {
    name: string
    date: Date | string
    isPublic?: boolean
    description?: string | null
  }

  export type HolidayUncheckedCreateInput = {
    id?: number
    name: string
    date: Date | string
    isPublic?: boolean
    description?: string | null
  }

  export type HolidayUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HolidayUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HolidayCreateManyInput = {
    id?: number
    name: string
    date: Date | string
    isPublic?: boolean
    description?: string | null
  }

  export type HolidayUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HolidayUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OvertimeLogCreateInput = {
    date: Date | string
    hours?: Decimal | DecimalJsLike | number | string | null
    startTime: Date | string
    endTime: Date | string
    reason?: string | null
    approvalStatus?: $Enums.OvertimeApprovalStatus
    compensationMethod?: $Enums.CompensationMethod
    employee: EmployeeCreateNestedOneWithoutOvertimesInput
    approver?: UserCreateNestedOneWithoutApprovedOvertimesInput
  }

  export type OvertimeLogUncheckedCreateInput = {
    id?: number
    employeeId: number
    date: Date | string
    hours?: Decimal | DecimalJsLike | number | string | null
    startTime: Date | string
    endTime: Date | string
    reason?: string | null
    approvedBy?: number | null
    approvalStatus?: $Enums.OvertimeApprovalStatus
    compensationMethod?: $Enums.CompensationMethod
  }

  export type OvertimeLogUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumOvertimeApprovalStatusFieldUpdateOperationsInput | $Enums.OvertimeApprovalStatus
    compensationMethod?: EnumCompensationMethodFieldUpdateOperationsInput | $Enums.CompensationMethod
    employee?: EmployeeUpdateOneRequiredWithoutOvertimesNestedInput
    approver?: UserUpdateOneWithoutApprovedOvertimesNestedInput
  }

  export type OvertimeLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvalStatus?: EnumOvertimeApprovalStatusFieldUpdateOperationsInput | $Enums.OvertimeApprovalStatus
    compensationMethod?: EnumCompensationMethodFieldUpdateOperationsInput | $Enums.CompensationMethod
  }

  export type OvertimeLogCreateManyInput = {
    id?: number
    employeeId: number
    date: Date | string
    hours?: Decimal | DecimalJsLike | number | string | null
    startTime: Date | string
    endTime: Date | string
    reason?: string | null
    approvedBy?: number | null
    approvalStatus?: $Enums.OvertimeApprovalStatus
    compensationMethod?: $Enums.CompensationMethod
  }

  export type OvertimeLogUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumOvertimeApprovalStatusFieldUpdateOperationsInput | $Enums.OvertimeApprovalStatus
    compensationMethod?: EnumCompensationMethodFieldUpdateOperationsInput | $Enums.CompensationMethod
  }

  export type OvertimeLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvalStatus?: EnumOvertimeApprovalStatusFieldUpdateOperationsInput | $Enums.OvertimeApprovalStatus
    compensationMethod?: EnumCompensationMethodFieldUpdateOperationsInput | $Enums.CompensationMethod
  }

  export type SalaryCreateInput = {
    salaryMonth: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.SalaryStatus
    overtimeHours?: Decimal | DecimalJsLike | number | string
    overtimePay?: Decimal | DecimalJsLike | number | string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutSalariesInput
  }

  export type SalaryUncheckedCreateInput = {
    id?: number
    employeeId: number
    salaryMonth: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.SalaryStatus
    overtimeHours?: Decimal | DecimalJsLike | number | string
    overtimePay?: Decimal | DecimalJsLike | number | string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalaryUpdateInput = {
    salaryMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumSalaryStatusFieldUpdateOperationsInput | $Enums.SalaryStatus
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimePay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutSalariesNestedInput
  }

  export type SalaryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    salaryMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumSalaryStatusFieldUpdateOperationsInput | $Enums.SalaryStatus
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimePay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryCreateManyInput = {
    id?: number
    employeeId: number
    salaryMonth: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.SalaryStatus
    overtimeHours?: Decimal | DecimalJsLike | number | string
    overtimePay?: Decimal | DecimalJsLike | number | string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalaryUpdateManyMutationInput = {
    salaryMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumSalaryStatusFieldUpdateOperationsInput | $Enums.SalaryStatus
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimePay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    salaryMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumSalaryStatusFieldUpdateOperationsInput | $Enums.SalaryStatus
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimePay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCreateInput = {
    subject: string
    description: string
    status?: $Enums.ComplaintStatus
    response?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutComplaintsInput
  }

  export type ComplaintUncheckedCreateInput = {
    id?: number
    employeeId: number
    subject: string
    description: string
    status?: $Enums.ComplaintStatus
    response?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintUpdateInput = {
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutComplaintsNestedInput
  }

  export type ComplaintUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCreateManyInput = {
    id?: number
    employeeId: number
    subject: string
    description: string
    status?: $Enums.ComplaintStatus
    response?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintUpdateManyMutationInput = {
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewCreateInput = {
    candidateName: string
    position?: string | null
    interviewDate?: Date | string | null
    result?: $Enums.InterviewResult
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterviewUncheckedCreateInput = {
    id?: number
    candidateName: string
    position?: string | null
    interviewDate?: Date | string | null
    result?: $Enums.InterviewResult
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterviewUpdateInput = {
    candidateName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    interviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: EnumInterviewResultFieldUpdateOperationsInput | $Enums.InterviewResult
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    candidateName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    interviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: EnumInterviewResultFieldUpdateOperationsInput | $Enums.InterviewResult
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewCreateManyInput = {
    id?: number
    candidateName: string
    position?: string | null
    interviewDate?: Date | string | null
    result?: $Enums.InterviewResult
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InterviewUpdateManyMutationInput = {
    candidateName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    interviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: EnumInterviewResultFieldUpdateOperationsInput | $Enums.InterviewResult
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    candidateName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    interviewDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    result?: EnumInterviewResultFieldUpdateOperationsInput | $Enums.InterviewResult
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceReviewCreateInput = {
    reviewDate: Date | string
    reviewerName?: string | null
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutPerformanceReviewsInput
  }

  export type PerformanceReviewUncheckedCreateInput = {
    id?: number
    employeeId: number
    reviewDate: Date | string
    reviewerName?: string | null
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceReviewUpdateInput = {
    reviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewerName?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutPerformanceReviewsNestedInput
  }

  export type PerformanceReviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    reviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewerName?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceReviewCreateManyInput = {
    id?: number
    employeeId: number
    reviewDate: Date | string
    reviewerName?: string | null
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceReviewUpdateManyMutationInput = {
    reviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewerName?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceReviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    reviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewerName?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TerminationCreateInput = {
    terminationDate: Date | string
    reason?: string | null
    status: $Enums.TerminationStatus
    workflowStatus?: $Enums.WorkflowStatus
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutTerminationsInput
  }

  export type TerminationUncheckedCreateInput = {
    id?: number
    employeeId: number
    terminationDate: Date | string
    reason?: string | null
    status: $Enums.TerminationStatus
    workflowStatus?: $Enums.WorkflowStatus
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TerminationUpdateInput = {
    terminationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTerminationStatusFieldUpdateOperationsInput | $Enums.TerminationStatus
    workflowStatus?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutTerminationsNestedInput
  }

  export type TerminationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    terminationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTerminationStatusFieldUpdateOperationsInput | $Enums.TerminationStatus
    workflowStatus?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TerminationCreateManyInput = {
    id?: number
    employeeId: number
    terminationDate: Date | string
    reason?: string | null
    status: $Enums.TerminationStatus
    workflowStatus?: $Enums.WorkflowStatus
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TerminationUpdateManyMutationInput = {
    terminationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTerminationStatusFieldUpdateOperationsInput | $Enums.TerminationStatus
    workflowStatus?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TerminationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    terminationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTerminationStatusFieldUpdateOperationsInput | $Enums.TerminationStatus
    workflowStatus?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleOrderByRelevanceInput = {
    fields: RoleOrderByRelevanceFieldEnum | RoleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EmployeeListRelationFilter = {
    every?: EmployeeWhereInput
    some?: EmployeeWhereInput
    none?: EmployeeWhereInput
  }

  export type LeaveListRelationFilter = {
    every?: LeaveWhereInput
    some?: LeaveWhereInput
    none?: LeaveWhereInput
  }

  export type OvertimeLogListRelationFilter = {
    every?: OvertimeLogWhereInput
    some?: OvertimeLogWhereInput
    none?: OvertimeLogWhereInput
  }

  export type EmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OvertimeLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notifyOnComplaint?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notifyOnComplaint?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notifyOnComplaint?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type UserRoleUserIdRoleIdCompoundUniqueInput = {
    userId: number
    roleId: number
  }

  export type UserRoleCountOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRoleAvgOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRoleSumOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DepartmentNullableScalarRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type DepartmentListRelationFilter = {
    every?: DepartmentWhereInput
    some?: DepartmentWhereInput
    none?: DepartmentWhereInput
  }

  export type AttendanceSummaryListRelationFilter = {
    every?: AttendanceSummaryWhereInput
    some?: AttendanceSummaryWhereInput
    none?: AttendanceSummaryWhereInput
  }

  export type DepartmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceSummaryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentOrderByRelevanceInput = {
    fields: DepartmentOrderByRelevanceFieldEnum | DepartmentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentAvgOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentSumOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type PositionOrderByRelevanceInput = {
    fields: PositionOrderByRelevanceFieldEnum | PositionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PositionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PositionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PositionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PositionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PositionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MaritalStatusOrderByRelevanceInput = {
    fields: MaritalStatusOrderByRelevanceFieldEnum | MaritalStatusOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MaritalStatusCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type MaritalStatusAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MaritalStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type MaritalStatusMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type MaritalStatusSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmploymentTypeOrderByRelevanceInput = {
    fields: EmploymentTypeOrderByRelevanceFieldEnum | EmploymentTypeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EmploymentTypeCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type EmploymentTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmploymentTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type EmploymentTypeMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
  }

  export type EmploymentTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type JobStatusOrderByRelevanceInput = {
    fields: JobStatusOrderByRelevanceFieldEnum | JobStatusOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type JobStatusCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type JobStatusAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type JobStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type JobStatusMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type JobStatusSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AgreementStatusOrderByRelevanceInput = {
    fields: AgreementStatusOrderByRelevanceFieldEnum | AgreementStatusOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AgreementStatusCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type AgreementStatusAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AgreementStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type AgreementStatusMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type AgreementStatusSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmployeeNullableScalarRelationFilter = {
    is?: EmployeeWhereInput | null
    isNot?: EmployeeWhereInput | null
  }

  export type MeetingOrderByRelevanceInput = {
    fields: MeetingOrderByRelevanceFieldEnum | MeetingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MeetingCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    time?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MeetingAvgOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
  }

  export type MeetingMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    time?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MeetingMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    time?: SortOrder
    creatorId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MeetingSumOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumSexFilter<$PrismaModel = never> = {
    equals?: $Enums.Sex | EnumSexFieldRefInput<$PrismaModel>
    in?: $Enums.Sex[]
    notIn?: $Enums.Sex[]
    not?: NestedEnumSexFilter<$PrismaModel> | $Enums.Sex
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type PositionNullableScalarRelationFilter = {
    is?: PositionWhereInput | null
    isNot?: PositionWhereInput | null
  }

  export type MaritalStatusNullableScalarRelationFilter = {
    is?: MaritalStatusWhereInput | null
    isNot?: MaritalStatusWhereInput | null
  }

  export type EmploymentTypeNullableScalarRelationFilter = {
    is?: EmploymentTypeWhereInput | null
    isNot?: EmploymentTypeWhereInput | null
  }

  export type JobStatusNullableScalarRelationFilter = {
    is?: JobStatusWhereInput | null
    isNot?: JobStatusWhereInput | null
  }

  export type AgreementStatusNullableScalarRelationFilter = {
    is?: AgreementStatusWhereInput | null
    isNot?: AgreementStatusWhereInput | null
  }

  export type MeetingListRelationFilter = {
    every?: MeetingWhereInput
    some?: MeetingWhereInput
    none?: MeetingWhereInput
  }

  export type EmployeeShiftListRelationFilter = {
    every?: EmployeeShiftWhereInput
    some?: EmployeeShiftWhereInput
    none?: EmployeeShiftWhereInput
  }

  export type AttendanceLogListRelationFilter = {
    every?: AttendanceLogWhereInput
    some?: AttendanceLogWhereInput
    none?: AttendanceLogWhereInput
  }

  export type ComplaintListRelationFilter = {
    every?: ComplaintWhereInput
    some?: ComplaintWhereInput
    none?: ComplaintWhereInput
  }

  export type PerformanceReviewListRelationFilter = {
    every?: PerformanceReviewWhereInput
    some?: PerformanceReviewWhereInput
    none?: PerformanceReviewWhereInput
  }

  export type TerminationListRelationFilter = {
    every?: TerminationWhereInput
    some?: TerminationWhereInput
    none?: TerminationWhereInput
  }

  export type SalaryListRelationFilter = {
    every?: SalaryWhereInput
    some?: SalaryWhereInput
    none?: SalaryWhereInput
  }

  export type MeetingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeShiftOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComplaintOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PerformanceReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TerminationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalaryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeOrderByRelevanceInput = {
    fields: EmployeeOrderByRelevanceFieldEnum | EmployeeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    baptismalName?: SortOrder
    dateOfBirth?: SortOrder
    sex?: SortOrder
    nationality?: SortOrder
    maritalStatusId?: SortOrder
    departmentId?: SortOrder
    subDepartmentId?: SortOrder
    positionId?: SortOrder
    employmentTypeId?: SortOrder
    employmentDate?: SortOrder
    jobStatusId?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    subCity?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    repentanceFatherName?: SortOrder
    repentanceFatherChurch?: SortOrder
    repentanceFatherPhone?: SortOrder
    academicQualification?: SortOrder
    educationalInstitution?: SortOrder
    salary?: SortOrder
    bonusSalary?: SortOrder
    accountNumber?: SortOrder
    agreementStatusId?: SortOrder
    photo?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    maritalStatusId?: SortOrder
    departmentId?: SortOrder
    subDepartmentId?: SortOrder
    positionId?: SortOrder
    employmentTypeId?: SortOrder
    jobStatusId?: SortOrder
    salary?: SortOrder
    bonusSalary?: SortOrder
    agreementStatusId?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    baptismalName?: SortOrder
    dateOfBirth?: SortOrder
    sex?: SortOrder
    nationality?: SortOrder
    maritalStatusId?: SortOrder
    departmentId?: SortOrder
    subDepartmentId?: SortOrder
    positionId?: SortOrder
    employmentTypeId?: SortOrder
    employmentDate?: SortOrder
    jobStatusId?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    subCity?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    repentanceFatherName?: SortOrder
    repentanceFatherChurch?: SortOrder
    repentanceFatherPhone?: SortOrder
    academicQualification?: SortOrder
    educationalInstitution?: SortOrder
    salary?: SortOrder
    bonusSalary?: SortOrder
    accountNumber?: SortOrder
    agreementStatusId?: SortOrder
    photo?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    baptismalName?: SortOrder
    dateOfBirth?: SortOrder
    sex?: SortOrder
    nationality?: SortOrder
    maritalStatusId?: SortOrder
    departmentId?: SortOrder
    subDepartmentId?: SortOrder
    positionId?: SortOrder
    employmentTypeId?: SortOrder
    employmentDate?: SortOrder
    jobStatusId?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    subCity?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    repentanceFatherName?: SortOrder
    repentanceFatherChurch?: SortOrder
    repentanceFatherPhone?: SortOrder
    academicQualification?: SortOrder
    educationalInstitution?: SortOrder
    salary?: SortOrder
    bonusSalary?: SortOrder
    accountNumber?: SortOrder
    agreementStatusId?: SortOrder
    photo?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    maritalStatusId?: SortOrder
    departmentId?: SortOrder
    subDepartmentId?: SortOrder
    positionId?: SortOrder
    employmentTypeId?: SortOrder
    jobStatusId?: SortOrder
    salary?: SortOrder
    bonusSalary?: SortOrder
    agreementStatusId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumSexWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sex | EnumSexFieldRefInput<$PrismaModel>
    in?: $Enums.Sex[]
    notIn?: $Enums.Sex[]
    not?: NestedEnumSexWithAggregatesFilter<$PrismaModel> | $Enums.Sex
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSexFilter<$PrismaModel>
    _max?: NestedEnumSexFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type ShiftOrderByRelevanceInput = {
    fields: ShiftOrderByRelevanceFieldEnum | ShiftOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ShiftCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isFlexible?: SortOrder
    description?: SortOrder
  }

  export type ShiftAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ShiftMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isFlexible?: SortOrder
    description?: SortOrder
  }

  export type ShiftMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    isFlexible?: SortOrder
    description?: SortOrder
  }

  export type ShiftSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmployeeScalarRelationFilter = {
    is?: EmployeeWhereInput
    isNot?: EmployeeWhereInput
  }

  export type ShiftScalarRelationFilter = {
    is?: ShiftWhereInput
    isNot?: ShiftWhereInput
  }

  export type EmployeeShiftCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
  }

  export type EmployeeShiftAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
  }

  export type EmployeeShiftMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
  }

  export type EmployeeShiftMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
  }

  export type EmployeeShiftSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
  }

  export type SessionDefinitionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionNumber?: SortOrder
    expectedClockIn?: SortOrder
    expectedClockOut?: SortOrder
  }

  export type SessionDefinitionAvgOrderByAggregateInput = {
    id?: SortOrder
    sessionNumber?: SortOrder
  }

  export type SessionDefinitionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionNumber?: SortOrder
    expectedClockIn?: SortOrder
    expectedClockOut?: SortOrder
  }

  export type SessionDefinitionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionNumber?: SortOrder
    expectedClockIn?: SortOrder
    expectedClockOut?: SortOrder
  }

  export type SessionDefinitionSumOrderByAggregateInput = {
    id?: SortOrder
    sessionNumber?: SortOrder
  }

  export type EnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[]
    notIn?: $Enums.AttendanceStatus[]
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type SessionDefinitionScalarRelationFilter = {
    is?: SessionDefinitionWhereInput
    isNot?: SessionDefinitionWhereInput
  }

  export type AttendanceLogEmployeeIdDateSessionIdCompoundUniqueInput = {
    employeeId: number
    date: Date | string
    sessionId: number
  }

  export type AttendanceLogCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    sessionId?: SortOrder
    actualClockIn?: SortOrder
    actualClockOut?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceLogAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    sessionId?: SortOrder
  }

  export type AttendanceLogMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    sessionId?: SortOrder
    actualClockIn?: SortOrder
    actualClockOut?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceLogMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    sessionId?: SortOrder
    actualClockIn?: SortOrder
    actualClockOut?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceLogSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    sessionId?: SortOrder
  }

  export type EnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[]
    notIn?: $Enums.AttendanceStatus[]
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type EnumSummaryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SummaryStatus | EnumSummaryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SummaryStatus[]
    notIn?: $Enums.SummaryStatus[]
    not?: NestedEnumSummaryStatusFilter<$PrismaModel> | $Enums.SummaryStatus
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type AttendanceSummaryOrderByRelevanceInput = {
    fields: AttendanceSummaryOrderByRelevanceFieldEnum | AttendanceSummaryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AttendanceSummaryEmployeeIdDateCompoundUniqueInput = {
    employeeId: number
    date: Date | string
  }

  export type AttendanceSummaryCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    lateArrival?: SortOrder
    earlyDeparture?: SortOrder
    unplannedAbsence?: SortOrder
    totalWorkHours?: SortOrder
    remarks?: SortOrder
    departmentId?: SortOrder
  }

  export type AttendanceSummaryAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    totalWorkHours?: SortOrder
    departmentId?: SortOrder
  }

  export type AttendanceSummaryMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    lateArrival?: SortOrder
    earlyDeparture?: SortOrder
    unplannedAbsence?: SortOrder
    totalWorkHours?: SortOrder
    remarks?: SortOrder
    departmentId?: SortOrder
  }

  export type AttendanceSummaryMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    lateArrival?: SortOrder
    earlyDeparture?: SortOrder
    unplannedAbsence?: SortOrder
    totalWorkHours?: SortOrder
    remarks?: SortOrder
    departmentId?: SortOrder
  }

  export type AttendanceSummarySumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    totalWorkHours?: SortOrder
    departmentId?: SortOrder
  }

  export type EnumSummaryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SummaryStatus | EnumSummaryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SummaryStatus[]
    notIn?: $Enums.SummaryStatus[]
    not?: NestedEnumSummaryStatusWithAggregatesFilter<$PrismaModel> | $Enums.SummaryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSummaryStatusFilter<$PrismaModel>
    _max?: NestedEnumSummaryStatusFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumLeaveTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[]
    notIn?: $Enums.LeaveType[]
    not?: NestedEnumLeaveTypeFilter<$PrismaModel> | $Enums.LeaveType
  }

  export type EnumLeaveStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[]
    notIn?: $Enums.LeaveStatus[]
    not?: NestedEnumLeaveStatusFilter<$PrismaModel> | $Enums.LeaveStatus
  }

  export type LeaveOrderByRelevanceInput = {
    fields: LeaveOrderByRelevanceFieldEnum | LeaveOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LeaveCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    approvedBy?: SortOrder
    requestedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    approvedBy?: SortOrder
  }

  export type LeaveMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    approvedBy?: SortOrder
    requestedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    approvedBy?: SortOrder
    requestedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    approvedBy?: SortOrder
  }

  export type EnumLeaveTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[]
    notIn?: $Enums.LeaveType[]
    not?: NestedEnumLeaveTypeWithAggregatesFilter<$PrismaModel> | $Enums.LeaveType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveTypeFilter<$PrismaModel>
    _max?: NestedEnumLeaveTypeFilter<$PrismaModel>
  }

  export type EnumLeaveStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[]
    notIn?: $Enums.LeaveStatus[]
    not?: NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeaveStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveStatusFilter<$PrismaModel>
    _max?: NestedEnumLeaveStatusFilter<$PrismaModel>
  }

  export type HolidayOrderByRelevanceInput = {
    fields: HolidayOrderByRelevanceFieldEnum | HolidayOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type HolidayCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    isPublic?: SortOrder
    description?: SortOrder
  }

  export type HolidayAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type HolidayMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    isPublic?: SortOrder
    description?: SortOrder
  }

  export type HolidayMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    date?: SortOrder
    isPublic?: SortOrder
    description?: SortOrder
  }

  export type HolidaySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumOvertimeApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OvertimeApprovalStatus | EnumOvertimeApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OvertimeApprovalStatus[]
    notIn?: $Enums.OvertimeApprovalStatus[]
    not?: NestedEnumOvertimeApprovalStatusFilter<$PrismaModel> | $Enums.OvertimeApprovalStatus
  }

  export type EnumCompensationMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.CompensationMethod | EnumCompensationMethodFieldRefInput<$PrismaModel>
    in?: $Enums.CompensationMethod[]
    notIn?: $Enums.CompensationMethod[]
    not?: NestedEnumCompensationMethodFilter<$PrismaModel> | $Enums.CompensationMethod
  }

  export type OvertimeLogOrderByRelevanceInput = {
    fields: OvertimeLogOrderByRelevanceFieldEnum | OvertimeLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type OvertimeLogCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    hours?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    reason?: SortOrder
    approvedBy?: SortOrder
    approvalStatus?: SortOrder
    compensationMethod?: SortOrder
  }

  export type OvertimeLogAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    hours?: SortOrder
    approvedBy?: SortOrder
  }

  export type OvertimeLogMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    hours?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    reason?: SortOrder
    approvedBy?: SortOrder
    approvalStatus?: SortOrder
    compensationMethod?: SortOrder
  }

  export type OvertimeLogMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    hours?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    reason?: SortOrder
    approvedBy?: SortOrder
    approvalStatus?: SortOrder
    compensationMethod?: SortOrder
  }

  export type OvertimeLogSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    hours?: SortOrder
    approvedBy?: SortOrder
  }

  export type EnumOvertimeApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OvertimeApprovalStatus | EnumOvertimeApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OvertimeApprovalStatus[]
    notIn?: $Enums.OvertimeApprovalStatus[]
    not?: NestedEnumOvertimeApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.OvertimeApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOvertimeApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumOvertimeApprovalStatusFilter<$PrismaModel>
  }

  export type EnumCompensationMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompensationMethod | EnumCompensationMethodFieldRefInput<$PrismaModel>
    in?: $Enums.CompensationMethod[]
    notIn?: $Enums.CompensationMethod[]
    not?: NestedEnumCompensationMethodWithAggregatesFilter<$PrismaModel> | $Enums.CompensationMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompensationMethodFilter<$PrismaModel>
    _max?: NestedEnumCompensationMethodFilter<$PrismaModel>
  }

  export type EnumSalaryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SalaryStatus | EnumSalaryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SalaryStatus[]
    notIn?: $Enums.SalaryStatus[]
    not?: NestedEnumSalaryStatusFilter<$PrismaModel> | $Enums.SalaryStatus
  }

  export type SalaryEmployeeIdSalaryMonthCompoundUniqueInput = {
    employeeId: number
    salaryMonth: Date | string
  }

  export type SalaryCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    salaryMonth?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    overtimeHours?: SortOrder
    overtimePay?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalaryAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    amount?: SortOrder
    overtimeHours?: SortOrder
    overtimePay?: SortOrder
  }

  export type SalaryMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    salaryMonth?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    overtimeHours?: SortOrder
    overtimePay?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalaryMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    salaryMonth?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    overtimeHours?: SortOrder
    overtimePay?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalarySumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    amount?: SortOrder
    overtimeHours?: SortOrder
    overtimePay?: SortOrder
  }

  export type EnumSalaryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SalaryStatus | EnumSalaryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SalaryStatus[]
    notIn?: $Enums.SalaryStatus[]
    not?: NestedEnumSalaryStatusWithAggregatesFilter<$PrismaModel> | $Enums.SalaryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSalaryStatusFilter<$PrismaModel>
    _max?: NestedEnumSalaryStatusFilter<$PrismaModel>
  }

  export type EnumComplaintStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintStatus | EnumComplaintStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintStatus[]
    notIn?: $Enums.ComplaintStatus[]
    not?: NestedEnumComplaintStatusFilter<$PrismaModel> | $Enums.ComplaintStatus
  }

  export type ComplaintOrderByRelevanceInput = {
    fields: ComplaintOrderByRelevanceFieldEnum | ComplaintOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ComplaintCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplaintAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
  }

  export type ComplaintMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplaintMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplaintSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
  }

  export type EnumComplaintStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintStatus | EnumComplaintStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintStatus[]
    notIn?: $Enums.ComplaintStatus[]
    not?: NestedEnumComplaintStatusWithAggregatesFilter<$PrismaModel> | $Enums.ComplaintStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplaintStatusFilter<$PrismaModel>
    _max?: NestedEnumComplaintStatusFilter<$PrismaModel>
  }

  export type EnumInterviewResultFilter<$PrismaModel = never> = {
    equals?: $Enums.InterviewResult | EnumInterviewResultFieldRefInput<$PrismaModel>
    in?: $Enums.InterviewResult[]
    notIn?: $Enums.InterviewResult[]
    not?: NestedEnumInterviewResultFilter<$PrismaModel> | $Enums.InterviewResult
  }

  export type InterviewOrderByRelevanceInput = {
    fields: InterviewOrderByRelevanceFieldEnum | InterviewOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type InterviewCountOrderByAggregateInput = {
    id?: SortOrder
    candidateName?: SortOrder
    position?: SortOrder
    interviewDate?: SortOrder
    result?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InterviewAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type InterviewMaxOrderByAggregateInput = {
    id?: SortOrder
    candidateName?: SortOrder
    position?: SortOrder
    interviewDate?: SortOrder
    result?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InterviewMinOrderByAggregateInput = {
    id?: SortOrder
    candidateName?: SortOrder
    position?: SortOrder
    interviewDate?: SortOrder
    result?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InterviewSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumInterviewResultWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InterviewResult | EnumInterviewResultFieldRefInput<$PrismaModel>
    in?: $Enums.InterviewResult[]
    notIn?: $Enums.InterviewResult[]
    not?: NestedEnumInterviewResultWithAggregatesFilter<$PrismaModel> | $Enums.InterviewResult
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInterviewResultFilter<$PrismaModel>
    _max?: NestedEnumInterviewResultFilter<$PrismaModel>
  }

  export type PerformanceReviewOrderByRelevanceInput = {
    fields: PerformanceReviewOrderByRelevanceFieldEnum | PerformanceReviewOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PerformanceReviewCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    reviewDate?: SortOrder
    reviewerName?: SortOrder
    score?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PerformanceReviewAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    score?: SortOrder
  }

  export type PerformanceReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    reviewDate?: SortOrder
    reviewerName?: SortOrder
    score?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PerformanceReviewMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    reviewDate?: SortOrder
    reviewerName?: SortOrder
    score?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PerformanceReviewSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    score?: SortOrder
  }

  export type EnumTerminationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TerminationStatus | EnumTerminationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TerminationStatus[]
    notIn?: $Enums.TerminationStatus[]
    not?: NestedEnumTerminationStatusFilter<$PrismaModel> | $Enums.TerminationStatus
  }

  export type EnumWorkflowStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStatus | EnumWorkflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStatus[]
    notIn?: $Enums.WorkflowStatus[]
    not?: NestedEnumWorkflowStatusFilter<$PrismaModel> | $Enums.WorkflowStatus
  }

  export type TerminationOrderByRelevanceInput = {
    fields: TerminationOrderByRelevanceFieldEnum | TerminationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TerminationCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    terminationDate?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    workflowStatus?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TerminationAvgOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
  }

  export type TerminationMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    terminationDate?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    workflowStatus?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TerminationMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    terminationDate?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    workflowStatus?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TerminationSumOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
  }

  export type EnumTerminationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TerminationStatus | EnumTerminationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TerminationStatus[]
    notIn?: $Enums.TerminationStatus[]
    not?: NestedEnumTerminationStatusWithAggregatesFilter<$PrismaModel> | $Enums.TerminationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTerminationStatusFilter<$PrismaModel>
    _max?: NestedEnumTerminationStatusFilter<$PrismaModel>
  }

  export type EnumWorkflowStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStatus | EnumWorkflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStatus[]
    notIn?: $Enums.WorkflowStatus[]
    not?: NestedEnumWorkflowStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkflowStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkflowStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkflowStatusFilter<$PrismaModel>
  }

  export type UserRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type EmployeeCreateNestedManyWithoutUserInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput> | EmployeeCreateWithoutUserInput[] | EmployeeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput | EmployeeCreateOrConnectWithoutUserInput[]
    createMany?: EmployeeCreateManyUserInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type LeaveCreateNestedManyWithoutApproverInput = {
    create?: XOR<LeaveCreateWithoutApproverInput, LeaveUncheckedCreateWithoutApproverInput> | LeaveCreateWithoutApproverInput[] | LeaveUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutApproverInput | LeaveCreateOrConnectWithoutApproverInput[]
    createMany?: LeaveCreateManyApproverInputEnvelope
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
  }

  export type OvertimeLogCreateNestedManyWithoutApproverInput = {
    create?: XOR<OvertimeLogCreateWithoutApproverInput, OvertimeLogUncheckedCreateWithoutApproverInput> | OvertimeLogCreateWithoutApproverInput[] | OvertimeLogUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: OvertimeLogCreateOrConnectWithoutApproverInput | OvertimeLogCreateOrConnectWithoutApproverInput[]
    createMany?: OvertimeLogCreateManyApproverInputEnvelope
    connect?: OvertimeLogWhereUniqueInput | OvertimeLogWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput> | EmployeeCreateWithoutUserInput[] | EmployeeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput | EmployeeCreateOrConnectWithoutUserInput[]
    createMany?: EmployeeCreateManyUserInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type LeaveUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<LeaveCreateWithoutApproverInput, LeaveUncheckedCreateWithoutApproverInput> | LeaveCreateWithoutApproverInput[] | LeaveUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutApproverInput | LeaveCreateOrConnectWithoutApproverInput[]
    createMany?: LeaveCreateManyApproverInputEnvelope
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
  }

  export type OvertimeLogUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<OvertimeLogCreateWithoutApproverInput, OvertimeLogUncheckedCreateWithoutApproverInput> | OvertimeLogCreateWithoutApproverInput[] | OvertimeLogUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: OvertimeLogCreateOrConnectWithoutApproverInput | OvertimeLogCreateOrConnectWithoutApproverInput[]
    createMany?: OvertimeLogCreateManyApproverInputEnvelope
    connect?: OvertimeLogWhereUniqueInput | OvertimeLogWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type EmployeeUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput> | EmployeeCreateWithoutUserInput[] | EmployeeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput | EmployeeCreateOrConnectWithoutUserInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutUserInput | EmployeeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmployeeCreateManyUserInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutUserInput | EmployeeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutUserInput | EmployeeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type LeaveUpdateManyWithoutApproverNestedInput = {
    create?: XOR<LeaveCreateWithoutApproverInput, LeaveUncheckedCreateWithoutApproverInput> | LeaveCreateWithoutApproverInput[] | LeaveUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutApproverInput | LeaveCreateOrConnectWithoutApproverInput[]
    upsert?: LeaveUpsertWithWhereUniqueWithoutApproverInput | LeaveUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: LeaveCreateManyApproverInputEnvelope
    set?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    disconnect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    delete?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    update?: LeaveUpdateWithWhereUniqueWithoutApproverInput | LeaveUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: LeaveUpdateManyWithWhereWithoutApproverInput | LeaveUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
  }

  export type OvertimeLogUpdateManyWithoutApproverNestedInput = {
    create?: XOR<OvertimeLogCreateWithoutApproverInput, OvertimeLogUncheckedCreateWithoutApproverInput> | OvertimeLogCreateWithoutApproverInput[] | OvertimeLogUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: OvertimeLogCreateOrConnectWithoutApproverInput | OvertimeLogCreateOrConnectWithoutApproverInput[]
    upsert?: OvertimeLogUpsertWithWhereUniqueWithoutApproverInput | OvertimeLogUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: OvertimeLogCreateManyApproverInputEnvelope
    set?: OvertimeLogWhereUniqueInput | OvertimeLogWhereUniqueInput[]
    disconnect?: OvertimeLogWhereUniqueInput | OvertimeLogWhereUniqueInput[]
    delete?: OvertimeLogWhereUniqueInput | OvertimeLogWhereUniqueInput[]
    connect?: OvertimeLogWhereUniqueInput | OvertimeLogWhereUniqueInput[]
    update?: OvertimeLogUpdateWithWhereUniqueWithoutApproverInput | OvertimeLogUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: OvertimeLogUpdateManyWithWhereWithoutApproverInput | OvertimeLogUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: OvertimeLogScalarWhereInput | OvertimeLogScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput> | EmployeeCreateWithoutUserInput[] | EmployeeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput | EmployeeCreateOrConnectWithoutUserInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutUserInput | EmployeeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmployeeCreateManyUserInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutUserInput | EmployeeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutUserInput | EmployeeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type LeaveUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<LeaveCreateWithoutApproverInput, LeaveUncheckedCreateWithoutApproverInput> | LeaveCreateWithoutApproverInput[] | LeaveUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutApproverInput | LeaveCreateOrConnectWithoutApproverInput[]
    upsert?: LeaveUpsertWithWhereUniqueWithoutApproverInput | LeaveUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: LeaveCreateManyApproverInputEnvelope
    set?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    disconnect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    delete?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    update?: LeaveUpdateWithWhereUniqueWithoutApproverInput | LeaveUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: LeaveUpdateManyWithWhereWithoutApproverInput | LeaveUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
  }

  export type OvertimeLogUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<OvertimeLogCreateWithoutApproverInput, OvertimeLogUncheckedCreateWithoutApproverInput> | OvertimeLogCreateWithoutApproverInput[] | OvertimeLogUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: OvertimeLogCreateOrConnectWithoutApproverInput | OvertimeLogCreateOrConnectWithoutApproverInput[]
    upsert?: OvertimeLogUpsertWithWhereUniqueWithoutApproverInput | OvertimeLogUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: OvertimeLogCreateManyApproverInputEnvelope
    set?: OvertimeLogWhereUniqueInput | OvertimeLogWhereUniqueInput[]
    disconnect?: OvertimeLogWhereUniqueInput | OvertimeLogWhereUniqueInput[]
    delete?: OvertimeLogWhereUniqueInput | OvertimeLogWhereUniqueInput[]
    connect?: OvertimeLogWhereUniqueInput | OvertimeLogWhereUniqueInput[]
    update?: OvertimeLogUpdateWithWhereUniqueWithoutApproverInput | OvertimeLogUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: OvertimeLogUpdateManyWithWhereWithoutApproverInput | OvertimeLogUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: OvertimeLogScalarWhereInput | OvertimeLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRolesInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    connect?: UserWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    upsert?: UserUpsertWithoutRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRolesInput, UserUpdateWithoutRolesInput>, UserUncheckedUpdateWithoutRolesInput>
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type DepartmentCreateNestedOneWithoutSubDepartmentsInput = {
    create?: XOR<DepartmentCreateWithoutSubDepartmentsInput, DepartmentUncheckedCreateWithoutSubDepartmentsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutSubDepartmentsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type DepartmentCreateNestedManyWithoutParentInput = {
    create?: XOR<DepartmentCreateWithoutParentInput, DepartmentUncheckedCreateWithoutParentInput> | DepartmentCreateWithoutParentInput[] | DepartmentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutParentInput | DepartmentCreateOrConnectWithoutParentInput[]
    createMany?: DepartmentCreateManyParentInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type EmployeeCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput> | EmployeeCreateWithoutDepartmentInput[] | EmployeeUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDepartmentInput | EmployeeCreateOrConnectWithoutDepartmentInput[]
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type AttendanceSummaryCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<AttendanceSummaryCreateWithoutDepartmentInput, AttendanceSummaryUncheckedCreateWithoutDepartmentInput> | AttendanceSummaryCreateWithoutDepartmentInput[] | AttendanceSummaryUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AttendanceSummaryCreateOrConnectWithoutDepartmentInput | AttendanceSummaryCreateOrConnectWithoutDepartmentInput[]
    createMany?: AttendanceSummaryCreateManyDepartmentInputEnvelope
    connect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
  }

  export type DepartmentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<DepartmentCreateWithoutParentInput, DepartmentUncheckedCreateWithoutParentInput> | DepartmentCreateWithoutParentInput[] | DepartmentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutParentInput | DepartmentCreateOrConnectWithoutParentInput[]
    createMany?: DepartmentCreateManyParentInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput> | EmployeeCreateWithoutDepartmentInput[] | EmployeeUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDepartmentInput | EmployeeCreateOrConnectWithoutDepartmentInput[]
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type AttendanceSummaryUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<AttendanceSummaryCreateWithoutDepartmentInput, AttendanceSummaryUncheckedCreateWithoutDepartmentInput> | AttendanceSummaryCreateWithoutDepartmentInput[] | AttendanceSummaryUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AttendanceSummaryCreateOrConnectWithoutDepartmentInput | AttendanceSummaryCreateOrConnectWithoutDepartmentInput[]
    createMany?: AttendanceSummaryCreateManyDepartmentInputEnvelope
    connect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
  }

  export type DepartmentUpdateOneWithoutSubDepartmentsNestedInput = {
    create?: XOR<DepartmentCreateWithoutSubDepartmentsInput, DepartmentUncheckedCreateWithoutSubDepartmentsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutSubDepartmentsInput
    upsert?: DepartmentUpsertWithoutSubDepartmentsInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutSubDepartmentsInput, DepartmentUpdateWithoutSubDepartmentsInput>, DepartmentUncheckedUpdateWithoutSubDepartmentsInput>
  }

  export type DepartmentUpdateManyWithoutParentNestedInput = {
    create?: XOR<DepartmentCreateWithoutParentInput, DepartmentUncheckedCreateWithoutParentInput> | DepartmentCreateWithoutParentInput[] | DepartmentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutParentInput | DepartmentCreateOrConnectWithoutParentInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutParentInput | DepartmentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: DepartmentCreateManyParentInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutParentInput | DepartmentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutParentInput | DepartmentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type EmployeeUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput> | EmployeeCreateWithoutDepartmentInput[] | EmployeeUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDepartmentInput | EmployeeCreateOrConnectWithoutDepartmentInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutDepartmentInput | EmployeeUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutDepartmentInput | EmployeeUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutDepartmentInput | EmployeeUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type AttendanceSummaryUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<AttendanceSummaryCreateWithoutDepartmentInput, AttendanceSummaryUncheckedCreateWithoutDepartmentInput> | AttendanceSummaryCreateWithoutDepartmentInput[] | AttendanceSummaryUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AttendanceSummaryCreateOrConnectWithoutDepartmentInput | AttendanceSummaryCreateOrConnectWithoutDepartmentInput[]
    upsert?: AttendanceSummaryUpsertWithWhereUniqueWithoutDepartmentInput | AttendanceSummaryUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: AttendanceSummaryCreateManyDepartmentInputEnvelope
    set?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    disconnect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    delete?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    connect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    update?: AttendanceSummaryUpdateWithWhereUniqueWithoutDepartmentInput | AttendanceSummaryUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: AttendanceSummaryUpdateManyWithWhereWithoutDepartmentInput | AttendanceSummaryUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: AttendanceSummaryScalarWhereInput | AttendanceSummaryScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DepartmentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<DepartmentCreateWithoutParentInput, DepartmentUncheckedCreateWithoutParentInput> | DepartmentCreateWithoutParentInput[] | DepartmentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutParentInput | DepartmentCreateOrConnectWithoutParentInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutParentInput | DepartmentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: DepartmentCreateManyParentInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutParentInput | DepartmentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutParentInput | DepartmentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput> | EmployeeCreateWithoutDepartmentInput[] | EmployeeUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDepartmentInput | EmployeeCreateOrConnectWithoutDepartmentInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutDepartmentInput | EmployeeUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutDepartmentInput | EmployeeUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutDepartmentInput | EmployeeUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type AttendanceSummaryUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<AttendanceSummaryCreateWithoutDepartmentInput, AttendanceSummaryUncheckedCreateWithoutDepartmentInput> | AttendanceSummaryCreateWithoutDepartmentInput[] | AttendanceSummaryUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AttendanceSummaryCreateOrConnectWithoutDepartmentInput | AttendanceSummaryCreateOrConnectWithoutDepartmentInput[]
    upsert?: AttendanceSummaryUpsertWithWhereUniqueWithoutDepartmentInput | AttendanceSummaryUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: AttendanceSummaryCreateManyDepartmentInputEnvelope
    set?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    disconnect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    delete?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    connect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    update?: AttendanceSummaryUpdateWithWhereUniqueWithoutDepartmentInput | AttendanceSummaryUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: AttendanceSummaryUpdateManyWithWhereWithoutDepartmentInput | AttendanceSummaryUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: AttendanceSummaryScalarWhereInput | AttendanceSummaryScalarWhereInput[]
  }

  export type EmployeeCreateNestedManyWithoutPositionInput = {
    create?: XOR<EmployeeCreateWithoutPositionInput, EmployeeUncheckedCreateWithoutPositionInput> | EmployeeCreateWithoutPositionInput[] | EmployeeUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutPositionInput | EmployeeCreateOrConnectWithoutPositionInput[]
    createMany?: EmployeeCreateManyPositionInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutPositionInput = {
    create?: XOR<EmployeeCreateWithoutPositionInput, EmployeeUncheckedCreateWithoutPositionInput> | EmployeeCreateWithoutPositionInput[] | EmployeeUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutPositionInput | EmployeeCreateOrConnectWithoutPositionInput[]
    createMany?: EmployeeCreateManyPositionInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeUpdateManyWithoutPositionNestedInput = {
    create?: XOR<EmployeeCreateWithoutPositionInput, EmployeeUncheckedCreateWithoutPositionInput> | EmployeeCreateWithoutPositionInput[] | EmployeeUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutPositionInput | EmployeeCreateOrConnectWithoutPositionInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutPositionInput | EmployeeUpsertWithWhereUniqueWithoutPositionInput[]
    createMany?: EmployeeCreateManyPositionInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutPositionInput | EmployeeUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutPositionInput | EmployeeUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutPositionNestedInput = {
    create?: XOR<EmployeeCreateWithoutPositionInput, EmployeeUncheckedCreateWithoutPositionInput> | EmployeeCreateWithoutPositionInput[] | EmployeeUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutPositionInput | EmployeeCreateOrConnectWithoutPositionInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutPositionInput | EmployeeUpsertWithWhereUniqueWithoutPositionInput[]
    createMany?: EmployeeCreateManyPositionInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutPositionInput | EmployeeUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutPositionInput | EmployeeUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeCreateNestedManyWithoutMaritalStatusInput = {
    create?: XOR<EmployeeCreateWithoutMaritalStatusInput, EmployeeUncheckedCreateWithoutMaritalStatusInput> | EmployeeCreateWithoutMaritalStatusInput[] | EmployeeUncheckedCreateWithoutMaritalStatusInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutMaritalStatusInput | EmployeeCreateOrConnectWithoutMaritalStatusInput[]
    createMany?: EmployeeCreateManyMaritalStatusInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutMaritalStatusInput = {
    create?: XOR<EmployeeCreateWithoutMaritalStatusInput, EmployeeUncheckedCreateWithoutMaritalStatusInput> | EmployeeCreateWithoutMaritalStatusInput[] | EmployeeUncheckedCreateWithoutMaritalStatusInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutMaritalStatusInput | EmployeeCreateOrConnectWithoutMaritalStatusInput[]
    createMany?: EmployeeCreateManyMaritalStatusInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeUpdateManyWithoutMaritalStatusNestedInput = {
    create?: XOR<EmployeeCreateWithoutMaritalStatusInput, EmployeeUncheckedCreateWithoutMaritalStatusInput> | EmployeeCreateWithoutMaritalStatusInput[] | EmployeeUncheckedCreateWithoutMaritalStatusInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutMaritalStatusInput | EmployeeCreateOrConnectWithoutMaritalStatusInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutMaritalStatusInput | EmployeeUpsertWithWhereUniqueWithoutMaritalStatusInput[]
    createMany?: EmployeeCreateManyMaritalStatusInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutMaritalStatusInput | EmployeeUpdateWithWhereUniqueWithoutMaritalStatusInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutMaritalStatusInput | EmployeeUpdateManyWithWhereWithoutMaritalStatusInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutMaritalStatusNestedInput = {
    create?: XOR<EmployeeCreateWithoutMaritalStatusInput, EmployeeUncheckedCreateWithoutMaritalStatusInput> | EmployeeCreateWithoutMaritalStatusInput[] | EmployeeUncheckedCreateWithoutMaritalStatusInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutMaritalStatusInput | EmployeeCreateOrConnectWithoutMaritalStatusInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutMaritalStatusInput | EmployeeUpsertWithWhereUniqueWithoutMaritalStatusInput[]
    createMany?: EmployeeCreateManyMaritalStatusInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutMaritalStatusInput | EmployeeUpdateWithWhereUniqueWithoutMaritalStatusInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutMaritalStatusInput | EmployeeUpdateManyWithWhereWithoutMaritalStatusInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeCreateNestedManyWithoutEmploymentTypeInput = {
    create?: XOR<EmployeeCreateWithoutEmploymentTypeInput, EmployeeUncheckedCreateWithoutEmploymentTypeInput> | EmployeeCreateWithoutEmploymentTypeInput[] | EmployeeUncheckedCreateWithoutEmploymentTypeInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutEmploymentTypeInput | EmployeeCreateOrConnectWithoutEmploymentTypeInput[]
    createMany?: EmployeeCreateManyEmploymentTypeInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutEmploymentTypeInput = {
    create?: XOR<EmployeeCreateWithoutEmploymentTypeInput, EmployeeUncheckedCreateWithoutEmploymentTypeInput> | EmployeeCreateWithoutEmploymentTypeInput[] | EmployeeUncheckedCreateWithoutEmploymentTypeInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutEmploymentTypeInput | EmployeeCreateOrConnectWithoutEmploymentTypeInput[]
    createMany?: EmployeeCreateManyEmploymentTypeInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeUpdateManyWithoutEmploymentTypeNestedInput = {
    create?: XOR<EmployeeCreateWithoutEmploymentTypeInput, EmployeeUncheckedCreateWithoutEmploymentTypeInput> | EmployeeCreateWithoutEmploymentTypeInput[] | EmployeeUncheckedCreateWithoutEmploymentTypeInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutEmploymentTypeInput | EmployeeCreateOrConnectWithoutEmploymentTypeInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutEmploymentTypeInput | EmployeeUpsertWithWhereUniqueWithoutEmploymentTypeInput[]
    createMany?: EmployeeCreateManyEmploymentTypeInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutEmploymentTypeInput | EmployeeUpdateWithWhereUniqueWithoutEmploymentTypeInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutEmploymentTypeInput | EmployeeUpdateManyWithWhereWithoutEmploymentTypeInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutEmploymentTypeNestedInput = {
    create?: XOR<EmployeeCreateWithoutEmploymentTypeInput, EmployeeUncheckedCreateWithoutEmploymentTypeInput> | EmployeeCreateWithoutEmploymentTypeInput[] | EmployeeUncheckedCreateWithoutEmploymentTypeInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutEmploymentTypeInput | EmployeeCreateOrConnectWithoutEmploymentTypeInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutEmploymentTypeInput | EmployeeUpsertWithWhereUniqueWithoutEmploymentTypeInput[]
    createMany?: EmployeeCreateManyEmploymentTypeInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutEmploymentTypeInput | EmployeeUpdateWithWhereUniqueWithoutEmploymentTypeInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutEmploymentTypeInput | EmployeeUpdateManyWithWhereWithoutEmploymentTypeInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeCreateNestedManyWithoutJobStatusInput = {
    create?: XOR<EmployeeCreateWithoutJobStatusInput, EmployeeUncheckedCreateWithoutJobStatusInput> | EmployeeCreateWithoutJobStatusInput[] | EmployeeUncheckedCreateWithoutJobStatusInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutJobStatusInput | EmployeeCreateOrConnectWithoutJobStatusInput[]
    createMany?: EmployeeCreateManyJobStatusInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutJobStatusInput = {
    create?: XOR<EmployeeCreateWithoutJobStatusInput, EmployeeUncheckedCreateWithoutJobStatusInput> | EmployeeCreateWithoutJobStatusInput[] | EmployeeUncheckedCreateWithoutJobStatusInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutJobStatusInput | EmployeeCreateOrConnectWithoutJobStatusInput[]
    createMany?: EmployeeCreateManyJobStatusInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeUpdateManyWithoutJobStatusNestedInput = {
    create?: XOR<EmployeeCreateWithoutJobStatusInput, EmployeeUncheckedCreateWithoutJobStatusInput> | EmployeeCreateWithoutJobStatusInput[] | EmployeeUncheckedCreateWithoutJobStatusInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutJobStatusInput | EmployeeCreateOrConnectWithoutJobStatusInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutJobStatusInput | EmployeeUpsertWithWhereUniqueWithoutJobStatusInput[]
    createMany?: EmployeeCreateManyJobStatusInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutJobStatusInput | EmployeeUpdateWithWhereUniqueWithoutJobStatusInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutJobStatusInput | EmployeeUpdateManyWithWhereWithoutJobStatusInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutJobStatusNestedInput = {
    create?: XOR<EmployeeCreateWithoutJobStatusInput, EmployeeUncheckedCreateWithoutJobStatusInput> | EmployeeCreateWithoutJobStatusInput[] | EmployeeUncheckedCreateWithoutJobStatusInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutJobStatusInput | EmployeeCreateOrConnectWithoutJobStatusInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutJobStatusInput | EmployeeUpsertWithWhereUniqueWithoutJobStatusInput[]
    createMany?: EmployeeCreateManyJobStatusInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutJobStatusInput | EmployeeUpdateWithWhereUniqueWithoutJobStatusInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutJobStatusInput | EmployeeUpdateManyWithWhereWithoutJobStatusInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeCreateNestedManyWithoutAgreementStatusInput = {
    create?: XOR<EmployeeCreateWithoutAgreementStatusInput, EmployeeUncheckedCreateWithoutAgreementStatusInput> | EmployeeCreateWithoutAgreementStatusInput[] | EmployeeUncheckedCreateWithoutAgreementStatusInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutAgreementStatusInput | EmployeeCreateOrConnectWithoutAgreementStatusInput[]
    createMany?: EmployeeCreateManyAgreementStatusInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutAgreementStatusInput = {
    create?: XOR<EmployeeCreateWithoutAgreementStatusInput, EmployeeUncheckedCreateWithoutAgreementStatusInput> | EmployeeCreateWithoutAgreementStatusInput[] | EmployeeUncheckedCreateWithoutAgreementStatusInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutAgreementStatusInput | EmployeeCreateOrConnectWithoutAgreementStatusInput[]
    createMany?: EmployeeCreateManyAgreementStatusInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeUpdateManyWithoutAgreementStatusNestedInput = {
    create?: XOR<EmployeeCreateWithoutAgreementStatusInput, EmployeeUncheckedCreateWithoutAgreementStatusInput> | EmployeeCreateWithoutAgreementStatusInput[] | EmployeeUncheckedCreateWithoutAgreementStatusInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutAgreementStatusInput | EmployeeCreateOrConnectWithoutAgreementStatusInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutAgreementStatusInput | EmployeeUpsertWithWhereUniqueWithoutAgreementStatusInput[]
    createMany?: EmployeeCreateManyAgreementStatusInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutAgreementStatusInput | EmployeeUpdateWithWhereUniqueWithoutAgreementStatusInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutAgreementStatusInput | EmployeeUpdateManyWithWhereWithoutAgreementStatusInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutAgreementStatusNestedInput = {
    create?: XOR<EmployeeCreateWithoutAgreementStatusInput, EmployeeUncheckedCreateWithoutAgreementStatusInput> | EmployeeCreateWithoutAgreementStatusInput[] | EmployeeUncheckedCreateWithoutAgreementStatusInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutAgreementStatusInput | EmployeeCreateOrConnectWithoutAgreementStatusInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutAgreementStatusInput | EmployeeUpsertWithWhereUniqueWithoutAgreementStatusInput[]
    createMany?: EmployeeCreateManyAgreementStatusInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutAgreementStatusInput | EmployeeUpdateWithWhereUniqueWithoutAgreementStatusInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutAgreementStatusInput | EmployeeUpdateManyWithWhereWithoutAgreementStatusInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeCreateNestedOneWithoutCreatedMeetingsInput = {
    create?: XOR<EmployeeCreateWithoutCreatedMeetingsInput, EmployeeUncheckedCreateWithoutCreatedMeetingsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutCreatedMeetingsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneWithoutCreatedMeetingsNestedInput = {
    create?: XOR<EmployeeCreateWithoutCreatedMeetingsInput, EmployeeUncheckedCreateWithoutCreatedMeetingsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutCreatedMeetingsInput
    upsert?: EmployeeUpsertWithoutCreatedMeetingsInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutCreatedMeetingsInput, EmployeeUpdateWithoutCreatedMeetingsInput>, EmployeeUncheckedUpdateWithoutCreatedMeetingsInput>
  }

  export type UserCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<UserCreateWithoutEmployeesInput, UserUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeesInput
    connect?: UserWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<DepartmentCreateWithoutEmployeesInput, DepartmentUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutEmployeesInput
    connect?: DepartmentWhereUniqueInput
  }

  export type PositionCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<PositionCreateWithoutEmployeesInput, PositionUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: PositionCreateOrConnectWithoutEmployeesInput
    connect?: PositionWhereUniqueInput
  }

  export type MaritalStatusCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<MaritalStatusCreateWithoutEmployeesInput, MaritalStatusUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: MaritalStatusCreateOrConnectWithoutEmployeesInput
    connect?: MaritalStatusWhereUniqueInput
  }

  export type EmploymentTypeCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<EmploymentTypeCreateWithoutEmployeesInput, EmploymentTypeUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: EmploymentTypeCreateOrConnectWithoutEmployeesInput
    connect?: EmploymentTypeWhereUniqueInput
  }

  export type JobStatusCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<JobStatusCreateWithoutEmployeesInput, JobStatusUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: JobStatusCreateOrConnectWithoutEmployeesInput
    connect?: JobStatusWhereUniqueInput
  }

  export type AgreementStatusCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<AgreementStatusCreateWithoutEmployeesInput, AgreementStatusUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: AgreementStatusCreateOrConnectWithoutEmployeesInput
    connect?: AgreementStatusWhereUniqueInput
  }

  export type MeetingCreateNestedManyWithoutCreatorInput = {
    create?: XOR<MeetingCreateWithoutCreatorInput, MeetingUncheckedCreateWithoutCreatorInput> | MeetingCreateWithoutCreatorInput[] | MeetingUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutCreatorInput | MeetingCreateOrConnectWithoutCreatorInput[]
    createMany?: MeetingCreateManyCreatorInputEnvelope
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
  }

  export type EmployeeShiftCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeShiftCreateWithoutEmployeeInput, EmployeeShiftUncheckedCreateWithoutEmployeeInput> | EmployeeShiftCreateWithoutEmployeeInput[] | EmployeeShiftUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeShiftCreateOrConnectWithoutEmployeeInput | EmployeeShiftCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeShiftCreateManyEmployeeInputEnvelope
    connect?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
  }

  export type AttendanceLogCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AttendanceLogCreateWithoutEmployeeInput, AttendanceLogUncheckedCreateWithoutEmployeeInput> | AttendanceLogCreateWithoutEmployeeInput[] | AttendanceLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceLogCreateOrConnectWithoutEmployeeInput | AttendanceLogCreateOrConnectWithoutEmployeeInput[]
    createMany?: AttendanceLogCreateManyEmployeeInputEnvelope
    connect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
  }

  export type AttendanceSummaryCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AttendanceSummaryCreateWithoutEmployeeInput, AttendanceSummaryUncheckedCreateWithoutEmployeeInput> | AttendanceSummaryCreateWithoutEmployeeInput[] | AttendanceSummaryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceSummaryCreateOrConnectWithoutEmployeeInput | AttendanceSummaryCreateOrConnectWithoutEmployeeInput[]
    createMany?: AttendanceSummaryCreateManyEmployeeInputEnvelope
    connect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
  }

  export type LeaveCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LeaveCreateWithoutEmployeeInput, LeaveUncheckedCreateWithoutEmployeeInput> | LeaveCreateWithoutEmployeeInput[] | LeaveUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutEmployeeInput | LeaveCreateOrConnectWithoutEmployeeInput[]
    createMany?: LeaveCreateManyEmployeeInputEnvelope
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
  }

  export type ComplaintCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<ComplaintCreateWithoutEmployeeInput, ComplaintUncheckedCreateWithoutEmployeeInput> | ComplaintCreateWithoutEmployeeInput[] | ComplaintUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutEmployeeInput | ComplaintCreateOrConnectWithoutEmployeeInput[]
    createMany?: ComplaintCreateManyEmployeeInputEnvelope
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
  }

  export type PerformanceReviewCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PerformanceReviewCreateWithoutEmployeeInput, PerformanceReviewUncheckedCreateWithoutEmployeeInput> | PerformanceReviewCreateWithoutEmployeeInput[] | PerformanceReviewUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PerformanceReviewCreateOrConnectWithoutEmployeeInput | PerformanceReviewCreateOrConnectWithoutEmployeeInput[]
    createMany?: PerformanceReviewCreateManyEmployeeInputEnvelope
    connect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
  }

  export type TerminationCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<TerminationCreateWithoutEmployeeInput, TerminationUncheckedCreateWithoutEmployeeInput> | TerminationCreateWithoutEmployeeInput[] | TerminationUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: TerminationCreateOrConnectWithoutEmployeeInput | TerminationCreateOrConnectWithoutEmployeeInput[]
    createMany?: TerminationCreateManyEmployeeInputEnvelope
    connect?: TerminationWhereUniqueInput | TerminationWhereUniqueInput[]
  }

  export type SalaryCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<SalaryCreateWithoutEmployeeInput, SalaryUncheckedCreateWithoutEmployeeInput> | SalaryCreateWithoutEmployeeInput[] | SalaryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SalaryCreateOrConnectWithoutEmployeeInput | SalaryCreateOrConnectWithoutEmployeeInput[]
    createMany?: SalaryCreateManyEmployeeInputEnvelope
    connect?: SalaryWhereUniqueInput | SalaryWhereUniqueInput[]
  }

  export type OvertimeLogCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<OvertimeLogCreateWithoutEmployeeInput, OvertimeLogUncheckedCreateWithoutEmployeeInput> | OvertimeLogCreateWithoutEmployeeInput[] | OvertimeLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: OvertimeLogCreateOrConnectWithoutEmployeeInput | OvertimeLogCreateOrConnectWithoutEmployeeInput[]
    createMany?: OvertimeLogCreateManyEmployeeInputEnvelope
    connect?: OvertimeLogWhereUniqueInput | OvertimeLogWhereUniqueInput[]
  }

  export type MeetingUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<MeetingCreateWithoutCreatorInput, MeetingUncheckedCreateWithoutCreatorInput> | MeetingCreateWithoutCreatorInput[] | MeetingUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutCreatorInput | MeetingCreateOrConnectWithoutCreatorInput[]
    createMany?: MeetingCreateManyCreatorInputEnvelope
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
  }

  export type EmployeeShiftUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeShiftCreateWithoutEmployeeInput, EmployeeShiftUncheckedCreateWithoutEmployeeInput> | EmployeeShiftCreateWithoutEmployeeInput[] | EmployeeShiftUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeShiftCreateOrConnectWithoutEmployeeInput | EmployeeShiftCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeShiftCreateManyEmployeeInputEnvelope
    connect?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
  }

  export type AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AttendanceLogCreateWithoutEmployeeInput, AttendanceLogUncheckedCreateWithoutEmployeeInput> | AttendanceLogCreateWithoutEmployeeInput[] | AttendanceLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceLogCreateOrConnectWithoutEmployeeInput | AttendanceLogCreateOrConnectWithoutEmployeeInput[]
    createMany?: AttendanceLogCreateManyEmployeeInputEnvelope
    connect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
  }

  export type AttendanceSummaryUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AttendanceSummaryCreateWithoutEmployeeInput, AttendanceSummaryUncheckedCreateWithoutEmployeeInput> | AttendanceSummaryCreateWithoutEmployeeInput[] | AttendanceSummaryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceSummaryCreateOrConnectWithoutEmployeeInput | AttendanceSummaryCreateOrConnectWithoutEmployeeInput[]
    createMany?: AttendanceSummaryCreateManyEmployeeInputEnvelope
    connect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
  }

  export type LeaveUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LeaveCreateWithoutEmployeeInput, LeaveUncheckedCreateWithoutEmployeeInput> | LeaveCreateWithoutEmployeeInput[] | LeaveUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutEmployeeInput | LeaveCreateOrConnectWithoutEmployeeInput[]
    createMany?: LeaveCreateManyEmployeeInputEnvelope
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
  }

  export type ComplaintUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<ComplaintCreateWithoutEmployeeInput, ComplaintUncheckedCreateWithoutEmployeeInput> | ComplaintCreateWithoutEmployeeInput[] | ComplaintUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutEmployeeInput | ComplaintCreateOrConnectWithoutEmployeeInput[]
    createMany?: ComplaintCreateManyEmployeeInputEnvelope
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
  }

  export type PerformanceReviewUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PerformanceReviewCreateWithoutEmployeeInput, PerformanceReviewUncheckedCreateWithoutEmployeeInput> | PerformanceReviewCreateWithoutEmployeeInput[] | PerformanceReviewUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PerformanceReviewCreateOrConnectWithoutEmployeeInput | PerformanceReviewCreateOrConnectWithoutEmployeeInput[]
    createMany?: PerformanceReviewCreateManyEmployeeInputEnvelope
    connect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
  }

  export type TerminationUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<TerminationCreateWithoutEmployeeInput, TerminationUncheckedCreateWithoutEmployeeInput> | TerminationCreateWithoutEmployeeInput[] | TerminationUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: TerminationCreateOrConnectWithoutEmployeeInput | TerminationCreateOrConnectWithoutEmployeeInput[]
    createMany?: TerminationCreateManyEmployeeInputEnvelope
    connect?: TerminationWhereUniqueInput | TerminationWhereUniqueInput[]
  }

  export type SalaryUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<SalaryCreateWithoutEmployeeInput, SalaryUncheckedCreateWithoutEmployeeInput> | SalaryCreateWithoutEmployeeInput[] | SalaryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SalaryCreateOrConnectWithoutEmployeeInput | SalaryCreateOrConnectWithoutEmployeeInput[]
    createMany?: SalaryCreateManyEmployeeInputEnvelope
    connect?: SalaryWhereUniqueInput | SalaryWhereUniqueInput[]
  }

  export type OvertimeLogUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<OvertimeLogCreateWithoutEmployeeInput, OvertimeLogUncheckedCreateWithoutEmployeeInput> | OvertimeLogCreateWithoutEmployeeInput[] | OvertimeLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: OvertimeLogCreateOrConnectWithoutEmployeeInput | OvertimeLogCreateOrConnectWithoutEmployeeInput[]
    createMany?: OvertimeLogCreateManyEmployeeInputEnvelope
    connect?: OvertimeLogWhereUniqueInput | OvertimeLogWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumSexFieldUpdateOperationsInput = {
    set?: $Enums.Sex
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<UserCreateWithoutEmployeesInput, UserUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeesInput
    upsert?: UserUpsertWithoutEmployeesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmployeesInput, UserUpdateWithoutEmployeesInput>, UserUncheckedUpdateWithoutEmployeesInput>
  }

  export type DepartmentUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<DepartmentCreateWithoutEmployeesInput, DepartmentUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutEmployeesInput
    upsert?: DepartmentUpsertWithoutEmployeesInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutEmployeesInput, DepartmentUpdateWithoutEmployeesInput>, DepartmentUncheckedUpdateWithoutEmployeesInput>
  }

  export type PositionUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<PositionCreateWithoutEmployeesInput, PositionUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: PositionCreateOrConnectWithoutEmployeesInput
    upsert?: PositionUpsertWithoutEmployeesInput
    disconnect?: PositionWhereInput | boolean
    delete?: PositionWhereInput | boolean
    connect?: PositionWhereUniqueInput
    update?: XOR<XOR<PositionUpdateToOneWithWhereWithoutEmployeesInput, PositionUpdateWithoutEmployeesInput>, PositionUncheckedUpdateWithoutEmployeesInput>
  }

  export type MaritalStatusUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<MaritalStatusCreateWithoutEmployeesInput, MaritalStatusUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: MaritalStatusCreateOrConnectWithoutEmployeesInput
    upsert?: MaritalStatusUpsertWithoutEmployeesInput
    disconnect?: MaritalStatusWhereInput | boolean
    delete?: MaritalStatusWhereInput | boolean
    connect?: MaritalStatusWhereUniqueInput
    update?: XOR<XOR<MaritalStatusUpdateToOneWithWhereWithoutEmployeesInput, MaritalStatusUpdateWithoutEmployeesInput>, MaritalStatusUncheckedUpdateWithoutEmployeesInput>
  }

  export type EmploymentTypeUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<EmploymentTypeCreateWithoutEmployeesInput, EmploymentTypeUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: EmploymentTypeCreateOrConnectWithoutEmployeesInput
    upsert?: EmploymentTypeUpsertWithoutEmployeesInput
    disconnect?: EmploymentTypeWhereInput | boolean
    delete?: EmploymentTypeWhereInput | boolean
    connect?: EmploymentTypeWhereUniqueInput
    update?: XOR<XOR<EmploymentTypeUpdateToOneWithWhereWithoutEmployeesInput, EmploymentTypeUpdateWithoutEmployeesInput>, EmploymentTypeUncheckedUpdateWithoutEmployeesInput>
  }

  export type JobStatusUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<JobStatusCreateWithoutEmployeesInput, JobStatusUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: JobStatusCreateOrConnectWithoutEmployeesInput
    upsert?: JobStatusUpsertWithoutEmployeesInput
    disconnect?: JobStatusWhereInput | boolean
    delete?: JobStatusWhereInput | boolean
    connect?: JobStatusWhereUniqueInput
    update?: XOR<XOR<JobStatusUpdateToOneWithWhereWithoutEmployeesInput, JobStatusUpdateWithoutEmployeesInput>, JobStatusUncheckedUpdateWithoutEmployeesInput>
  }

  export type AgreementStatusUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<AgreementStatusCreateWithoutEmployeesInput, AgreementStatusUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: AgreementStatusCreateOrConnectWithoutEmployeesInput
    upsert?: AgreementStatusUpsertWithoutEmployeesInput
    disconnect?: AgreementStatusWhereInput | boolean
    delete?: AgreementStatusWhereInput | boolean
    connect?: AgreementStatusWhereUniqueInput
    update?: XOR<XOR<AgreementStatusUpdateToOneWithWhereWithoutEmployeesInput, AgreementStatusUpdateWithoutEmployeesInput>, AgreementStatusUncheckedUpdateWithoutEmployeesInput>
  }

  export type MeetingUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<MeetingCreateWithoutCreatorInput, MeetingUncheckedCreateWithoutCreatorInput> | MeetingCreateWithoutCreatorInput[] | MeetingUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutCreatorInput | MeetingCreateOrConnectWithoutCreatorInput[]
    upsert?: MeetingUpsertWithWhereUniqueWithoutCreatorInput | MeetingUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: MeetingCreateManyCreatorInputEnvelope
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    update?: MeetingUpdateWithWhereUniqueWithoutCreatorInput | MeetingUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: MeetingUpdateManyWithWhereWithoutCreatorInput | MeetingUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
  }

  export type EmployeeShiftUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeShiftCreateWithoutEmployeeInput, EmployeeShiftUncheckedCreateWithoutEmployeeInput> | EmployeeShiftCreateWithoutEmployeeInput[] | EmployeeShiftUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeShiftCreateOrConnectWithoutEmployeeInput | EmployeeShiftCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeShiftUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeShiftUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeShiftCreateManyEmployeeInputEnvelope
    set?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    disconnect?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    delete?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    connect?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    update?: EmployeeShiftUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeShiftUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeShiftUpdateManyWithWhereWithoutEmployeeInput | EmployeeShiftUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeShiftScalarWhereInput | EmployeeShiftScalarWhereInput[]
  }

  export type AttendanceLogUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AttendanceLogCreateWithoutEmployeeInput, AttendanceLogUncheckedCreateWithoutEmployeeInput> | AttendanceLogCreateWithoutEmployeeInput[] | AttendanceLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceLogCreateOrConnectWithoutEmployeeInput | AttendanceLogCreateOrConnectWithoutEmployeeInput[]
    upsert?: AttendanceLogUpsertWithWhereUniqueWithoutEmployeeInput | AttendanceLogUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AttendanceLogCreateManyEmployeeInputEnvelope
    set?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    disconnect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    delete?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    connect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    update?: AttendanceLogUpdateWithWhereUniqueWithoutEmployeeInput | AttendanceLogUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AttendanceLogUpdateManyWithWhereWithoutEmployeeInput | AttendanceLogUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AttendanceLogScalarWhereInput | AttendanceLogScalarWhereInput[]
  }

  export type AttendanceSummaryUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AttendanceSummaryCreateWithoutEmployeeInput, AttendanceSummaryUncheckedCreateWithoutEmployeeInput> | AttendanceSummaryCreateWithoutEmployeeInput[] | AttendanceSummaryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceSummaryCreateOrConnectWithoutEmployeeInput | AttendanceSummaryCreateOrConnectWithoutEmployeeInput[]
    upsert?: AttendanceSummaryUpsertWithWhereUniqueWithoutEmployeeInput | AttendanceSummaryUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AttendanceSummaryCreateManyEmployeeInputEnvelope
    set?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    disconnect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    delete?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    connect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    update?: AttendanceSummaryUpdateWithWhereUniqueWithoutEmployeeInput | AttendanceSummaryUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AttendanceSummaryUpdateManyWithWhereWithoutEmployeeInput | AttendanceSummaryUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AttendanceSummaryScalarWhereInput | AttendanceSummaryScalarWhereInput[]
  }

  export type LeaveUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LeaveCreateWithoutEmployeeInput, LeaveUncheckedCreateWithoutEmployeeInput> | LeaveCreateWithoutEmployeeInput[] | LeaveUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutEmployeeInput | LeaveCreateOrConnectWithoutEmployeeInput[]
    upsert?: LeaveUpsertWithWhereUniqueWithoutEmployeeInput | LeaveUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LeaveCreateManyEmployeeInputEnvelope
    set?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    disconnect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    delete?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    update?: LeaveUpdateWithWhereUniqueWithoutEmployeeInput | LeaveUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LeaveUpdateManyWithWhereWithoutEmployeeInput | LeaveUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
  }

  export type ComplaintUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<ComplaintCreateWithoutEmployeeInput, ComplaintUncheckedCreateWithoutEmployeeInput> | ComplaintCreateWithoutEmployeeInput[] | ComplaintUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutEmployeeInput | ComplaintCreateOrConnectWithoutEmployeeInput[]
    upsert?: ComplaintUpsertWithWhereUniqueWithoutEmployeeInput | ComplaintUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: ComplaintCreateManyEmployeeInputEnvelope
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    update?: ComplaintUpdateWithWhereUniqueWithoutEmployeeInput | ComplaintUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: ComplaintUpdateManyWithWhereWithoutEmployeeInput | ComplaintUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
  }

  export type PerformanceReviewUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PerformanceReviewCreateWithoutEmployeeInput, PerformanceReviewUncheckedCreateWithoutEmployeeInput> | PerformanceReviewCreateWithoutEmployeeInput[] | PerformanceReviewUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PerformanceReviewCreateOrConnectWithoutEmployeeInput | PerformanceReviewCreateOrConnectWithoutEmployeeInput[]
    upsert?: PerformanceReviewUpsertWithWhereUniqueWithoutEmployeeInput | PerformanceReviewUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PerformanceReviewCreateManyEmployeeInputEnvelope
    set?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    disconnect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    delete?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    connect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    update?: PerformanceReviewUpdateWithWhereUniqueWithoutEmployeeInput | PerformanceReviewUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PerformanceReviewUpdateManyWithWhereWithoutEmployeeInput | PerformanceReviewUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PerformanceReviewScalarWhereInput | PerformanceReviewScalarWhereInput[]
  }

  export type TerminationUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<TerminationCreateWithoutEmployeeInput, TerminationUncheckedCreateWithoutEmployeeInput> | TerminationCreateWithoutEmployeeInput[] | TerminationUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: TerminationCreateOrConnectWithoutEmployeeInput | TerminationCreateOrConnectWithoutEmployeeInput[]
    upsert?: TerminationUpsertWithWhereUniqueWithoutEmployeeInput | TerminationUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: TerminationCreateManyEmployeeInputEnvelope
    set?: TerminationWhereUniqueInput | TerminationWhereUniqueInput[]
    disconnect?: TerminationWhereUniqueInput | TerminationWhereUniqueInput[]
    delete?: TerminationWhereUniqueInput | TerminationWhereUniqueInput[]
    connect?: TerminationWhereUniqueInput | TerminationWhereUniqueInput[]
    update?: TerminationUpdateWithWhereUniqueWithoutEmployeeInput | TerminationUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: TerminationUpdateManyWithWhereWithoutEmployeeInput | TerminationUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: TerminationScalarWhereInput | TerminationScalarWhereInput[]
  }

  export type SalaryUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<SalaryCreateWithoutEmployeeInput, SalaryUncheckedCreateWithoutEmployeeInput> | SalaryCreateWithoutEmployeeInput[] | SalaryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SalaryCreateOrConnectWithoutEmployeeInput | SalaryCreateOrConnectWithoutEmployeeInput[]
    upsert?: SalaryUpsertWithWhereUniqueWithoutEmployeeInput | SalaryUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: SalaryCreateManyEmployeeInputEnvelope
    set?: SalaryWhereUniqueInput | SalaryWhereUniqueInput[]
    disconnect?: SalaryWhereUniqueInput | SalaryWhereUniqueInput[]
    delete?: SalaryWhereUniqueInput | SalaryWhereUniqueInput[]
    connect?: SalaryWhereUniqueInput | SalaryWhereUniqueInput[]
    update?: SalaryUpdateWithWhereUniqueWithoutEmployeeInput | SalaryUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: SalaryUpdateManyWithWhereWithoutEmployeeInput | SalaryUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: SalaryScalarWhereInput | SalaryScalarWhereInput[]
  }

  export type OvertimeLogUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<OvertimeLogCreateWithoutEmployeeInput, OvertimeLogUncheckedCreateWithoutEmployeeInput> | OvertimeLogCreateWithoutEmployeeInput[] | OvertimeLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: OvertimeLogCreateOrConnectWithoutEmployeeInput | OvertimeLogCreateOrConnectWithoutEmployeeInput[]
    upsert?: OvertimeLogUpsertWithWhereUniqueWithoutEmployeeInput | OvertimeLogUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: OvertimeLogCreateManyEmployeeInputEnvelope
    set?: OvertimeLogWhereUniqueInput | OvertimeLogWhereUniqueInput[]
    disconnect?: OvertimeLogWhereUniqueInput | OvertimeLogWhereUniqueInput[]
    delete?: OvertimeLogWhereUniqueInput | OvertimeLogWhereUniqueInput[]
    connect?: OvertimeLogWhereUniqueInput | OvertimeLogWhereUniqueInput[]
    update?: OvertimeLogUpdateWithWhereUniqueWithoutEmployeeInput | OvertimeLogUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: OvertimeLogUpdateManyWithWhereWithoutEmployeeInput | OvertimeLogUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: OvertimeLogScalarWhereInput | OvertimeLogScalarWhereInput[]
  }

  export type MeetingUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<MeetingCreateWithoutCreatorInput, MeetingUncheckedCreateWithoutCreatorInput> | MeetingCreateWithoutCreatorInput[] | MeetingUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutCreatorInput | MeetingCreateOrConnectWithoutCreatorInput[]
    upsert?: MeetingUpsertWithWhereUniqueWithoutCreatorInput | MeetingUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: MeetingCreateManyCreatorInputEnvelope
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    update?: MeetingUpdateWithWhereUniqueWithoutCreatorInput | MeetingUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: MeetingUpdateManyWithWhereWithoutCreatorInput | MeetingUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
  }

  export type EmployeeShiftUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeShiftCreateWithoutEmployeeInput, EmployeeShiftUncheckedCreateWithoutEmployeeInput> | EmployeeShiftCreateWithoutEmployeeInput[] | EmployeeShiftUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeShiftCreateOrConnectWithoutEmployeeInput | EmployeeShiftCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeShiftUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeShiftUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeShiftCreateManyEmployeeInputEnvelope
    set?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    disconnect?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    delete?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    connect?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    update?: EmployeeShiftUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeShiftUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeShiftUpdateManyWithWhereWithoutEmployeeInput | EmployeeShiftUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeShiftScalarWhereInput | EmployeeShiftScalarWhereInput[]
  }

  export type AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AttendanceLogCreateWithoutEmployeeInput, AttendanceLogUncheckedCreateWithoutEmployeeInput> | AttendanceLogCreateWithoutEmployeeInput[] | AttendanceLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceLogCreateOrConnectWithoutEmployeeInput | AttendanceLogCreateOrConnectWithoutEmployeeInput[]
    upsert?: AttendanceLogUpsertWithWhereUniqueWithoutEmployeeInput | AttendanceLogUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AttendanceLogCreateManyEmployeeInputEnvelope
    set?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    disconnect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    delete?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    connect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    update?: AttendanceLogUpdateWithWhereUniqueWithoutEmployeeInput | AttendanceLogUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AttendanceLogUpdateManyWithWhereWithoutEmployeeInput | AttendanceLogUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AttendanceLogScalarWhereInput | AttendanceLogScalarWhereInput[]
  }

  export type AttendanceSummaryUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AttendanceSummaryCreateWithoutEmployeeInput, AttendanceSummaryUncheckedCreateWithoutEmployeeInput> | AttendanceSummaryCreateWithoutEmployeeInput[] | AttendanceSummaryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceSummaryCreateOrConnectWithoutEmployeeInput | AttendanceSummaryCreateOrConnectWithoutEmployeeInput[]
    upsert?: AttendanceSummaryUpsertWithWhereUniqueWithoutEmployeeInput | AttendanceSummaryUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AttendanceSummaryCreateManyEmployeeInputEnvelope
    set?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    disconnect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    delete?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    connect?: AttendanceSummaryWhereUniqueInput | AttendanceSummaryWhereUniqueInput[]
    update?: AttendanceSummaryUpdateWithWhereUniqueWithoutEmployeeInput | AttendanceSummaryUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AttendanceSummaryUpdateManyWithWhereWithoutEmployeeInput | AttendanceSummaryUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AttendanceSummaryScalarWhereInput | AttendanceSummaryScalarWhereInput[]
  }

  export type LeaveUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LeaveCreateWithoutEmployeeInput, LeaveUncheckedCreateWithoutEmployeeInput> | LeaveCreateWithoutEmployeeInput[] | LeaveUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutEmployeeInput | LeaveCreateOrConnectWithoutEmployeeInput[]
    upsert?: LeaveUpsertWithWhereUniqueWithoutEmployeeInput | LeaveUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LeaveCreateManyEmployeeInputEnvelope
    set?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    disconnect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    delete?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    update?: LeaveUpdateWithWhereUniqueWithoutEmployeeInput | LeaveUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LeaveUpdateManyWithWhereWithoutEmployeeInput | LeaveUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
  }

  export type ComplaintUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<ComplaintCreateWithoutEmployeeInput, ComplaintUncheckedCreateWithoutEmployeeInput> | ComplaintCreateWithoutEmployeeInput[] | ComplaintUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutEmployeeInput | ComplaintCreateOrConnectWithoutEmployeeInput[]
    upsert?: ComplaintUpsertWithWhereUniqueWithoutEmployeeInput | ComplaintUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: ComplaintCreateManyEmployeeInputEnvelope
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    update?: ComplaintUpdateWithWhereUniqueWithoutEmployeeInput | ComplaintUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: ComplaintUpdateManyWithWhereWithoutEmployeeInput | ComplaintUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
  }

  export type PerformanceReviewUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PerformanceReviewCreateWithoutEmployeeInput, PerformanceReviewUncheckedCreateWithoutEmployeeInput> | PerformanceReviewCreateWithoutEmployeeInput[] | PerformanceReviewUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PerformanceReviewCreateOrConnectWithoutEmployeeInput | PerformanceReviewCreateOrConnectWithoutEmployeeInput[]
    upsert?: PerformanceReviewUpsertWithWhereUniqueWithoutEmployeeInput | PerformanceReviewUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PerformanceReviewCreateManyEmployeeInputEnvelope
    set?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    disconnect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    delete?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    connect?: PerformanceReviewWhereUniqueInput | PerformanceReviewWhereUniqueInput[]
    update?: PerformanceReviewUpdateWithWhereUniqueWithoutEmployeeInput | PerformanceReviewUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PerformanceReviewUpdateManyWithWhereWithoutEmployeeInput | PerformanceReviewUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PerformanceReviewScalarWhereInput | PerformanceReviewScalarWhereInput[]
  }

  export type TerminationUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<TerminationCreateWithoutEmployeeInput, TerminationUncheckedCreateWithoutEmployeeInput> | TerminationCreateWithoutEmployeeInput[] | TerminationUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: TerminationCreateOrConnectWithoutEmployeeInput | TerminationCreateOrConnectWithoutEmployeeInput[]
    upsert?: TerminationUpsertWithWhereUniqueWithoutEmployeeInput | TerminationUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: TerminationCreateManyEmployeeInputEnvelope
    set?: TerminationWhereUniqueInput | TerminationWhereUniqueInput[]
    disconnect?: TerminationWhereUniqueInput | TerminationWhereUniqueInput[]
    delete?: TerminationWhereUniqueInput | TerminationWhereUniqueInput[]
    connect?: TerminationWhereUniqueInput | TerminationWhereUniqueInput[]
    update?: TerminationUpdateWithWhereUniqueWithoutEmployeeInput | TerminationUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: TerminationUpdateManyWithWhereWithoutEmployeeInput | TerminationUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: TerminationScalarWhereInput | TerminationScalarWhereInput[]
  }

  export type SalaryUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<SalaryCreateWithoutEmployeeInput, SalaryUncheckedCreateWithoutEmployeeInput> | SalaryCreateWithoutEmployeeInput[] | SalaryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SalaryCreateOrConnectWithoutEmployeeInput | SalaryCreateOrConnectWithoutEmployeeInput[]
    upsert?: SalaryUpsertWithWhereUniqueWithoutEmployeeInput | SalaryUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: SalaryCreateManyEmployeeInputEnvelope
    set?: SalaryWhereUniqueInput | SalaryWhereUniqueInput[]
    disconnect?: SalaryWhereUniqueInput | SalaryWhereUniqueInput[]
    delete?: SalaryWhereUniqueInput | SalaryWhereUniqueInput[]
    connect?: SalaryWhereUniqueInput | SalaryWhereUniqueInput[]
    update?: SalaryUpdateWithWhereUniqueWithoutEmployeeInput | SalaryUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: SalaryUpdateManyWithWhereWithoutEmployeeInput | SalaryUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: SalaryScalarWhereInput | SalaryScalarWhereInput[]
  }

  export type OvertimeLogUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<OvertimeLogCreateWithoutEmployeeInput, OvertimeLogUncheckedCreateWithoutEmployeeInput> | OvertimeLogCreateWithoutEmployeeInput[] | OvertimeLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: OvertimeLogCreateOrConnectWithoutEmployeeInput | OvertimeLogCreateOrConnectWithoutEmployeeInput[]
    upsert?: OvertimeLogUpsertWithWhereUniqueWithoutEmployeeInput | OvertimeLogUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: OvertimeLogCreateManyEmployeeInputEnvelope
    set?: OvertimeLogWhereUniqueInput | OvertimeLogWhereUniqueInput[]
    disconnect?: OvertimeLogWhereUniqueInput | OvertimeLogWhereUniqueInput[]
    delete?: OvertimeLogWhereUniqueInput | OvertimeLogWhereUniqueInput[]
    connect?: OvertimeLogWhereUniqueInput | OvertimeLogWhereUniqueInput[]
    update?: OvertimeLogUpdateWithWhereUniqueWithoutEmployeeInput | OvertimeLogUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: OvertimeLogUpdateManyWithWhereWithoutEmployeeInput | OvertimeLogUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: OvertimeLogScalarWhereInput | OvertimeLogScalarWhereInput[]
  }

  export type EmployeeShiftCreateNestedManyWithoutShiftInput = {
    create?: XOR<EmployeeShiftCreateWithoutShiftInput, EmployeeShiftUncheckedCreateWithoutShiftInput> | EmployeeShiftCreateWithoutShiftInput[] | EmployeeShiftUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: EmployeeShiftCreateOrConnectWithoutShiftInput | EmployeeShiftCreateOrConnectWithoutShiftInput[]
    createMany?: EmployeeShiftCreateManyShiftInputEnvelope
    connect?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
  }

  export type EmployeeShiftUncheckedCreateNestedManyWithoutShiftInput = {
    create?: XOR<EmployeeShiftCreateWithoutShiftInput, EmployeeShiftUncheckedCreateWithoutShiftInput> | EmployeeShiftCreateWithoutShiftInput[] | EmployeeShiftUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: EmployeeShiftCreateOrConnectWithoutShiftInput | EmployeeShiftCreateOrConnectWithoutShiftInput[]
    createMany?: EmployeeShiftCreateManyShiftInputEnvelope
    connect?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
  }

  export type EmployeeShiftUpdateManyWithoutShiftNestedInput = {
    create?: XOR<EmployeeShiftCreateWithoutShiftInput, EmployeeShiftUncheckedCreateWithoutShiftInput> | EmployeeShiftCreateWithoutShiftInput[] | EmployeeShiftUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: EmployeeShiftCreateOrConnectWithoutShiftInput | EmployeeShiftCreateOrConnectWithoutShiftInput[]
    upsert?: EmployeeShiftUpsertWithWhereUniqueWithoutShiftInput | EmployeeShiftUpsertWithWhereUniqueWithoutShiftInput[]
    createMany?: EmployeeShiftCreateManyShiftInputEnvelope
    set?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    disconnect?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    delete?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    connect?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    update?: EmployeeShiftUpdateWithWhereUniqueWithoutShiftInput | EmployeeShiftUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: EmployeeShiftUpdateManyWithWhereWithoutShiftInput | EmployeeShiftUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: EmployeeShiftScalarWhereInput | EmployeeShiftScalarWhereInput[]
  }

  export type EmployeeShiftUncheckedUpdateManyWithoutShiftNestedInput = {
    create?: XOR<EmployeeShiftCreateWithoutShiftInput, EmployeeShiftUncheckedCreateWithoutShiftInput> | EmployeeShiftCreateWithoutShiftInput[] | EmployeeShiftUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: EmployeeShiftCreateOrConnectWithoutShiftInput | EmployeeShiftCreateOrConnectWithoutShiftInput[]
    upsert?: EmployeeShiftUpsertWithWhereUniqueWithoutShiftInput | EmployeeShiftUpsertWithWhereUniqueWithoutShiftInput[]
    createMany?: EmployeeShiftCreateManyShiftInputEnvelope
    set?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    disconnect?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    delete?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    connect?: EmployeeShiftWhereUniqueInput | EmployeeShiftWhereUniqueInput[]
    update?: EmployeeShiftUpdateWithWhereUniqueWithoutShiftInput | EmployeeShiftUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: EmployeeShiftUpdateManyWithWhereWithoutShiftInput | EmployeeShiftUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: EmployeeShiftScalarWhereInput | EmployeeShiftScalarWhereInput[]
  }

  export type EmployeeCreateNestedOneWithoutShiftsInput = {
    create?: XOR<EmployeeCreateWithoutShiftsInput, EmployeeUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutShiftsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type ShiftCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<ShiftCreateWithoutAssignmentsInput, ShiftUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ShiftCreateOrConnectWithoutAssignmentsInput
    connect?: ShiftWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutShiftsNestedInput = {
    create?: XOR<EmployeeCreateWithoutShiftsInput, EmployeeUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutShiftsInput
    upsert?: EmployeeUpsertWithoutShiftsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutShiftsInput, EmployeeUpdateWithoutShiftsInput>, EmployeeUncheckedUpdateWithoutShiftsInput>
  }

  export type ShiftUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<ShiftCreateWithoutAssignmentsInput, ShiftUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ShiftCreateOrConnectWithoutAssignmentsInput
    upsert?: ShiftUpsertWithoutAssignmentsInput
    connect?: ShiftWhereUniqueInput
    update?: XOR<XOR<ShiftUpdateToOneWithWhereWithoutAssignmentsInput, ShiftUpdateWithoutAssignmentsInput>, ShiftUncheckedUpdateWithoutAssignmentsInput>
  }

  export type AttendanceLogCreateNestedManyWithoutSessionInput = {
    create?: XOR<AttendanceLogCreateWithoutSessionInput, AttendanceLogUncheckedCreateWithoutSessionInput> | AttendanceLogCreateWithoutSessionInput[] | AttendanceLogUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AttendanceLogCreateOrConnectWithoutSessionInput | AttendanceLogCreateOrConnectWithoutSessionInput[]
    createMany?: AttendanceLogCreateManySessionInputEnvelope
    connect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
  }

  export type AttendanceLogUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<AttendanceLogCreateWithoutSessionInput, AttendanceLogUncheckedCreateWithoutSessionInput> | AttendanceLogCreateWithoutSessionInput[] | AttendanceLogUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AttendanceLogCreateOrConnectWithoutSessionInput | AttendanceLogCreateOrConnectWithoutSessionInput[]
    createMany?: AttendanceLogCreateManySessionInputEnvelope
    connect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
  }

  export type AttendanceLogUpdateManyWithoutSessionNestedInput = {
    create?: XOR<AttendanceLogCreateWithoutSessionInput, AttendanceLogUncheckedCreateWithoutSessionInput> | AttendanceLogCreateWithoutSessionInput[] | AttendanceLogUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AttendanceLogCreateOrConnectWithoutSessionInput | AttendanceLogCreateOrConnectWithoutSessionInput[]
    upsert?: AttendanceLogUpsertWithWhereUniqueWithoutSessionInput | AttendanceLogUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: AttendanceLogCreateManySessionInputEnvelope
    set?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    disconnect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    delete?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    connect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    update?: AttendanceLogUpdateWithWhereUniqueWithoutSessionInput | AttendanceLogUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: AttendanceLogUpdateManyWithWhereWithoutSessionInput | AttendanceLogUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: AttendanceLogScalarWhereInput | AttendanceLogScalarWhereInput[]
  }

  export type AttendanceLogUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<AttendanceLogCreateWithoutSessionInput, AttendanceLogUncheckedCreateWithoutSessionInput> | AttendanceLogCreateWithoutSessionInput[] | AttendanceLogUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AttendanceLogCreateOrConnectWithoutSessionInput | AttendanceLogCreateOrConnectWithoutSessionInput[]
    upsert?: AttendanceLogUpsertWithWhereUniqueWithoutSessionInput | AttendanceLogUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: AttendanceLogCreateManySessionInputEnvelope
    set?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    disconnect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    delete?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    connect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    update?: AttendanceLogUpdateWithWhereUniqueWithoutSessionInput | AttendanceLogUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: AttendanceLogUpdateManyWithWhereWithoutSessionInput | AttendanceLogUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: AttendanceLogScalarWhereInput | AttendanceLogScalarWhereInput[]
  }

  export type EmployeeCreateNestedOneWithoutAttendanceLogsInput = {
    create?: XOR<EmployeeCreateWithoutAttendanceLogsInput, EmployeeUncheckedCreateWithoutAttendanceLogsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAttendanceLogsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type SessionDefinitionCreateNestedOneWithoutLogsInput = {
    create?: XOR<SessionDefinitionCreateWithoutLogsInput, SessionDefinitionUncheckedCreateWithoutLogsInput>
    connectOrCreate?: SessionDefinitionCreateOrConnectWithoutLogsInput
    connect?: SessionDefinitionWhereUniqueInput
  }

  export type EnumAttendanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.AttendanceStatus
  }

  export type EmployeeUpdateOneRequiredWithoutAttendanceLogsNestedInput = {
    create?: XOR<EmployeeCreateWithoutAttendanceLogsInput, EmployeeUncheckedCreateWithoutAttendanceLogsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAttendanceLogsInput
    upsert?: EmployeeUpsertWithoutAttendanceLogsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutAttendanceLogsInput, EmployeeUpdateWithoutAttendanceLogsInput>, EmployeeUncheckedUpdateWithoutAttendanceLogsInput>
  }

  export type SessionDefinitionUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<SessionDefinitionCreateWithoutLogsInput, SessionDefinitionUncheckedCreateWithoutLogsInput>
    connectOrCreate?: SessionDefinitionCreateOrConnectWithoutLogsInput
    upsert?: SessionDefinitionUpsertWithoutLogsInput
    connect?: SessionDefinitionWhereUniqueInput
    update?: XOR<XOR<SessionDefinitionUpdateToOneWithWhereWithoutLogsInput, SessionDefinitionUpdateWithoutLogsInput>, SessionDefinitionUncheckedUpdateWithoutLogsInput>
  }

  export type EmployeeCreateNestedOneWithoutAttendanceSummariesInput = {
    create?: XOR<EmployeeCreateWithoutAttendanceSummariesInput, EmployeeUncheckedCreateWithoutAttendanceSummariesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAttendanceSummariesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutAttendanceSummariesInput = {
    create?: XOR<DepartmentCreateWithoutAttendanceSummariesInput, DepartmentUncheckedCreateWithoutAttendanceSummariesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutAttendanceSummariesInput
    connect?: DepartmentWhereUniqueInput
  }

  export type EnumSummaryStatusFieldUpdateOperationsInput = {
    set?: $Enums.SummaryStatus
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EmployeeUpdateOneRequiredWithoutAttendanceSummariesNestedInput = {
    create?: XOR<EmployeeCreateWithoutAttendanceSummariesInput, EmployeeUncheckedCreateWithoutAttendanceSummariesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAttendanceSummariesInput
    upsert?: EmployeeUpsertWithoutAttendanceSummariesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutAttendanceSummariesInput, EmployeeUpdateWithoutAttendanceSummariesInput>, EmployeeUncheckedUpdateWithoutAttendanceSummariesInput>
  }

  export type DepartmentUpdateOneWithoutAttendanceSummariesNestedInput = {
    create?: XOR<DepartmentCreateWithoutAttendanceSummariesInput, DepartmentUncheckedCreateWithoutAttendanceSummariesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutAttendanceSummariesInput
    upsert?: DepartmentUpsertWithoutAttendanceSummariesInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutAttendanceSummariesInput, DepartmentUpdateWithoutAttendanceSummariesInput>, DepartmentUncheckedUpdateWithoutAttendanceSummariesInput>
  }

  export type EmployeeCreateNestedOneWithoutLeavesInput = {
    create?: XOR<EmployeeCreateWithoutLeavesInput, EmployeeUncheckedCreateWithoutLeavesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLeavesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovedLeavesInput = {
    create?: XOR<UserCreateWithoutApprovedLeavesInput, UserUncheckedCreateWithoutApprovedLeavesInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedLeavesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumLeaveTypeFieldUpdateOperationsInput = {
    set?: $Enums.LeaveType
  }

  export type EnumLeaveStatusFieldUpdateOperationsInput = {
    set?: $Enums.LeaveStatus
  }

  export type EmployeeUpdateOneRequiredWithoutLeavesNestedInput = {
    create?: XOR<EmployeeCreateWithoutLeavesInput, EmployeeUncheckedCreateWithoutLeavesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLeavesInput
    upsert?: EmployeeUpsertWithoutLeavesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutLeavesInput, EmployeeUpdateWithoutLeavesInput>, EmployeeUncheckedUpdateWithoutLeavesInput>
  }

  export type UserUpdateOneWithoutApprovedLeavesNestedInput = {
    create?: XOR<UserCreateWithoutApprovedLeavesInput, UserUncheckedCreateWithoutApprovedLeavesInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedLeavesInput
    upsert?: UserUpsertWithoutApprovedLeavesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedLeavesInput, UserUpdateWithoutApprovedLeavesInput>, UserUncheckedUpdateWithoutApprovedLeavesInput>
  }

  export type EmployeeCreateNestedOneWithoutOvertimesInput = {
    create?: XOR<EmployeeCreateWithoutOvertimesInput, EmployeeUncheckedCreateWithoutOvertimesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutOvertimesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovedOvertimesInput = {
    create?: XOR<UserCreateWithoutApprovedOvertimesInput, UserUncheckedCreateWithoutApprovedOvertimesInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedOvertimesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumOvertimeApprovalStatusFieldUpdateOperationsInput = {
    set?: $Enums.OvertimeApprovalStatus
  }

  export type EnumCompensationMethodFieldUpdateOperationsInput = {
    set?: $Enums.CompensationMethod
  }

  export type EmployeeUpdateOneRequiredWithoutOvertimesNestedInput = {
    create?: XOR<EmployeeCreateWithoutOvertimesInput, EmployeeUncheckedCreateWithoutOvertimesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutOvertimesInput
    upsert?: EmployeeUpsertWithoutOvertimesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutOvertimesInput, EmployeeUpdateWithoutOvertimesInput>, EmployeeUncheckedUpdateWithoutOvertimesInput>
  }

  export type UserUpdateOneWithoutApprovedOvertimesNestedInput = {
    create?: XOR<UserCreateWithoutApprovedOvertimesInput, UserUncheckedCreateWithoutApprovedOvertimesInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedOvertimesInput
    upsert?: UserUpsertWithoutApprovedOvertimesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedOvertimesInput, UserUpdateWithoutApprovedOvertimesInput>, UserUncheckedUpdateWithoutApprovedOvertimesInput>
  }

  export type EmployeeCreateNestedOneWithoutSalariesInput = {
    create?: XOR<EmployeeCreateWithoutSalariesInput, EmployeeUncheckedCreateWithoutSalariesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutSalariesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EnumSalaryStatusFieldUpdateOperationsInput = {
    set?: $Enums.SalaryStatus
  }

  export type EmployeeUpdateOneRequiredWithoutSalariesNestedInput = {
    create?: XOR<EmployeeCreateWithoutSalariesInput, EmployeeUncheckedCreateWithoutSalariesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutSalariesInput
    upsert?: EmployeeUpsertWithoutSalariesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutSalariesInput, EmployeeUpdateWithoutSalariesInput>, EmployeeUncheckedUpdateWithoutSalariesInput>
  }

  export type EmployeeCreateNestedOneWithoutComplaintsInput = {
    create?: XOR<EmployeeCreateWithoutComplaintsInput, EmployeeUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutComplaintsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EnumComplaintStatusFieldUpdateOperationsInput = {
    set?: $Enums.ComplaintStatus
  }

  export type EmployeeUpdateOneRequiredWithoutComplaintsNestedInput = {
    create?: XOR<EmployeeCreateWithoutComplaintsInput, EmployeeUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutComplaintsInput
    upsert?: EmployeeUpsertWithoutComplaintsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutComplaintsInput, EmployeeUpdateWithoutComplaintsInput>, EmployeeUncheckedUpdateWithoutComplaintsInput>
  }

  export type EnumInterviewResultFieldUpdateOperationsInput = {
    set?: $Enums.InterviewResult
  }

  export type EmployeeCreateNestedOneWithoutPerformanceReviewsInput = {
    create?: XOR<EmployeeCreateWithoutPerformanceReviewsInput, EmployeeUncheckedCreateWithoutPerformanceReviewsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPerformanceReviewsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutPerformanceReviewsNestedInput = {
    create?: XOR<EmployeeCreateWithoutPerformanceReviewsInput, EmployeeUncheckedCreateWithoutPerformanceReviewsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPerformanceReviewsInput
    upsert?: EmployeeUpsertWithoutPerformanceReviewsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutPerformanceReviewsInput, EmployeeUpdateWithoutPerformanceReviewsInput>, EmployeeUncheckedUpdateWithoutPerformanceReviewsInput>
  }

  export type EmployeeCreateNestedOneWithoutTerminationsInput = {
    create?: XOR<EmployeeCreateWithoutTerminationsInput, EmployeeUncheckedCreateWithoutTerminationsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutTerminationsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EnumTerminationStatusFieldUpdateOperationsInput = {
    set?: $Enums.TerminationStatus
  }

  export type EnumWorkflowStatusFieldUpdateOperationsInput = {
    set?: $Enums.WorkflowStatus
  }

  export type EmployeeUpdateOneRequiredWithoutTerminationsNestedInput = {
    create?: XOR<EmployeeCreateWithoutTerminationsInput, EmployeeUncheckedCreateWithoutTerminationsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutTerminationsInput
    upsert?: EmployeeUpsertWithoutTerminationsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutTerminationsInput, EmployeeUpdateWithoutTerminationsInput>, EmployeeUncheckedUpdateWithoutTerminationsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumSexFilter<$PrismaModel = never> = {
    equals?: $Enums.Sex | EnumSexFieldRefInput<$PrismaModel>
    in?: $Enums.Sex[]
    notIn?: $Enums.Sex[]
    not?: NestedEnumSexFilter<$PrismaModel> | $Enums.Sex
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumSexWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sex | EnumSexFieldRefInput<$PrismaModel>
    in?: $Enums.Sex[]
    notIn?: $Enums.Sex[]
    not?: NestedEnumSexWithAggregatesFilter<$PrismaModel> | $Enums.Sex
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSexFilter<$PrismaModel>
    _max?: NestedEnumSexFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[]
    notIn?: $Enums.AttendanceStatus[]
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[]
    notIn?: $Enums.AttendanceStatus[]
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type NestedEnumSummaryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SummaryStatus | EnumSummaryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SummaryStatus[]
    notIn?: $Enums.SummaryStatus[]
    not?: NestedEnumSummaryStatusFilter<$PrismaModel> | $Enums.SummaryStatus
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumSummaryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SummaryStatus | EnumSummaryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SummaryStatus[]
    notIn?: $Enums.SummaryStatus[]
    not?: NestedEnumSummaryStatusWithAggregatesFilter<$PrismaModel> | $Enums.SummaryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSummaryStatusFilter<$PrismaModel>
    _max?: NestedEnumSummaryStatusFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumLeaveTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[]
    notIn?: $Enums.LeaveType[]
    not?: NestedEnumLeaveTypeFilter<$PrismaModel> | $Enums.LeaveType
  }

  export type NestedEnumLeaveStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[]
    notIn?: $Enums.LeaveStatus[]
    not?: NestedEnumLeaveStatusFilter<$PrismaModel> | $Enums.LeaveStatus
  }

  export type NestedEnumLeaveTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveType | EnumLeaveTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveType[]
    notIn?: $Enums.LeaveType[]
    not?: NestedEnumLeaveTypeWithAggregatesFilter<$PrismaModel> | $Enums.LeaveType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveTypeFilter<$PrismaModel>
    _max?: NestedEnumLeaveTypeFilter<$PrismaModel>
  }

  export type NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[]
    notIn?: $Enums.LeaveStatus[]
    not?: NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeaveStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveStatusFilter<$PrismaModel>
    _max?: NestedEnumLeaveStatusFilter<$PrismaModel>
  }

  export type NestedEnumOvertimeApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OvertimeApprovalStatus | EnumOvertimeApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OvertimeApprovalStatus[]
    notIn?: $Enums.OvertimeApprovalStatus[]
    not?: NestedEnumOvertimeApprovalStatusFilter<$PrismaModel> | $Enums.OvertimeApprovalStatus
  }

  export type NestedEnumCompensationMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.CompensationMethod | EnumCompensationMethodFieldRefInput<$PrismaModel>
    in?: $Enums.CompensationMethod[]
    notIn?: $Enums.CompensationMethod[]
    not?: NestedEnumCompensationMethodFilter<$PrismaModel> | $Enums.CompensationMethod
  }

  export type NestedEnumOvertimeApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OvertimeApprovalStatus | EnumOvertimeApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OvertimeApprovalStatus[]
    notIn?: $Enums.OvertimeApprovalStatus[]
    not?: NestedEnumOvertimeApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.OvertimeApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOvertimeApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumOvertimeApprovalStatusFilter<$PrismaModel>
  }

  export type NestedEnumCompensationMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompensationMethod | EnumCompensationMethodFieldRefInput<$PrismaModel>
    in?: $Enums.CompensationMethod[]
    notIn?: $Enums.CompensationMethod[]
    not?: NestedEnumCompensationMethodWithAggregatesFilter<$PrismaModel> | $Enums.CompensationMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompensationMethodFilter<$PrismaModel>
    _max?: NestedEnumCompensationMethodFilter<$PrismaModel>
  }

  export type NestedEnumSalaryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SalaryStatus | EnumSalaryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SalaryStatus[]
    notIn?: $Enums.SalaryStatus[]
    not?: NestedEnumSalaryStatusFilter<$PrismaModel> | $Enums.SalaryStatus
  }

  export type NestedEnumSalaryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SalaryStatus | EnumSalaryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SalaryStatus[]
    notIn?: $Enums.SalaryStatus[]
    not?: NestedEnumSalaryStatusWithAggregatesFilter<$PrismaModel> | $Enums.SalaryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSalaryStatusFilter<$PrismaModel>
    _max?: NestedEnumSalaryStatusFilter<$PrismaModel>
  }

  export type NestedEnumComplaintStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintStatus | EnumComplaintStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintStatus[]
    notIn?: $Enums.ComplaintStatus[]
    not?: NestedEnumComplaintStatusFilter<$PrismaModel> | $Enums.ComplaintStatus
  }

  export type NestedEnumComplaintStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplaintStatus | EnumComplaintStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplaintStatus[]
    notIn?: $Enums.ComplaintStatus[]
    not?: NestedEnumComplaintStatusWithAggregatesFilter<$PrismaModel> | $Enums.ComplaintStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplaintStatusFilter<$PrismaModel>
    _max?: NestedEnumComplaintStatusFilter<$PrismaModel>
  }

  export type NestedEnumInterviewResultFilter<$PrismaModel = never> = {
    equals?: $Enums.InterviewResult | EnumInterviewResultFieldRefInput<$PrismaModel>
    in?: $Enums.InterviewResult[]
    notIn?: $Enums.InterviewResult[]
    not?: NestedEnumInterviewResultFilter<$PrismaModel> | $Enums.InterviewResult
  }

  export type NestedEnumInterviewResultWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InterviewResult | EnumInterviewResultFieldRefInput<$PrismaModel>
    in?: $Enums.InterviewResult[]
    notIn?: $Enums.InterviewResult[]
    not?: NestedEnumInterviewResultWithAggregatesFilter<$PrismaModel> | $Enums.InterviewResult
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInterviewResultFilter<$PrismaModel>
    _max?: NestedEnumInterviewResultFilter<$PrismaModel>
  }

  export type NestedEnumTerminationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TerminationStatus | EnumTerminationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TerminationStatus[]
    notIn?: $Enums.TerminationStatus[]
    not?: NestedEnumTerminationStatusFilter<$PrismaModel> | $Enums.TerminationStatus
  }

  export type NestedEnumWorkflowStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStatus | EnumWorkflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStatus[]
    notIn?: $Enums.WorkflowStatus[]
    not?: NestedEnumWorkflowStatusFilter<$PrismaModel> | $Enums.WorkflowStatus
  }

  export type NestedEnumTerminationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TerminationStatus | EnumTerminationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TerminationStatus[]
    notIn?: $Enums.TerminationStatus[]
    not?: NestedEnumTerminationStatusWithAggregatesFilter<$PrismaModel> | $Enums.TerminationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTerminationStatusFilter<$PrismaModel>
    _max?: NestedEnumTerminationStatusFilter<$PrismaModel>
  }

  export type NestedEnumWorkflowStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkflowStatus | EnumWorkflowStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkflowStatus[]
    notIn?: $Enums.WorkflowStatus[]
    not?: NestedEnumWorkflowStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkflowStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkflowStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkflowStatusFilter<$PrismaModel>
  }

  export type UserRoleCreateWithoutRoleInput = {
    user: UserCreateNestedOneWithoutRolesInput
  }

  export type UserRoleUncheckedCreateWithoutRoleInput = {
    userId: number
  }

  export type UserRoleCreateOrConnectWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleCreateManyRoleInputEnvelope = {
    data: UserRoleCreateManyRoleInput | UserRoleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    OR?: UserRoleScalarWhereInput[]
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    userId?: IntFilter<"UserRole"> | number
    roleId?: IntFilter<"UserRole"> | number
  }

  export type UserRoleCreateWithoutUserInput = {
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserRoleUncheckedCreateWithoutUserInput = {
    roleId: number
  }

  export type UserRoleCreateOrConnectWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleCreateManyUserInputEnvelope = {
    data: UserRoleCreateManyUserInput | UserRoleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeCreateWithoutUserInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    subDepartmentId?: number | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    maritalStatus?: MaritalStatusCreateNestedOneWithoutEmployeesInput
    employmentType?: EmploymentTypeCreateNestedOneWithoutEmployeesInput
    jobStatus?: JobStatusCreateNestedOneWithoutEmployeesInput
    agreementStatus?: AgreementStatusCreateNestedOneWithoutEmployeesInput
    createdMeetings?: MeetingCreateNestedManyWithoutCreatorInput
    shifts?: EmployeeShiftCreateNestedManyWithoutEmployeeInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutUserInput = {
    id?: number
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    subDepartmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdMeetings?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    shifts?: EmployeeShiftUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationUncheckedCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryUncheckedCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutUserInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
  }

  export type EmployeeCreateManyUserInputEnvelope = {
    data: EmployeeCreateManyUserInput | EmployeeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LeaveCreateWithoutApproverInput = {
    leaveType: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.LeaveStatus
    reason?: string | null
    requestedAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutLeavesInput
  }

  export type LeaveUncheckedCreateWithoutApproverInput = {
    id?: number
    employeeId: number
    leaveType: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.LeaveStatus
    reason?: string | null
    requestedAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveCreateOrConnectWithoutApproverInput = {
    where: LeaveWhereUniqueInput
    create: XOR<LeaveCreateWithoutApproverInput, LeaveUncheckedCreateWithoutApproverInput>
  }

  export type LeaveCreateManyApproverInputEnvelope = {
    data: LeaveCreateManyApproverInput | LeaveCreateManyApproverInput[]
    skipDuplicates?: boolean
  }

  export type OvertimeLogCreateWithoutApproverInput = {
    date: Date | string
    hours?: Decimal | DecimalJsLike | number | string | null
    startTime: Date | string
    endTime: Date | string
    reason?: string | null
    approvalStatus?: $Enums.OvertimeApprovalStatus
    compensationMethod?: $Enums.CompensationMethod
    employee: EmployeeCreateNestedOneWithoutOvertimesInput
  }

  export type OvertimeLogUncheckedCreateWithoutApproverInput = {
    id?: number
    employeeId: number
    date: Date | string
    hours?: Decimal | DecimalJsLike | number | string | null
    startTime: Date | string
    endTime: Date | string
    reason?: string | null
    approvalStatus?: $Enums.OvertimeApprovalStatus
    compensationMethod?: $Enums.CompensationMethod
  }

  export type OvertimeLogCreateOrConnectWithoutApproverInput = {
    where: OvertimeLogWhereUniqueInput
    create: XOR<OvertimeLogCreateWithoutApproverInput, OvertimeLogUncheckedCreateWithoutApproverInput>
  }

  export type OvertimeLogCreateManyApproverInputEnvelope = {
    data: OvertimeLogCreateManyApproverInput | OvertimeLogCreateManyApproverInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type EmployeeUpsertWithWhereUniqueWithoutUserInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
    create: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutUserInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutUserInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutUserInput>
  }

  export type EmployeeScalarWhereInput = {
    AND?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    OR?: EmployeeScalarWhereInput[]
    NOT?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    id?: IntFilter<"Employee"> | number
    userId?: IntNullableFilter<"Employee"> | number | null
    firstName?: StringFilter<"Employee"> | string
    lastName?: StringFilter<"Employee"> | string
    baptismalName?: StringNullableFilter<"Employee"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Employee"> | Date | string | null
    sex?: EnumSexFilter<"Employee"> | $Enums.Sex
    nationality?: StringNullableFilter<"Employee"> | string | null
    maritalStatusId?: IntNullableFilter<"Employee"> | number | null
    departmentId?: IntNullableFilter<"Employee"> | number | null
    subDepartmentId?: IntNullableFilter<"Employee"> | number | null
    positionId?: IntNullableFilter<"Employee"> | number | null
    employmentTypeId?: IntNullableFilter<"Employee"> | number | null
    employmentDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    jobStatusId?: IntNullableFilter<"Employee"> | number | null
    phone?: StringNullableFilter<"Employee"> | string | null
    address?: StringNullableFilter<"Employee"> | string | null
    subCity?: StringNullableFilter<"Employee"> | string | null
    emergencyContactName?: StringNullableFilter<"Employee"> | string | null
    emergencyContactPhone?: StringNullableFilter<"Employee"> | string | null
    repentanceFatherName?: StringNullableFilter<"Employee"> | string | null
    repentanceFatherChurch?: StringNullableFilter<"Employee"> | string | null
    repentanceFatherPhone?: StringNullableFilter<"Employee"> | string | null
    academicQualification?: StringNullableFilter<"Employee"> | string | null
    educationalInstitution?: StringNullableFilter<"Employee"> | string | null
    salary?: DecimalFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    accountNumber?: StringNullableFilter<"Employee"> | string | null
    agreementStatusId?: IntNullableFilter<"Employee"> | number | null
    photo?: StringNullableFilter<"Employee"> | string | null
    deletedAt?: DateTimeNullableFilter<"Employee"> | Date | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
  }

  export type LeaveUpsertWithWhereUniqueWithoutApproverInput = {
    where: LeaveWhereUniqueInput
    update: XOR<LeaveUpdateWithoutApproverInput, LeaveUncheckedUpdateWithoutApproverInput>
    create: XOR<LeaveCreateWithoutApproverInput, LeaveUncheckedCreateWithoutApproverInput>
  }

  export type LeaveUpdateWithWhereUniqueWithoutApproverInput = {
    where: LeaveWhereUniqueInput
    data: XOR<LeaveUpdateWithoutApproverInput, LeaveUncheckedUpdateWithoutApproverInput>
  }

  export type LeaveUpdateManyWithWhereWithoutApproverInput = {
    where: LeaveScalarWhereInput
    data: XOR<LeaveUpdateManyMutationInput, LeaveUncheckedUpdateManyWithoutApproverInput>
  }

  export type LeaveScalarWhereInput = {
    AND?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
    OR?: LeaveScalarWhereInput[]
    NOT?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
    id?: IntFilter<"Leave"> | number
    employeeId?: IntFilter<"Leave"> | number
    leaveType?: EnumLeaveTypeFilter<"Leave"> | $Enums.LeaveType
    startDate?: DateTimeFilter<"Leave"> | Date | string
    endDate?: DateTimeFilter<"Leave"> | Date | string
    status?: EnumLeaveStatusFilter<"Leave"> | $Enums.LeaveStatus
    reason?: StringNullableFilter<"Leave"> | string | null
    approvedBy?: IntNullableFilter<"Leave"> | number | null
    requestedAt?: DateTimeFilter<"Leave"> | Date | string
    updatedAt?: DateTimeFilter<"Leave"> | Date | string
  }

  export type OvertimeLogUpsertWithWhereUniqueWithoutApproverInput = {
    where: OvertimeLogWhereUniqueInput
    update: XOR<OvertimeLogUpdateWithoutApproverInput, OvertimeLogUncheckedUpdateWithoutApproverInput>
    create: XOR<OvertimeLogCreateWithoutApproverInput, OvertimeLogUncheckedCreateWithoutApproverInput>
  }

  export type OvertimeLogUpdateWithWhereUniqueWithoutApproverInput = {
    where: OvertimeLogWhereUniqueInput
    data: XOR<OvertimeLogUpdateWithoutApproverInput, OvertimeLogUncheckedUpdateWithoutApproverInput>
  }

  export type OvertimeLogUpdateManyWithWhereWithoutApproverInput = {
    where: OvertimeLogScalarWhereInput
    data: XOR<OvertimeLogUpdateManyMutationInput, OvertimeLogUncheckedUpdateManyWithoutApproverInput>
  }

  export type OvertimeLogScalarWhereInput = {
    AND?: OvertimeLogScalarWhereInput | OvertimeLogScalarWhereInput[]
    OR?: OvertimeLogScalarWhereInput[]
    NOT?: OvertimeLogScalarWhereInput | OvertimeLogScalarWhereInput[]
    id?: IntFilter<"OvertimeLog"> | number
    employeeId?: IntFilter<"OvertimeLog"> | number
    date?: DateTimeFilter<"OvertimeLog"> | Date | string
    hours?: DecimalNullableFilter<"OvertimeLog"> | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFilter<"OvertimeLog"> | Date | string
    endTime?: DateTimeFilter<"OvertimeLog"> | Date | string
    reason?: StringNullableFilter<"OvertimeLog"> | string | null
    approvedBy?: IntNullableFilter<"OvertimeLog"> | number | null
    approvalStatus?: EnumOvertimeApprovalStatusFilter<"OvertimeLog"> | $Enums.OvertimeApprovalStatus
    compensationMethod?: EnumCompensationMethodFilter<"OvertimeLog"> | $Enums.CompensationMethod
  }

  export type UserCreateWithoutRolesInput = {
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notifyOnComplaint?: boolean
    employees?: EmployeeCreateNestedManyWithoutUserInput
    approvedLeaves?: LeaveCreateNestedManyWithoutApproverInput
    approvedOvertimes?: OvertimeLogCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutRolesInput = {
    id?: number
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notifyOnComplaint?: boolean
    employees?: EmployeeUncheckedCreateNestedManyWithoutUserInput
    approvedLeaves?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    approvedOvertimes?: OvertimeLogUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type RoleCreateWithoutUsersInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutRolesInput = {
    update: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
  }

  export type UserUpdateWithoutRolesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifyOnComplaint?: BoolFieldUpdateOperationsInput | boolean
    employees?: EmployeeUpdateManyWithoutUserNestedInput
    approvedLeaves?: LeaveUpdateManyWithoutApproverNestedInput
    approvedOvertimes?: OvertimeLogUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifyOnComplaint?: BoolFieldUpdateOperationsInput | boolean
    employees?: EmployeeUncheckedUpdateManyWithoutUserNestedInput
    approvedLeaves?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    approvedOvertimes?: OvertimeLogUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateWithoutSubDepartmentsInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: DepartmentCreateNestedOneWithoutSubDepartmentsInput
    employees?: EmployeeCreateNestedManyWithoutDepartmentInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutSubDepartmentsInput = {
    id?: number
    name: string
    description?: string | null
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutDepartmentInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutSubDepartmentsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutSubDepartmentsInput, DepartmentUncheckedCreateWithoutSubDepartmentsInput>
  }

  export type DepartmentCreateWithoutParentInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subDepartments?: DepartmentCreateNestedManyWithoutParentInput
    employees?: EmployeeCreateNestedManyWithoutDepartmentInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutParentInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subDepartments?: DepartmentUncheckedCreateNestedManyWithoutParentInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutDepartmentInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutParentInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutParentInput, DepartmentUncheckedCreateWithoutParentInput>
  }

  export type DepartmentCreateManyParentInputEnvelope = {
    data: DepartmentCreateManyParentInput | DepartmentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeCreateWithoutDepartmentInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    subDepartmentId?: number | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    maritalStatus?: MaritalStatusCreateNestedOneWithoutEmployeesInput
    employmentType?: EmploymentTypeCreateNestedOneWithoutEmployeesInput
    jobStatus?: JobStatusCreateNestedOneWithoutEmployeesInput
    agreementStatus?: AgreementStatusCreateNestedOneWithoutEmployeesInput
    createdMeetings?: MeetingCreateNestedManyWithoutCreatorInput
    shifts?: EmployeeShiftCreateNestedManyWithoutEmployeeInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutDepartmentInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    maritalStatusId?: number | null
    subDepartmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdMeetings?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    shifts?: EmployeeShiftUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationUncheckedCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryUncheckedCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutDepartmentInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput>
  }

  export type EmployeeCreateManyDepartmentInputEnvelope = {
    data: EmployeeCreateManyDepartmentInput | EmployeeCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceSummaryCreateWithoutDepartmentInput = {
    date: Date | string
    status: $Enums.SummaryStatus
    lateArrival?: boolean
    earlyDeparture?: boolean
    unplannedAbsence?: boolean
    totalWorkHours?: Decimal | DecimalJsLike | number | string | null
    remarks?: string | null
    employee: EmployeeCreateNestedOneWithoutAttendanceSummariesInput
  }

  export type AttendanceSummaryUncheckedCreateWithoutDepartmentInput = {
    id?: number
    employeeId: number
    date: Date | string
    status: $Enums.SummaryStatus
    lateArrival?: boolean
    earlyDeparture?: boolean
    unplannedAbsence?: boolean
    totalWorkHours?: Decimal | DecimalJsLike | number | string | null
    remarks?: string | null
  }

  export type AttendanceSummaryCreateOrConnectWithoutDepartmentInput = {
    where: AttendanceSummaryWhereUniqueInput
    create: XOR<AttendanceSummaryCreateWithoutDepartmentInput, AttendanceSummaryUncheckedCreateWithoutDepartmentInput>
  }

  export type AttendanceSummaryCreateManyDepartmentInputEnvelope = {
    data: AttendanceSummaryCreateManyDepartmentInput | AttendanceSummaryCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentUpsertWithoutSubDepartmentsInput = {
    update: XOR<DepartmentUpdateWithoutSubDepartmentsInput, DepartmentUncheckedUpdateWithoutSubDepartmentsInput>
    create: XOR<DepartmentCreateWithoutSubDepartmentsInput, DepartmentUncheckedCreateWithoutSubDepartmentsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutSubDepartmentsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutSubDepartmentsInput, DepartmentUncheckedUpdateWithoutSubDepartmentsInput>
  }

  export type DepartmentUpdateWithoutSubDepartmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: DepartmentUpdateOneWithoutSubDepartmentsNestedInput
    employees?: EmployeeUpdateManyWithoutDepartmentNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutSubDepartmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUpsertWithWhereUniqueWithoutParentInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutParentInput, DepartmentUncheckedUpdateWithoutParentInput>
    create: XOR<DepartmentCreateWithoutParentInput, DepartmentUncheckedCreateWithoutParentInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutParentInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutParentInput, DepartmentUncheckedUpdateWithoutParentInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutParentInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutParentInput>
  }

  export type DepartmentScalarWhereInput = {
    AND?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    OR?: DepartmentScalarWhereInput[]
    NOT?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    id?: IntFilter<"Department"> | number
    name?: StringFilter<"Department"> | string
    description?: StringNullableFilter<"Department"> | string | null
    parentId?: IntNullableFilter<"Department"> | number | null
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
  }

  export type EmployeeUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutDepartmentInput, EmployeeUncheckedUpdateWithoutDepartmentInput>
    create: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutDepartmentInput, EmployeeUncheckedUpdateWithoutDepartmentInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutDepartmentInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type AttendanceSummaryUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: AttendanceSummaryWhereUniqueInput
    update: XOR<AttendanceSummaryUpdateWithoutDepartmentInput, AttendanceSummaryUncheckedUpdateWithoutDepartmentInput>
    create: XOR<AttendanceSummaryCreateWithoutDepartmentInput, AttendanceSummaryUncheckedCreateWithoutDepartmentInput>
  }

  export type AttendanceSummaryUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: AttendanceSummaryWhereUniqueInput
    data: XOR<AttendanceSummaryUpdateWithoutDepartmentInput, AttendanceSummaryUncheckedUpdateWithoutDepartmentInput>
  }

  export type AttendanceSummaryUpdateManyWithWhereWithoutDepartmentInput = {
    where: AttendanceSummaryScalarWhereInput
    data: XOR<AttendanceSummaryUpdateManyMutationInput, AttendanceSummaryUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type AttendanceSummaryScalarWhereInput = {
    AND?: AttendanceSummaryScalarWhereInput | AttendanceSummaryScalarWhereInput[]
    OR?: AttendanceSummaryScalarWhereInput[]
    NOT?: AttendanceSummaryScalarWhereInput | AttendanceSummaryScalarWhereInput[]
    id?: IntFilter<"AttendanceSummary"> | number
    employeeId?: IntFilter<"AttendanceSummary"> | number
    date?: DateTimeFilter<"AttendanceSummary"> | Date | string
    status?: EnumSummaryStatusFilter<"AttendanceSummary"> | $Enums.SummaryStatus
    lateArrival?: BoolFilter<"AttendanceSummary"> | boolean
    earlyDeparture?: BoolFilter<"AttendanceSummary"> | boolean
    unplannedAbsence?: BoolFilter<"AttendanceSummary"> | boolean
    totalWorkHours?: DecimalNullableFilter<"AttendanceSummary"> | Decimal | DecimalJsLike | number | string | null
    remarks?: StringNullableFilter<"AttendanceSummary"> | string | null
    departmentId?: IntNullableFilter<"AttendanceSummary"> | number | null
  }

  export type EmployeeCreateWithoutPositionInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    subDepartmentId?: number | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    maritalStatus?: MaritalStatusCreateNestedOneWithoutEmployeesInput
    employmentType?: EmploymentTypeCreateNestedOneWithoutEmployeesInput
    jobStatus?: JobStatusCreateNestedOneWithoutEmployeesInput
    agreementStatus?: AgreementStatusCreateNestedOneWithoutEmployeesInput
    createdMeetings?: MeetingCreateNestedManyWithoutCreatorInput
    shifts?: EmployeeShiftCreateNestedManyWithoutEmployeeInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutPositionInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    subDepartmentId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdMeetings?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    shifts?: EmployeeShiftUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationUncheckedCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryUncheckedCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutPositionInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutPositionInput, EmployeeUncheckedCreateWithoutPositionInput>
  }

  export type EmployeeCreateManyPositionInputEnvelope = {
    data: EmployeeCreateManyPositionInput | EmployeeCreateManyPositionInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeUpsertWithWhereUniqueWithoutPositionInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutPositionInput, EmployeeUncheckedUpdateWithoutPositionInput>
    create: XOR<EmployeeCreateWithoutPositionInput, EmployeeUncheckedCreateWithoutPositionInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutPositionInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutPositionInput, EmployeeUncheckedUpdateWithoutPositionInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutPositionInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutPositionInput>
  }

  export type EmployeeCreateWithoutMaritalStatusInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    subDepartmentId?: number | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    employmentType?: EmploymentTypeCreateNestedOneWithoutEmployeesInput
    jobStatus?: JobStatusCreateNestedOneWithoutEmployeesInput
    agreementStatus?: AgreementStatusCreateNestedOneWithoutEmployeesInput
    createdMeetings?: MeetingCreateNestedManyWithoutCreatorInput
    shifts?: EmployeeShiftCreateNestedManyWithoutEmployeeInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutMaritalStatusInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    departmentId?: number | null
    subDepartmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdMeetings?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    shifts?: EmployeeShiftUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationUncheckedCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryUncheckedCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutMaritalStatusInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutMaritalStatusInput, EmployeeUncheckedCreateWithoutMaritalStatusInput>
  }

  export type EmployeeCreateManyMaritalStatusInputEnvelope = {
    data: EmployeeCreateManyMaritalStatusInput | EmployeeCreateManyMaritalStatusInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeUpsertWithWhereUniqueWithoutMaritalStatusInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutMaritalStatusInput, EmployeeUncheckedUpdateWithoutMaritalStatusInput>
    create: XOR<EmployeeCreateWithoutMaritalStatusInput, EmployeeUncheckedCreateWithoutMaritalStatusInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutMaritalStatusInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutMaritalStatusInput, EmployeeUncheckedUpdateWithoutMaritalStatusInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutMaritalStatusInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutMaritalStatusInput>
  }

  export type EmployeeCreateWithoutEmploymentTypeInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    subDepartmentId?: number | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    maritalStatus?: MaritalStatusCreateNestedOneWithoutEmployeesInput
    jobStatus?: JobStatusCreateNestedOneWithoutEmployeesInput
    agreementStatus?: AgreementStatusCreateNestedOneWithoutEmployeesInput
    createdMeetings?: MeetingCreateNestedManyWithoutCreatorInput
    shifts?: EmployeeShiftCreateNestedManyWithoutEmployeeInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutEmploymentTypeInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    subDepartmentId?: number | null
    positionId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdMeetings?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    shifts?: EmployeeShiftUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationUncheckedCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryUncheckedCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutEmploymentTypeInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutEmploymentTypeInput, EmployeeUncheckedCreateWithoutEmploymentTypeInput>
  }

  export type EmployeeCreateManyEmploymentTypeInputEnvelope = {
    data: EmployeeCreateManyEmploymentTypeInput | EmployeeCreateManyEmploymentTypeInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeUpsertWithWhereUniqueWithoutEmploymentTypeInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutEmploymentTypeInput, EmployeeUncheckedUpdateWithoutEmploymentTypeInput>
    create: XOR<EmployeeCreateWithoutEmploymentTypeInput, EmployeeUncheckedCreateWithoutEmploymentTypeInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutEmploymentTypeInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutEmploymentTypeInput, EmployeeUncheckedUpdateWithoutEmploymentTypeInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutEmploymentTypeInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutEmploymentTypeInput>
  }

  export type EmployeeCreateWithoutJobStatusInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    subDepartmentId?: number | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    maritalStatus?: MaritalStatusCreateNestedOneWithoutEmployeesInput
    employmentType?: EmploymentTypeCreateNestedOneWithoutEmployeesInput
    agreementStatus?: AgreementStatusCreateNestedOneWithoutEmployeesInput
    createdMeetings?: MeetingCreateNestedManyWithoutCreatorInput
    shifts?: EmployeeShiftCreateNestedManyWithoutEmployeeInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutJobStatusInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    subDepartmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdMeetings?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    shifts?: EmployeeShiftUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationUncheckedCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryUncheckedCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutJobStatusInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutJobStatusInput, EmployeeUncheckedCreateWithoutJobStatusInput>
  }

  export type EmployeeCreateManyJobStatusInputEnvelope = {
    data: EmployeeCreateManyJobStatusInput | EmployeeCreateManyJobStatusInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeUpsertWithWhereUniqueWithoutJobStatusInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutJobStatusInput, EmployeeUncheckedUpdateWithoutJobStatusInput>
    create: XOR<EmployeeCreateWithoutJobStatusInput, EmployeeUncheckedCreateWithoutJobStatusInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutJobStatusInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutJobStatusInput, EmployeeUncheckedUpdateWithoutJobStatusInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutJobStatusInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutJobStatusInput>
  }

  export type EmployeeCreateWithoutAgreementStatusInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    subDepartmentId?: number | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    maritalStatus?: MaritalStatusCreateNestedOneWithoutEmployeesInput
    employmentType?: EmploymentTypeCreateNestedOneWithoutEmployeesInput
    jobStatus?: JobStatusCreateNestedOneWithoutEmployeesInput
    createdMeetings?: MeetingCreateNestedManyWithoutCreatorInput
    shifts?: EmployeeShiftCreateNestedManyWithoutEmployeeInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutAgreementStatusInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    subDepartmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdMeetings?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    shifts?: EmployeeShiftUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationUncheckedCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryUncheckedCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutAgreementStatusInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAgreementStatusInput, EmployeeUncheckedCreateWithoutAgreementStatusInput>
  }

  export type EmployeeCreateManyAgreementStatusInputEnvelope = {
    data: EmployeeCreateManyAgreementStatusInput | EmployeeCreateManyAgreementStatusInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeUpsertWithWhereUniqueWithoutAgreementStatusInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutAgreementStatusInput, EmployeeUncheckedUpdateWithoutAgreementStatusInput>
    create: XOR<EmployeeCreateWithoutAgreementStatusInput, EmployeeUncheckedCreateWithoutAgreementStatusInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutAgreementStatusInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutAgreementStatusInput, EmployeeUncheckedUpdateWithoutAgreementStatusInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutAgreementStatusInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutAgreementStatusInput>
  }

  export type EmployeeCreateWithoutCreatedMeetingsInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    subDepartmentId?: number | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    maritalStatus?: MaritalStatusCreateNestedOneWithoutEmployeesInput
    employmentType?: EmploymentTypeCreateNestedOneWithoutEmployeesInput
    jobStatus?: JobStatusCreateNestedOneWithoutEmployeesInput
    agreementStatus?: AgreementStatusCreateNestedOneWithoutEmployeesInput
    shifts?: EmployeeShiftCreateNestedManyWithoutEmployeeInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutCreatedMeetingsInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    subDepartmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: EmployeeShiftUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationUncheckedCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryUncheckedCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutCreatedMeetingsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutCreatedMeetingsInput, EmployeeUncheckedCreateWithoutCreatedMeetingsInput>
  }

  export type EmployeeUpsertWithoutCreatedMeetingsInput = {
    update: XOR<EmployeeUpdateWithoutCreatedMeetingsInput, EmployeeUncheckedUpdateWithoutCreatedMeetingsInput>
    create: XOR<EmployeeCreateWithoutCreatedMeetingsInput, EmployeeUncheckedCreateWithoutCreatedMeetingsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutCreatedMeetingsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutCreatedMeetingsInput, EmployeeUncheckedUpdateWithoutCreatedMeetingsInput>
  }

  export type EmployeeUpdateWithoutCreatedMeetingsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    maritalStatus?: MaritalStatusUpdateOneWithoutEmployeesNestedInput
    employmentType?: EmploymentTypeUpdateOneWithoutEmployeesNestedInput
    jobStatus?: JobStatusUpdateOneWithoutEmployeesNestedInput
    agreementStatus?: AgreementStatusUpdateOneWithoutEmployeesNestedInput
    shifts?: EmployeeShiftUpdateManyWithoutEmployeeNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutCreatedMeetingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: EmployeeShiftUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUncheckedUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type UserCreateWithoutEmployeesInput = {
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notifyOnComplaint?: boolean
    roles?: UserRoleCreateNestedManyWithoutUserInput
    approvedLeaves?: LeaveCreateNestedManyWithoutApproverInput
    approvedOvertimes?: OvertimeLogCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutEmployeesInput = {
    id?: number
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notifyOnComplaint?: boolean
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    approvedLeaves?: LeaveUncheckedCreateNestedManyWithoutApproverInput
    approvedOvertimes?: OvertimeLogUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutEmployeesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmployeesInput, UserUncheckedCreateWithoutEmployeesInput>
  }

  export type DepartmentCreateWithoutEmployeesInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: DepartmentCreateNestedOneWithoutSubDepartmentsInput
    subDepartments?: DepartmentCreateNestedManyWithoutParentInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutEmployeesInput = {
    id?: number
    name: string
    description?: string | null
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subDepartments?: DepartmentUncheckedCreateNestedManyWithoutParentInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutEmployeesInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutEmployeesInput, DepartmentUncheckedCreateWithoutEmployeesInput>
  }

  export type PositionCreateWithoutEmployeesInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PositionUncheckedCreateWithoutEmployeesInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PositionCreateOrConnectWithoutEmployeesInput = {
    where: PositionWhereUniqueInput
    create: XOR<PositionCreateWithoutEmployeesInput, PositionUncheckedCreateWithoutEmployeesInput>
  }

  export type MaritalStatusCreateWithoutEmployeesInput = {
    status: string
  }

  export type MaritalStatusUncheckedCreateWithoutEmployeesInput = {
    id?: number
    status: string
  }

  export type MaritalStatusCreateOrConnectWithoutEmployeesInput = {
    where: MaritalStatusWhereUniqueInput
    create: XOR<MaritalStatusCreateWithoutEmployeesInput, MaritalStatusUncheckedCreateWithoutEmployeesInput>
  }

  export type EmploymentTypeCreateWithoutEmployeesInput = {
    type: string
  }

  export type EmploymentTypeUncheckedCreateWithoutEmployeesInput = {
    id?: number
    type: string
  }

  export type EmploymentTypeCreateOrConnectWithoutEmployeesInput = {
    where: EmploymentTypeWhereUniqueInput
    create: XOR<EmploymentTypeCreateWithoutEmployeesInput, EmploymentTypeUncheckedCreateWithoutEmployeesInput>
  }

  export type JobStatusCreateWithoutEmployeesInput = {
    status: string
  }

  export type JobStatusUncheckedCreateWithoutEmployeesInput = {
    id?: number
    status: string
  }

  export type JobStatusCreateOrConnectWithoutEmployeesInput = {
    where: JobStatusWhereUniqueInput
    create: XOR<JobStatusCreateWithoutEmployeesInput, JobStatusUncheckedCreateWithoutEmployeesInput>
  }

  export type AgreementStatusCreateWithoutEmployeesInput = {
    status: string
  }

  export type AgreementStatusUncheckedCreateWithoutEmployeesInput = {
    id?: number
    status: string
  }

  export type AgreementStatusCreateOrConnectWithoutEmployeesInput = {
    where: AgreementStatusWhereUniqueInput
    create: XOR<AgreementStatusCreateWithoutEmployeesInput, AgreementStatusUncheckedCreateWithoutEmployeesInput>
  }

  export type MeetingCreateWithoutCreatorInput = {
    title: string
    description?: string | null
    date: string
    time: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeetingUncheckedCreateWithoutCreatorInput = {
    id?: number
    title: string
    description?: string | null
    date: string
    time: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeetingCreateOrConnectWithoutCreatorInput = {
    where: MeetingWhereUniqueInput
    create: XOR<MeetingCreateWithoutCreatorInput, MeetingUncheckedCreateWithoutCreatorInput>
  }

  export type MeetingCreateManyCreatorInputEnvelope = {
    data: MeetingCreateManyCreatorInput | MeetingCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeShiftCreateWithoutEmployeeInput = {
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    shift: ShiftCreateNestedOneWithoutAssignmentsInput
  }

  export type EmployeeShiftUncheckedCreateWithoutEmployeeInput = {
    id?: number
    shiftId: number
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
  }

  export type EmployeeShiftCreateOrConnectWithoutEmployeeInput = {
    where: EmployeeShiftWhereUniqueInput
    create: XOR<EmployeeShiftCreateWithoutEmployeeInput, EmployeeShiftUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeShiftCreateManyEmployeeInputEnvelope = {
    data: EmployeeShiftCreateManyEmployeeInput | EmployeeShiftCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceLogCreateWithoutEmployeeInput = {
    date: Date | string
    actualClockIn?: Date | string | null
    actualClockOut?: Date | string | null
    status: $Enums.AttendanceStatus
    createdAt?: Date | string
    session: SessionDefinitionCreateNestedOneWithoutLogsInput
  }

  export type AttendanceLogUncheckedCreateWithoutEmployeeInput = {
    id?: number
    date: Date | string
    sessionId: number
    actualClockIn?: Date | string | null
    actualClockOut?: Date | string | null
    status: $Enums.AttendanceStatus
    createdAt?: Date | string
  }

  export type AttendanceLogCreateOrConnectWithoutEmployeeInput = {
    where: AttendanceLogWhereUniqueInput
    create: XOR<AttendanceLogCreateWithoutEmployeeInput, AttendanceLogUncheckedCreateWithoutEmployeeInput>
  }

  export type AttendanceLogCreateManyEmployeeInputEnvelope = {
    data: AttendanceLogCreateManyEmployeeInput | AttendanceLogCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceSummaryCreateWithoutEmployeeInput = {
    date: Date | string
    status: $Enums.SummaryStatus
    lateArrival?: boolean
    earlyDeparture?: boolean
    unplannedAbsence?: boolean
    totalWorkHours?: Decimal | DecimalJsLike | number | string | null
    remarks?: string | null
    department?: DepartmentCreateNestedOneWithoutAttendanceSummariesInput
  }

  export type AttendanceSummaryUncheckedCreateWithoutEmployeeInput = {
    id?: number
    date: Date | string
    status: $Enums.SummaryStatus
    lateArrival?: boolean
    earlyDeparture?: boolean
    unplannedAbsence?: boolean
    totalWorkHours?: Decimal | DecimalJsLike | number | string | null
    remarks?: string | null
    departmentId?: number | null
  }

  export type AttendanceSummaryCreateOrConnectWithoutEmployeeInput = {
    where: AttendanceSummaryWhereUniqueInput
    create: XOR<AttendanceSummaryCreateWithoutEmployeeInput, AttendanceSummaryUncheckedCreateWithoutEmployeeInput>
  }

  export type AttendanceSummaryCreateManyEmployeeInputEnvelope = {
    data: AttendanceSummaryCreateManyEmployeeInput | AttendanceSummaryCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type LeaveCreateWithoutEmployeeInput = {
    leaveType: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.LeaveStatus
    reason?: string | null
    requestedAt?: Date | string
    updatedAt?: Date | string
    approver?: UserCreateNestedOneWithoutApprovedLeavesInput
  }

  export type LeaveUncheckedCreateWithoutEmployeeInput = {
    id?: number
    leaveType: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.LeaveStatus
    reason?: string | null
    approvedBy?: number | null
    requestedAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveCreateOrConnectWithoutEmployeeInput = {
    where: LeaveWhereUniqueInput
    create: XOR<LeaveCreateWithoutEmployeeInput, LeaveUncheckedCreateWithoutEmployeeInput>
  }

  export type LeaveCreateManyEmployeeInputEnvelope = {
    data: LeaveCreateManyEmployeeInput | LeaveCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type ComplaintCreateWithoutEmployeeInput = {
    subject: string
    description: string
    status?: $Enums.ComplaintStatus
    response?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintUncheckedCreateWithoutEmployeeInput = {
    id?: number
    subject: string
    description: string
    status?: $Enums.ComplaintStatus
    response?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintCreateOrConnectWithoutEmployeeInput = {
    where: ComplaintWhereUniqueInput
    create: XOR<ComplaintCreateWithoutEmployeeInput, ComplaintUncheckedCreateWithoutEmployeeInput>
  }

  export type ComplaintCreateManyEmployeeInputEnvelope = {
    data: ComplaintCreateManyEmployeeInput | ComplaintCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type PerformanceReviewCreateWithoutEmployeeInput = {
    reviewDate: Date | string
    reviewerName?: string | null
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceReviewUncheckedCreateWithoutEmployeeInput = {
    id?: number
    reviewDate: Date | string
    reviewerName?: string | null
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceReviewCreateOrConnectWithoutEmployeeInput = {
    where: PerformanceReviewWhereUniqueInput
    create: XOR<PerformanceReviewCreateWithoutEmployeeInput, PerformanceReviewUncheckedCreateWithoutEmployeeInput>
  }

  export type PerformanceReviewCreateManyEmployeeInputEnvelope = {
    data: PerformanceReviewCreateManyEmployeeInput | PerformanceReviewCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type TerminationCreateWithoutEmployeeInput = {
    terminationDate: Date | string
    reason?: string | null
    status: $Enums.TerminationStatus
    workflowStatus?: $Enums.WorkflowStatus
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TerminationUncheckedCreateWithoutEmployeeInput = {
    id?: number
    terminationDate: Date | string
    reason?: string | null
    status: $Enums.TerminationStatus
    workflowStatus?: $Enums.WorkflowStatus
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TerminationCreateOrConnectWithoutEmployeeInput = {
    where: TerminationWhereUniqueInput
    create: XOR<TerminationCreateWithoutEmployeeInput, TerminationUncheckedCreateWithoutEmployeeInput>
  }

  export type TerminationCreateManyEmployeeInputEnvelope = {
    data: TerminationCreateManyEmployeeInput | TerminationCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type SalaryCreateWithoutEmployeeInput = {
    salaryMonth: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.SalaryStatus
    overtimeHours?: Decimal | DecimalJsLike | number | string
    overtimePay?: Decimal | DecimalJsLike | number | string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalaryUncheckedCreateWithoutEmployeeInput = {
    id?: number
    salaryMonth: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.SalaryStatus
    overtimeHours?: Decimal | DecimalJsLike | number | string
    overtimePay?: Decimal | DecimalJsLike | number | string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalaryCreateOrConnectWithoutEmployeeInput = {
    where: SalaryWhereUniqueInput
    create: XOR<SalaryCreateWithoutEmployeeInput, SalaryUncheckedCreateWithoutEmployeeInput>
  }

  export type SalaryCreateManyEmployeeInputEnvelope = {
    data: SalaryCreateManyEmployeeInput | SalaryCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type OvertimeLogCreateWithoutEmployeeInput = {
    date: Date | string
    hours?: Decimal | DecimalJsLike | number | string | null
    startTime: Date | string
    endTime: Date | string
    reason?: string | null
    approvalStatus?: $Enums.OvertimeApprovalStatus
    compensationMethod?: $Enums.CompensationMethod
    approver?: UserCreateNestedOneWithoutApprovedOvertimesInput
  }

  export type OvertimeLogUncheckedCreateWithoutEmployeeInput = {
    id?: number
    date: Date | string
    hours?: Decimal | DecimalJsLike | number | string | null
    startTime: Date | string
    endTime: Date | string
    reason?: string | null
    approvedBy?: number | null
    approvalStatus?: $Enums.OvertimeApprovalStatus
    compensationMethod?: $Enums.CompensationMethod
  }

  export type OvertimeLogCreateOrConnectWithoutEmployeeInput = {
    where: OvertimeLogWhereUniqueInput
    create: XOR<OvertimeLogCreateWithoutEmployeeInput, OvertimeLogUncheckedCreateWithoutEmployeeInput>
  }

  export type OvertimeLogCreateManyEmployeeInputEnvelope = {
    data: OvertimeLogCreateManyEmployeeInput | OvertimeLogCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutEmployeesInput = {
    update: XOR<UserUpdateWithoutEmployeesInput, UserUncheckedUpdateWithoutEmployeesInput>
    create: XOR<UserCreateWithoutEmployeesInput, UserUncheckedCreateWithoutEmployeesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmployeesInput, UserUncheckedUpdateWithoutEmployeesInput>
  }

  export type UserUpdateWithoutEmployeesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifyOnComplaint?: BoolFieldUpdateOperationsInput | boolean
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    approvedLeaves?: LeaveUpdateManyWithoutApproverNestedInput
    approvedOvertimes?: OvertimeLogUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutEmployeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifyOnComplaint?: BoolFieldUpdateOperationsInput | boolean
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    approvedLeaves?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
    approvedOvertimes?: OvertimeLogUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type DepartmentUpsertWithoutEmployeesInput = {
    update: XOR<DepartmentUpdateWithoutEmployeesInput, DepartmentUncheckedUpdateWithoutEmployeesInput>
    create: XOR<DepartmentCreateWithoutEmployeesInput, DepartmentUncheckedCreateWithoutEmployeesInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutEmployeesInput, DepartmentUncheckedUpdateWithoutEmployeesInput>
  }

  export type DepartmentUpdateWithoutEmployeesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: DepartmentUpdateOneWithoutSubDepartmentsNestedInput
    subDepartments?: DepartmentUpdateManyWithoutParentNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutEmployeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subDepartments?: DepartmentUncheckedUpdateManyWithoutParentNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type PositionUpsertWithoutEmployeesInput = {
    update: XOR<PositionUpdateWithoutEmployeesInput, PositionUncheckedUpdateWithoutEmployeesInput>
    create: XOR<PositionCreateWithoutEmployeesInput, PositionUncheckedCreateWithoutEmployeesInput>
    where?: PositionWhereInput
  }

  export type PositionUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: PositionWhereInput
    data: XOR<PositionUpdateWithoutEmployeesInput, PositionUncheckedUpdateWithoutEmployeesInput>
  }

  export type PositionUpdateWithoutEmployeesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionUncheckedUpdateWithoutEmployeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaritalStatusUpsertWithoutEmployeesInput = {
    update: XOR<MaritalStatusUpdateWithoutEmployeesInput, MaritalStatusUncheckedUpdateWithoutEmployeesInput>
    create: XOR<MaritalStatusCreateWithoutEmployeesInput, MaritalStatusUncheckedCreateWithoutEmployeesInput>
    where?: MaritalStatusWhereInput
  }

  export type MaritalStatusUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: MaritalStatusWhereInput
    data: XOR<MaritalStatusUpdateWithoutEmployeesInput, MaritalStatusUncheckedUpdateWithoutEmployeesInput>
  }

  export type MaritalStatusUpdateWithoutEmployeesInput = {
    status?: StringFieldUpdateOperationsInput | string
  }

  export type MaritalStatusUncheckedUpdateWithoutEmployeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type EmploymentTypeUpsertWithoutEmployeesInput = {
    update: XOR<EmploymentTypeUpdateWithoutEmployeesInput, EmploymentTypeUncheckedUpdateWithoutEmployeesInput>
    create: XOR<EmploymentTypeCreateWithoutEmployeesInput, EmploymentTypeUncheckedCreateWithoutEmployeesInput>
    where?: EmploymentTypeWhereInput
  }

  export type EmploymentTypeUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: EmploymentTypeWhereInput
    data: XOR<EmploymentTypeUpdateWithoutEmployeesInput, EmploymentTypeUncheckedUpdateWithoutEmployeesInput>
  }

  export type EmploymentTypeUpdateWithoutEmployeesInput = {
    type?: StringFieldUpdateOperationsInput | string
  }

  export type EmploymentTypeUncheckedUpdateWithoutEmployeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type JobStatusUpsertWithoutEmployeesInput = {
    update: XOR<JobStatusUpdateWithoutEmployeesInput, JobStatusUncheckedUpdateWithoutEmployeesInput>
    create: XOR<JobStatusCreateWithoutEmployeesInput, JobStatusUncheckedCreateWithoutEmployeesInput>
    where?: JobStatusWhereInput
  }

  export type JobStatusUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: JobStatusWhereInput
    data: XOR<JobStatusUpdateWithoutEmployeesInput, JobStatusUncheckedUpdateWithoutEmployeesInput>
  }

  export type JobStatusUpdateWithoutEmployeesInput = {
    status?: StringFieldUpdateOperationsInput | string
  }

  export type JobStatusUncheckedUpdateWithoutEmployeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type AgreementStatusUpsertWithoutEmployeesInput = {
    update: XOR<AgreementStatusUpdateWithoutEmployeesInput, AgreementStatusUncheckedUpdateWithoutEmployeesInput>
    create: XOR<AgreementStatusCreateWithoutEmployeesInput, AgreementStatusUncheckedCreateWithoutEmployeesInput>
    where?: AgreementStatusWhereInput
  }

  export type AgreementStatusUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: AgreementStatusWhereInput
    data: XOR<AgreementStatusUpdateWithoutEmployeesInput, AgreementStatusUncheckedUpdateWithoutEmployeesInput>
  }

  export type AgreementStatusUpdateWithoutEmployeesInput = {
    status?: StringFieldUpdateOperationsInput | string
  }

  export type AgreementStatusUncheckedUpdateWithoutEmployeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type MeetingUpsertWithWhereUniqueWithoutCreatorInput = {
    where: MeetingWhereUniqueInput
    update: XOR<MeetingUpdateWithoutCreatorInput, MeetingUncheckedUpdateWithoutCreatorInput>
    create: XOR<MeetingCreateWithoutCreatorInput, MeetingUncheckedCreateWithoutCreatorInput>
  }

  export type MeetingUpdateWithWhereUniqueWithoutCreatorInput = {
    where: MeetingWhereUniqueInput
    data: XOR<MeetingUpdateWithoutCreatorInput, MeetingUncheckedUpdateWithoutCreatorInput>
  }

  export type MeetingUpdateManyWithWhereWithoutCreatorInput = {
    where: MeetingScalarWhereInput
    data: XOR<MeetingUpdateManyMutationInput, MeetingUncheckedUpdateManyWithoutCreatorInput>
  }

  export type MeetingScalarWhereInput = {
    AND?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
    OR?: MeetingScalarWhereInput[]
    NOT?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
    id?: IntFilter<"Meeting"> | number
    title?: StringFilter<"Meeting"> | string
    description?: StringNullableFilter<"Meeting"> | string | null
    date?: StringFilter<"Meeting"> | string
    time?: StringFilter<"Meeting"> | string
    creatorId?: IntNullableFilter<"Meeting"> | number | null
    createdAt?: DateTimeFilter<"Meeting"> | Date | string
    updatedAt?: DateTimeFilter<"Meeting"> | Date | string
  }

  export type EmployeeShiftUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeShiftWhereUniqueInput
    update: XOR<EmployeeShiftUpdateWithoutEmployeeInput, EmployeeShiftUncheckedUpdateWithoutEmployeeInput>
    create: XOR<EmployeeShiftCreateWithoutEmployeeInput, EmployeeShiftUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeShiftUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeShiftWhereUniqueInput
    data: XOR<EmployeeShiftUpdateWithoutEmployeeInput, EmployeeShiftUncheckedUpdateWithoutEmployeeInput>
  }

  export type EmployeeShiftUpdateManyWithWhereWithoutEmployeeInput = {
    where: EmployeeShiftScalarWhereInput
    data: XOR<EmployeeShiftUpdateManyMutationInput, EmployeeShiftUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type EmployeeShiftScalarWhereInput = {
    AND?: EmployeeShiftScalarWhereInput | EmployeeShiftScalarWhereInput[]
    OR?: EmployeeShiftScalarWhereInput[]
    NOT?: EmployeeShiftScalarWhereInput | EmployeeShiftScalarWhereInput[]
    id?: IntFilter<"EmployeeShift"> | number
    employeeId?: IntFilter<"EmployeeShift"> | number
    shiftId?: IntFilter<"EmployeeShift"> | number
    effectiveFrom?: DateTimeFilter<"EmployeeShift"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"EmployeeShift"> | Date | string | null
  }

  export type AttendanceLogUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: AttendanceLogWhereUniqueInput
    update: XOR<AttendanceLogUpdateWithoutEmployeeInput, AttendanceLogUncheckedUpdateWithoutEmployeeInput>
    create: XOR<AttendanceLogCreateWithoutEmployeeInput, AttendanceLogUncheckedCreateWithoutEmployeeInput>
  }

  export type AttendanceLogUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: AttendanceLogWhereUniqueInput
    data: XOR<AttendanceLogUpdateWithoutEmployeeInput, AttendanceLogUncheckedUpdateWithoutEmployeeInput>
  }

  export type AttendanceLogUpdateManyWithWhereWithoutEmployeeInput = {
    where: AttendanceLogScalarWhereInput
    data: XOR<AttendanceLogUpdateManyMutationInput, AttendanceLogUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type AttendanceLogScalarWhereInput = {
    AND?: AttendanceLogScalarWhereInput | AttendanceLogScalarWhereInput[]
    OR?: AttendanceLogScalarWhereInput[]
    NOT?: AttendanceLogScalarWhereInput | AttendanceLogScalarWhereInput[]
    id?: IntFilter<"AttendanceLog"> | number
    employeeId?: IntFilter<"AttendanceLog"> | number
    date?: DateTimeFilter<"AttendanceLog"> | Date | string
    sessionId?: IntFilter<"AttendanceLog"> | number
    actualClockIn?: DateTimeNullableFilter<"AttendanceLog"> | Date | string | null
    actualClockOut?: DateTimeNullableFilter<"AttendanceLog"> | Date | string | null
    status?: EnumAttendanceStatusFilter<"AttendanceLog"> | $Enums.AttendanceStatus
    createdAt?: DateTimeFilter<"AttendanceLog"> | Date | string
  }

  export type AttendanceSummaryUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: AttendanceSummaryWhereUniqueInput
    update: XOR<AttendanceSummaryUpdateWithoutEmployeeInput, AttendanceSummaryUncheckedUpdateWithoutEmployeeInput>
    create: XOR<AttendanceSummaryCreateWithoutEmployeeInput, AttendanceSummaryUncheckedCreateWithoutEmployeeInput>
  }

  export type AttendanceSummaryUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: AttendanceSummaryWhereUniqueInput
    data: XOR<AttendanceSummaryUpdateWithoutEmployeeInput, AttendanceSummaryUncheckedUpdateWithoutEmployeeInput>
  }

  export type AttendanceSummaryUpdateManyWithWhereWithoutEmployeeInput = {
    where: AttendanceSummaryScalarWhereInput
    data: XOR<AttendanceSummaryUpdateManyMutationInput, AttendanceSummaryUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type LeaveUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: LeaveWhereUniqueInput
    update: XOR<LeaveUpdateWithoutEmployeeInput, LeaveUncheckedUpdateWithoutEmployeeInput>
    create: XOR<LeaveCreateWithoutEmployeeInput, LeaveUncheckedCreateWithoutEmployeeInput>
  }

  export type LeaveUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: LeaveWhereUniqueInput
    data: XOR<LeaveUpdateWithoutEmployeeInput, LeaveUncheckedUpdateWithoutEmployeeInput>
  }

  export type LeaveUpdateManyWithWhereWithoutEmployeeInput = {
    where: LeaveScalarWhereInput
    data: XOR<LeaveUpdateManyMutationInput, LeaveUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type ComplaintUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: ComplaintWhereUniqueInput
    update: XOR<ComplaintUpdateWithoutEmployeeInput, ComplaintUncheckedUpdateWithoutEmployeeInput>
    create: XOR<ComplaintCreateWithoutEmployeeInput, ComplaintUncheckedCreateWithoutEmployeeInput>
  }

  export type ComplaintUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: ComplaintWhereUniqueInput
    data: XOR<ComplaintUpdateWithoutEmployeeInput, ComplaintUncheckedUpdateWithoutEmployeeInput>
  }

  export type ComplaintUpdateManyWithWhereWithoutEmployeeInput = {
    where: ComplaintScalarWhereInput
    data: XOR<ComplaintUpdateManyMutationInput, ComplaintUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type ComplaintScalarWhereInput = {
    AND?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
    OR?: ComplaintScalarWhereInput[]
    NOT?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
    id?: IntFilter<"Complaint"> | number
    employeeId?: IntFilter<"Complaint"> | number
    subject?: StringFilter<"Complaint"> | string
    description?: StringFilter<"Complaint"> | string
    status?: EnumComplaintStatusFilter<"Complaint"> | $Enums.ComplaintStatus
    response?: StringNullableFilter<"Complaint"> | string | null
    createdAt?: DateTimeFilter<"Complaint"> | Date | string
    updatedAt?: DateTimeFilter<"Complaint"> | Date | string
  }

  export type PerformanceReviewUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: PerformanceReviewWhereUniqueInput
    update: XOR<PerformanceReviewUpdateWithoutEmployeeInput, PerformanceReviewUncheckedUpdateWithoutEmployeeInput>
    create: XOR<PerformanceReviewCreateWithoutEmployeeInput, PerformanceReviewUncheckedCreateWithoutEmployeeInput>
  }

  export type PerformanceReviewUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: PerformanceReviewWhereUniqueInput
    data: XOR<PerformanceReviewUpdateWithoutEmployeeInput, PerformanceReviewUncheckedUpdateWithoutEmployeeInput>
  }

  export type PerformanceReviewUpdateManyWithWhereWithoutEmployeeInput = {
    where: PerformanceReviewScalarWhereInput
    data: XOR<PerformanceReviewUpdateManyMutationInput, PerformanceReviewUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type PerformanceReviewScalarWhereInput = {
    AND?: PerformanceReviewScalarWhereInput | PerformanceReviewScalarWhereInput[]
    OR?: PerformanceReviewScalarWhereInput[]
    NOT?: PerformanceReviewScalarWhereInput | PerformanceReviewScalarWhereInput[]
    id?: IntFilter<"PerformanceReview"> | number
    employeeId?: IntFilter<"PerformanceReview"> | number
    reviewDate?: DateTimeFilter<"PerformanceReview"> | Date | string
    reviewerName?: StringNullableFilter<"PerformanceReview"> | string | null
    score?: IntNullableFilter<"PerformanceReview"> | number | null
    comments?: StringNullableFilter<"PerformanceReview"> | string | null
    createdAt?: DateTimeFilter<"PerformanceReview"> | Date | string
    updatedAt?: DateTimeFilter<"PerformanceReview"> | Date | string
  }

  export type TerminationUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: TerminationWhereUniqueInput
    update: XOR<TerminationUpdateWithoutEmployeeInput, TerminationUncheckedUpdateWithoutEmployeeInput>
    create: XOR<TerminationCreateWithoutEmployeeInput, TerminationUncheckedCreateWithoutEmployeeInput>
  }

  export type TerminationUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: TerminationWhereUniqueInput
    data: XOR<TerminationUpdateWithoutEmployeeInput, TerminationUncheckedUpdateWithoutEmployeeInput>
  }

  export type TerminationUpdateManyWithWhereWithoutEmployeeInput = {
    where: TerminationScalarWhereInput
    data: XOR<TerminationUpdateManyMutationInput, TerminationUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type TerminationScalarWhereInput = {
    AND?: TerminationScalarWhereInput | TerminationScalarWhereInput[]
    OR?: TerminationScalarWhereInput[]
    NOT?: TerminationScalarWhereInput | TerminationScalarWhereInput[]
    id?: IntFilter<"Termination"> | number
    employeeId?: IntFilter<"Termination"> | number
    terminationDate?: DateTimeFilter<"Termination"> | Date | string
    reason?: StringNullableFilter<"Termination"> | string | null
    status?: EnumTerminationStatusFilter<"Termination"> | $Enums.TerminationStatus
    workflowStatus?: EnumWorkflowStatusFilter<"Termination"> | $Enums.WorkflowStatus
    remarks?: StringNullableFilter<"Termination"> | string | null
    createdAt?: DateTimeFilter<"Termination"> | Date | string
    updatedAt?: DateTimeFilter<"Termination"> | Date | string
  }

  export type SalaryUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: SalaryWhereUniqueInput
    update: XOR<SalaryUpdateWithoutEmployeeInput, SalaryUncheckedUpdateWithoutEmployeeInput>
    create: XOR<SalaryCreateWithoutEmployeeInput, SalaryUncheckedCreateWithoutEmployeeInput>
  }

  export type SalaryUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: SalaryWhereUniqueInput
    data: XOR<SalaryUpdateWithoutEmployeeInput, SalaryUncheckedUpdateWithoutEmployeeInput>
  }

  export type SalaryUpdateManyWithWhereWithoutEmployeeInput = {
    where: SalaryScalarWhereInput
    data: XOR<SalaryUpdateManyMutationInput, SalaryUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type SalaryScalarWhereInput = {
    AND?: SalaryScalarWhereInput | SalaryScalarWhereInput[]
    OR?: SalaryScalarWhereInput[]
    NOT?: SalaryScalarWhereInput | SalaryScalarWhereInput[]
    id?: IntFilter<"Salary"> | number
    employeeId?: IntFilter<"Salary"> | number
    salaryMonth?: DateTimeFilter<"Salary"> | Date | string
    amount?: DecimalFilter<"Salary"> | Decimal | DecimalJsLike | number | string
    status?: EnumSalaryStatusFilter<"Salary"> | $Enums.SalaryStatus
    overtimeHours?: DecimalFilter<"Salary"> | Decimal | DecimalJsLike | number | string
    overtimePay?: DecimalFilter<"Salary"> | Decimal | DecimalJsLike | number | string
    paidAt?: DateTimeNullableFilter<"Salary"> | Date | string | null
    createdAt?: DateTimeFilter<"Salary"> | Date | string
    updatedAt?: DateTimeFilter<"Salary"> | Date | string
  }

  export type OvertimeLogUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: OvertimeLogWhereUniqueInput
    update: XOR<OvertimeLogUpdateWithoutEmployeeInput, OvertimeLogUncheckedUpdateWithoutEmployeeInput>
    create: XOR<OvertimeLogCreateWithoutEmployeeInput, OvertimeLogUncheckedCreateWithoutEmployeeInput>
  }

  export type OvertimeLogUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: OvertimeLogWhereUniqueInput
    data: XOR<OvertimeLogUpdateWithoutEmployeeInput, OvertimeLogUncheckedUpdateWithoutEmployeeInput>
  }

  export type OvertimeLogUpdateManyWithWhereWithoutEmployeeInput = {
    where: OvertimeLogScalarWhereInput
    data: XOR<OvertimeLogUpdateManyMutationInput, OvertimeLogUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type EmployeeShiftCreateWithoutShiftInput = {
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
    employee: EmployeeCreateNestedOneWithoutShiftsInput
  }

  export type EmployeeShiftUncheckedCreateWithoutShiftInput = {
    id?: number
    employeeId: number
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
  }

  export type EmployeeShiftCreateOrConnectWithoutShiftInput = {
    where: EmployeeShiftWhereUniqueInput
    create: XOR<EmployeeShiftCreateWithoutShiftInput, EmployeeShiftUncheckedCreateWithoutShiftInput>
  }

  export type EmployeeShiftCreateManyShiftInputEnvelope = {
    data: EmployeeShiftCreateManyShiftInput | EmployeeShiftCreateManyShiftInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeShiftUpsertWithWhereUniqueWithoutShiftInput = {
    where: EmployeeShiftWhereUniqueInput
    update: XOR<EmployeeShiftUpdateWithoutShiftInput, EmployeeShiftUncheckedUpdateWithoutShiftInput>
    create: XOR<EmployeeShiftCreateWithoutShiftInput, EmployeeShiftUncheckedCreateWithoutShiftInput>
  }

  export type EmployeeShiftUpdateWithWhereUniqueWithoutShiftInput = {
    where: EmployeeShiftWhereUniqueInput
    data: XOR<EmployeeShiftUpdateWithoutShiftInput, EmployeeShiftUncheckedUpdateWithoutShiftInput>
  }

  export type EmployeeShiftUpdateManyWithWhereWithoutShiftInput = {
    where: EmployeeShiftScalarWhereInput
    data: XOR<EmployeeShiftUpdateManyMutationInput, EmployeeShiftUncheckedUpdateManyWithoutShiftInput>
  }

  export type EmployeeCreateWithoutShiftsInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    subDepartmentId?: number | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    maritalStatus?: MaritalStatusCreateNestedOneWithoutEmployeesInput
    employmentType?: EmploymentTypeCreateNestedOneWithoutEmployeesInput
    jobStatus?: JobStatusCreateNestedOneWithoutEmployeesInput
    agreementStatus?: AgreementStatusCreateNestedOneWithoutEmployeesInput
    createdMeetings?: MeetingCreateNestedManyWithoutCreatorInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutShiftsInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    subDepartmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdMeetings?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationUncheckedCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryUncheckedCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutShiftsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutShiftsInput, EmployeeUncheckedCreateWithoutShiftsInput>
  }

  export type ShiftCreateWithoutAssignmentsInput = {
    name: string
    startTime: Date | string
    endTime: Date | string
    isFlexible?: boolean
    description?: string | null
  }

  export type ShiftUncheckedCreateWithoutAssignmentsInput = {
    id?: number
    name: string
    startTime: Date | string
    endTime: Date | string
    isFlexible?: boolean
    description?: string | null
  }

  export type ShiftCreateOrConnectWithoutAssignmentsInput = {
    where: ShiftWhereUniqueInput
    create: XOR<ShiftCreateWithoutAssignmentsInput, ShiftUncheckedCreateWithoutAssignmentsInput>
  }

  export type EmployeeUpsertWithoutShiftsInput = {
    update: XOR<EmployeeUpdateWithoutShiftsInput, EmployeeUncheckedUpdateWithoutShiftsInput>
    create: XOR<EmployeeCreateWithoutShiftsInput, EmployeeUncheckedCreateWithoutShiftsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutShiftsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutShiftsInput, EmployeeUncheckedUpdateWithoutShiftsInput>
  }

  export type EmployeeUpdateWithoutShiftsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    maritalStatus?: MaritalStatusUpdateOneWithoutEmployeesNestedInput
    employmentType?: EmploymentTypeUpdateOneWithoutEmployeesNestedInput
    jobStatus?: JobStatusUpdateOneWithoutEmployeesNestedInput
    agreementStatus?: AgreementStatusUpdateOneWithoutEmployeesNestedInput
    createdMeetings?: MeetingUpdateManyWithoutCreatorNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutShiftsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdMeetings?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUncheckedUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type ShiftUpsertWithoutAssignmentsInput = {
    update: XOR<ShiftUpdateWithoutAssignmentsInput, ShiftUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<ShiftCreateWithoutAssignmentsInput, ShiftUncheckedCreateWithoutAssignmentsInput>
    where?: ShiftWhereInput
  }

  export type ShiftUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: ShiftWhereInput
    data: XOR<ShiftUpdateWithoutAssignmentsInput, ShiftUncheckedUpdateWithoutAssignmentsInput>
  }

  export type ShiftUpdateWithoutAssignmentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isFlexible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ShiftUncheckedUpdateWithoutAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    isFlexible?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceLogCreateWithoutSessionInput = {
    date: Date | string
    actualClockIn?: Date | string | null
    actualClockOut?: Date | string | null
    status: $Enums.AttendanceStatus
    createdAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutAttendanceLogsInput
  }

  export type AttendanceLogUncheckedCreateWithoutSessionInput = {
    id?: number
    employeeId: number
    date: Date | string
    actualClockIn?: Date | string | null
    actualClockOut?: Date | string | null
    status: $Enums.AttendanceStatus
    createdAt?: Date | string
  }

  export type AttendanceLogCreateOrConnectWithoutSessionInput = {
    where: AttendanceLogWhereUniqueInput
    create: XOR<AttendanceLogCreateWithoutSessionInput, AttendanceLogUncheckedCreateWithoutSessionInput>
  }

  export type AttendanceLogCreateManySessionInputEnvelope = {
    data: AttendanceLogCreateManySessionInput | AttendanceLogCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceLogUpsertWithWhereUniqueWithoutSessionInput = {
    where: AttendanceLogWhereUniqueInput
    update: XOR<AttendanceLogUpdateWithoutSessionInput, AttendanceLogUncheckedUpdateWithoutSessionInput>
    create: XOR<AttendanceLogCreateWithoutSessionInput, AttendanceLogUncheckedCreateWithoutSessionInput>
  }

  export type AttendanceLogUpdateWithWhereUniqueWithoutSessionInput = {
    where: AttendanceLogWhereUniqueInput
    data: XOR<AttendanceLogUpdateWithoutSessionInput, AttendanceLogUncheckedUpdateWithoutSessionInput>
  }

  export type AttendanceLogUpdateManyWithWhereWithoutSessionInput = {
    where: AttendanceLogScalarWhereInput
    data: XOR<AttendanceLogUpdateManyMutationInput, AttendanceLogUncheckedUpdateManyWithoutSessionInput>
  }

  export type EmployeeCreateWithoutAttendanceLogsInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    subDepartmentId?: number | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    maritalStatus?: MaritalStatusCreateNestedOneWithoutEmployeesInput
    employmentType?: EmploymentTypeCreateNestedOneWithoutEmployeesInput
    jobStatus?: JobStatusCreateNestedOneWithoutEmployeesInput
    agreementStatus?: AgreementStatusCreateNestedOneWithoutEmployeesInput
    createdMeetings?: MeetingCreateNestedManyWithoutCreatorInput
    shifts?: EmployeeShiftCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutAttendanceLogsInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    subDepartmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdMeetings?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    shifts?: EmployeeShiftUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationUncheckedCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryUncheckedCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutAttendanceLogsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAttendanceLogsInput, EmployeeUncheckedCreateWithoutAttendanceLogsInput>
  }

  export type SessionDefinitionCreateWithoutLogsInput = {
    sessionNumber: number
    expectedClockIn: Date | string
    expectedClockOut: Date | string
  }

  export type SessionDefinitionUncheckedCreateWithoutLogsInput = {
    id?: number
    sessionNumber: number
    expectedClockIn: Date | string
    expectedClockOut: Date | string
  }

  export type SessionDefinitionCreateOrConnectWithoutLogsInput = {
    where: SessionDefinitionWhereUniqueInput
    create: XOR<SessionDefinitionCreateWithoutLogsInput, SessionDefinitionUncheckedCreateWithoutLogsInput>
  }

  export type EmployeeUpsertWithoutAttendanceLogsInput = {
    update: XOR<EmployeeUpdateWithoutAttendanceLogsInput, EmployeeUncheckedUpdateWithoutAttendanceLogsInput>
    create: XOR<EmployeeCreateWithoutAttendanceLogsInput, EmployeeUncheckedCreateWithoutAttendanceLogsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutAttendanceLogsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutAttendanceLogsInput, EmployeeUncheckedUpdateWithoutAttendanceLogsInput>
  }

  export type EmployeeUpdateWithoutAttendanceLogsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    maritalStatus?: MaritalStatusUpdateOneWithoutEmployeesNestedInput
    employmentType?: EmploymentTypeUpdateOneWithoutEmployeesNestedInput
    jobStatus?: JobStatusUpdateOneWithoutEmployeesNestedInput
    agreementStatus?: AgreementStatusUpdateOneWithoutEmployeesNestedInput
    createdMeetings?: MeetingUpdateManyWithoutCreatorNestedInput
    shifts?: EmployeeShiftUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutAttendanceLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdMeetings?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    shifts?: EmployeeShiftUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUncheckedUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type SessionDefinitionUpsertWithoutLogsInput = {
    update: XOR<SessionDefinitionUpdateWithoutLogsInput, SessionDefinitionUncheckedUpdateWithoutLogsInput>
    create: XOR<SessionDefinitionCreateWithoutLogsInput, SessionDefinitionUncheckedCreateWithoutLogsInput>
    where?: SessionDefinitionWhereInput
  }

  export type SessionDefinitionUpdateToOneWithWhereWithoutLogsInput = {
    where?: SessionDefinitionWhereInput
    data: XOR<SessionDefinitionUpdateWithoutLogsInput, SessionDefinitionUncheckedUpdateWithoutLogsInput>
  }

  export type SessionDefinitionUpdateWithoutLogsInput = {
    sessionNumber?: IntFieldUpdateOperationsInput | number
    expectedClockIn?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedClockOut?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionDefinitionUncheckedUpdateWithoutLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionNumber?: IntFieldUpdateOperationsInput | number
    expectedClockIn?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedClockOut?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateWithoutAttendanceSummariesInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    subDepartmentId?: number | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    maritalStatus?: MaritalStatusCreateNestedOneWithoutEmployeesInput
    employmentType?: EmploymentTypeCreateNestedOneWithoutEmployeesInput
    jobStatus?: JobStatusCreateNestedOneWithoutEmployeesInput
    agreementStatus?: AgreementStatusCreateNestedOneWithoutEmployeesInput
    createdMeetings?: MeetingCreateNestedManyWithoutCreatorInput
    shifts?: EmployeeShiftCreateNestedManyWithoutEmployeeInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutAttendanceSummariesInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    subDepartmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdMeetings?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    shifts?: EmployeeShiftUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationUncheckedCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryUncheckedCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutAttendanceSummariesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAttendanceSummariesInput, EmployeeUncheckedCreateWithoutAttendanceSummariesInput>
  }

  export type DepartmentCreateWithoutAttendanceSummariesInput = {
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: DepartmentCreateNestedOneWithoutSubDepartmentsInput
    subDepartments?: DepartmentCreateNestedManyWithoutParentInput
    employees?: EmployeeCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutAttendanceSummariesInput = {
    id?: number
    name: string
    description?: string | null
    parentId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subDepartments?: DepartmentUncheckedCreateNestedManyWithoutParentInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutAttendanceSummariesInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutAttendanceSummariesInput, DepartmentUncheckedCreateWithoutAttendanceSummariesInput>
  }

  export type EmployeeUpsertWithoutAttendanceSummariesInput = {
    update: XOR<EmployeeUpdateWithoutAttendanceSummariesInput, EmployeeUncheckedUpdateWithoutAttendanceSummariesInput>
    create: XOR<EmployeeCreateWithoutAttendanceSummariesInput, EmployeeUncheckedCreateWithoutAttendanceSummariesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutAttendanceSummariesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutAttendanceSummariesInput, EmployeeUncheckedUpdateWithoutAttendanceSummariesInput>
  }

  export type EmployeeUpdateWithoutAttendanceSummariesInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    maritalStatus?: MaritalStatusUpdateOneWithoutEmployeesNestedInput
    employmentType?: EmploymentTypeUpdateOneWithoutEmployeesNestedInput
    jobStatus?: JobStatusUpdateOneWithoutEmployeesNestedInput
    agreementStatus?: AgreementStatusUpdateOneWithoutEmployeesNestedInput
    createdMeetings?: MeetingUpdateManyWithoutCreatorNestedInput
    shifts?: EmployeeShiftUpdateManyWithoutEmployeeNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutAttendanceSummariesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdMeetings?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    shifts?: EmployeeShiftUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUncheckedUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type DepartmentUpsertWithoutAttendanceSummariesInput = {
    update: XOR<DepartmentUpdateWithoutAttendanceSummariesInput, DepartmentUncheckedUpdateWithoutAttendanceSummariesInput>
    create: XOR<DepartmentCreateWithoutAttendanceSummariesInput, DepartmentUncheckedCreateWithoutAttendanceSummariesInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutAttendanceSummariesInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutAttendanceSummariesInput, DepartmentUncheckedUpdateWithoutAttendanceSummariesInput>
  }

  export type DepartmentUpdateWithoutAttendanceSummariesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: DepartmentUpdateOneWithoutSubDepartmentsNestedInput
    subDepartments?: DepartmentUpdateManyWithoutParentNestedInput
    employees?: EmployeeUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutAttendanceSummariesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subDepartments?: DepartmentUncheckedUpdateManyWithoutParentNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type EmployeeCreateWithoutLeavesInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    subDepartmentId?: number | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    maritalStatus?: MaritalStatusCreateNestedOneWithoutEmployeesInput
    employmentType?: EmploymentTypeCreateNestedOneWithoutEmployeesInput
    jobStatus?: JobStatusCreateNestedOneWithoutEmployeesInput
    agreementStatus?: AgreementStatusCreateNestedOneWithoutEmployeesInput
    createdMeetings?: MeetingCreateNestedManyWithoutCreatorInput
    shifts?: EmployeeShiftCreateNestedManyWithoutEmployeeInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutLeavesInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    subDepartmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdMeetings?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    shifts?: EmployeeShiftUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationUncheckedCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryUncheckedCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutLeavesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutLeavesInput, EmployeeUncheckedCreateWithoutLeavesInput>
  }

  export type UserCreateWithoutApprovedLeavesInput = {
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notifyOnComplaint?: boolean
    roles?: UserRoleCreateNestedManyWithoutUserInput
    employees?: EmployeeCreateNestedManyWithoutUserInput
    approvedOvertimes?: OvertimeLogCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutApprovedLeavesInput = {
    id?: number
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notifyOnComplaint?: boolean
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutUserInput
    approvedOvertimes?: OvertimeLogUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutApprovedLeavesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedLeavesInput, UserUncheckedCreateWithoutApprovedLeavesInput>
  }

  export type EmployeeUpsertWithoutLeavesInput = {
    update: XOR<EmployeeUpdateWithoutLeavesInput, EmployeeUncheckedUpdateWithoutLeavesInput>
    create: XOR<EmployeeCreateWithoutLeavesInput, EmployeeUncheckedCreateWithoutLeavesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutLeavesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutLeavesInput, EmployeeUncheckedUpdateWithoutLeavesInput>
  }

  export type EmployeeUpdateWithoutLeavesInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    maritalStatus?: MaritalStatusUpdateOneWithoutEmployeesNestedInput
    employmentType?: EmploymentTypeUpdateOneWithoutEmployeesNestedInput
    jobStatus?: JobStatusUpdateOneWithoutEmployeesNestedInput
    agreementStatus?: AgreementStatusUpdateOneWithoutEmployeesNestedInput
    createdMeetings?: MeetingUpdateManyWithoutCreatorNestedInput
    shifts?: EmployeeShiftUpdateManyWithoutEmployeeNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutLeavesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdMeetings?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    shifts?: EmployeeShiftUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUncheckedUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUpsertWithoutApprovedLeavesInput = {
    update: XOR<UserUpdateWithoutApprovedLeavesInput, UserUncheckedUpdateWithoutApprovedLeavesInput>
    create: XOR<UserCreateWithoutApprovedLeavesInput, UserUncheckedCreateWithoutApprovedLeavesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedLeavesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedLeavesInput, UserUncheckedUpdateWithoutApprovedLeavesInput>
  }

  export type UserUpdateWithoutApprovedLeavesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifyOnComplaint?: BoolFieldUpdateOperationsInput | boolean
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    employees?: EmployeeUpdateManyWithoutUserNestedInput
    approvedOvertimes?: OvertimeLogUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedLeavesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifyOnComplaint?: BoolFieldUpdateOperationsInput | boolean
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutUserNestedInput
    approvedOvertimes?: OvertimeLogUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type EmployeeCreateWithoutOvertimesInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    subDepartmentId?: number | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    maritalStatus?: MaritalStatusCreateNestedOneWithoutEmployeesInput
    employmentType?: EmploymentTypeCreateNestedOneWithoutEmployeesInput
    jobStatus?: JobStatusCreateNestedOneWithoutEmployeesInput
    agreementStatus?: AgreementStatusCreateNestedOneWithoutEmployeesInput
    createdMeetings?: MeetingCreateNestedManyWithoutCreatorInput
    shifts?: EmployeeShiftCreateNestedManyWithoutEmployeeInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutOvertimesInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    subDepartmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdMeetings?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    shifts?: EmployeeShiftUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationUncheckedCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutOvertimesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutOvertimesInput, EmployeeUncheckedCreateWithoutOvertimesInput>
  }

  export type UserCreateWithoutApprovedOvertimesInput = {
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notifyOnComplaint?: boolean
    roles?: UserRoleCreateNestedManyWithoutUserInput
    employees?: EmployeeCreateNestedManyWithoutUserInput
    approvedLeaves?: LeaveCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutApprovedOvertimesInput = {
    id?: number
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notifyOnComplaint?: boolean
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutUserInput
    approvedLeaves?: LeaveUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutApprovedOvertimesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedOvertimesInput, UserUncheckedCreateWithoutApprovedOvertimesInput>
  }

  export type EmployeeUpsertWithoutOvertimesInput = {
    update: XOR<EmployeeUpdateWithoutOvertimesInput, EmployeeUncheckedUpdateWithoutOvertimesInput>
    create: XOR<EmployeeCreateWithoutOvertimesInput, EmployeeUncheckedCreateWithoutOvertimesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutOvertimesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutOvertimesInput, EmployeeUncheckedUpdateWithoutOvertimesInput>
  }

  export type EmployeeUpdateWithoutOvertimesInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    maritalStatus?: MaritalStatusUpdateOneWithoutEmployeesNestedInput
    employmentType?: EmploymentTypeUpdateOneWithoutEmployeesNestedInput
    jobStatus?: JobStatusUpdateOneWithoutEmployeesNestedInput
    agreementStatus?: AgreementStatusUpdateOneWithoutEmployeesNestedInput
    createdMeetings?: MeetingUpdateManyWithoutCreatorNestedInput
    shifts?: EmployeeShiftUpdateManyWithoutEmployeeNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutOvertimesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdMeetings?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    shifts?: EmployeeShiftUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUncheckedUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUpsertWithoutApprovedOvertimesInput = {
    update: XOR<UserUpdateWithoutApprovedOvertimesInput, UserUncheckedUpdateWithoutApprovedOvertimesInput>
    create: XOR<UserCreateWithoutApprovedOvertimesInput, UserUncheckedCreateWithoutApprovedOvertimesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedOvertimesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedOvertimesInput, UserUncheckedUpdateWithoutApprovedOvertimesInput>
  }

  export type UserUpdateWithoutApprovedOvertimesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifyOnComplaint?: BoolFieldUpdateOperationsInput | boolean
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    employees?: EmployeeUpdateManyWithoutUserNestedInput
    approvedLeaves?: LeaveUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedOvertimesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifyOnComplaint?: BoolFieldUpdateOperationsInput | boolean
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutUserNestedInput
    approvedLeaves?: LeaveUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type EmployeeCreateWithoutSalariesInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    subDepartmentId?: number | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    maritalStatus?: MaritalStatusCreateNestedOneWithoutEmployeesInput
    employmentType?: EmploymentTypeCreateNestedOneWithoutEmployeesInput
    jobStatus?: JobStatusCreateNestedOneWithoutEmployeesInput
    agreementStatus?: AgreementStatusCreateNestedOneWithoutEmployeesInput
    createdMeetings?: MeetingCreateNestedManyWithoutCreatorInput
    shifts?: EmployeeShiftCreateNestedManyWithoutEmployeeInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutSalariesInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    subDepartmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdMeetings?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    shifts?: EmployeeShiftUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationUncheckedCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutSalariesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutSalariesInput, EmployeeUncheckedCreateWithoutSalariesInput>
  }

  export type EmployeeUpsertWithoutSalariesInput = {
    update: XOR<EmployeeUpdateWithoutSalariesInput, EmployeeUncheckedUpdateWithoutSalariesInput>
    create: XOR<EmployeeCreateWithoutSalariesInput, EmployeeUncheckedCreateWithoutSalariesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutSalariesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutSalariesInput, EmployeeUncheckedUpdateWithoutSalariesInput>
  }

  export type EmployeeUpdateWithoutSalariesInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    maritalStatus?: MaritalStatusUpdateOneWithoutEmployeesNestedInput
    employmentType?: EmploymentTypeUpdateOneWithoutEmployeesNestedInput
    jobStatus?: JobStatusUpdateOneWithoutEmployeesNestedInput
    agreementStatus?: AgreementStatusUpdateOneWithoutEmployeesNestedInput
    createdMeetings?: MeetingUpdateManyWithoutCreatorNestedInput
    shifts?: EmployeeShiftUpdateManyWithoutEmployeeNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutSalariesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdMeetings?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    shifts?: EmployeeShiftUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateWithoutComplaintsInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    subDepartmentId?: number | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    maritalStatus?: MaritalStatusCreateNestedOneWithoutEmployeesInput
    employmentType?: EmploymentTypeCreateNestedOneWithoutEmployeesInput
    jobStatus?: JobStatusCreateNestedOneWithoutEmployeesInput
    agreementStatus?: AgreementStatusCreateNestedOneWithoutEmployeesInput
    createdMeetings?: MeetingCreateNestedManyWithoutCreatorInput
    shifts?: EmployeeShiftCreateNestedManyWithoutEmployeeInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutComplaintsInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    subDepartmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdMeetings?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    shifts?: EmployeeShiftUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationUncheckedCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryUncheckedCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutComplaintsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutComplaintsInput, EmployeeUncheckedCreateWithoutComplaintsInput>
  }

  export type EmployeeUpsertWithoutComplaintsInput = {
    update: XOR<EmployeeUpdateWithoutComplaintsInput, EmployeeUncheckedUpdateWithoutComplaintsInput>
    create: XOR<EmployeeCreateWithoutComplaintsInput, EmployeeUncheckedCreateWithoutComplaintsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutComplaintsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutComplaintsInput, EmployeeUncheckedUpdateWithoutComplaintsInput>
  }

  export type EmployeeUpdateWithoutComplaintsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    maritalStatus?: MaritalStatusUpdateOneWithoutEmployeesNestedInput
    employmentType?: EmploymentTypeUpdateOneWithoutEmployeesNestedInput
    jobStatus?: JobStatusUpdateOneWithoutEmployeesNestedInput
    agreementStatus?: AgreementStatusUpdateOneWithoutEmployeesNestedInput
    createdMeetings?: MeetingUpdateManyWithoutCreatorNestedInput
    shifts?: EmployeeShiftUpdateManyWithoutEmployeeNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutComplaintsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdMeetings?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    shifts?: EmployeeShiftUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUncheckedUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateWithoutPerformanceReviewsInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    subDepartmentId?: number | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    maritalStatus?: MaritalStatusCreateNestedOneWithoutEmployeesInput
    employmentType?: EmploymentTypeCreateNestedOneWithoutEmployeesInput
    jobStatus?: JobStatusCreateNestedOneWithoutEmployeesInput
    agreementStatus?: AgreementStatusCreateNestedOneWithoutEmployeesInput
    createdMeetings?: MeetingCreateNestedManyWithoutCreatorInput
    shifts?: EmployeeShiftCreateNestedManyWithoutEmployeeInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutPerformanceReviewsInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    subDepartmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdMeetings?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    shifts?: EmployeeShiftUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutEmployeeInput
    terminations?: TerminationUncheckedCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryUncheckedCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutPerformanceReviewsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutPerformanceReviewsInput, EmployeeUncheckedCreateWithoutPerformanceReviewsInput>
  }

  export type EmployeeUpsertWithoutPerformanceReviewsInput = {
    update: XOR<EmployeeUpdateWithoutPerformanceReviewsInput, EmployeeUncheckedUpdateWithoutPerformanceReviewsInput>
    create: XOR<EmployeeCreateWithoutPerformanceReviewsInput, EmployeeUncheckedCreateWithoutPerformanceReviewsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutPerformanceReviewsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutPerformanceReviewsInput, EmployeeUncheckedUpdateWithoutPerformanceReviewsInput>
  }

  export type EmployeeUpdateWithoutPerformanceReviewsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    maritalStatus?: MaritalStatusUpdateOneWithoutEmployeesNestedInput
    employmentType?: EmploymentTypeUpdateOneWithoutEmployeesNestedInput
    jobStatus?: JobStatusUpdateOneWithoutEmployeesNestedInput
    agreementStatus?: AgreementStatusUpdateOneWithoutEmployeesNestedInput
    createdMeetings?: MeetingUpdateManyWithoutCreatorNestedInput
    shifts?: EmployeeShiftUpdateManyWithoutEmployeeNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutPerformanceReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdMeetings?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    shifts?: EmployeeShiftUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUncheckedUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateWithoutTerminationsInput = {
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    subDepartmentId?: number | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    maritalStatus?: MaritalStatusCreateNestedOneWithoutEmployeesInput
    employmentType?: EmploymentTypeCreateNestedOneWithoutEmployeesInput
    jobStatus?: JobStatusCreateNestedOneWithoutEmployeesInput
    agreementStatus?: AgreementStatusCreateNestedOneWithoutEmployeesInput
    createdMeetings?: MeetingCreateNestedManyWithoutCreatorInput
    shifts?: EmployeeShiftCreateNestedManyWithoutEmployeeInput
    attendanceLogs?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutTerminationsInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    subDepartmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdMeetings?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    shifts?: EmployeeShiftUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceLogs?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    attendanceSummaries?: AttendanceSummaryUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutEmployeeInput
    performanceReviews?: PerformanceReviewUncheckedCreateNestedManyWithoutEmployeeInput
    salaries?: SalaryUncheckedCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutTerminationsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutTerminationsInput, EmployeeUncheckedCreateWithoutTerminationsInput>
  }

  export type EmployeeUpsertWithoutTerminationsInput = {
    update: XOR<EmployeeUpdateWithoutTerminationsInput, EmployeeUncheckedUpdateWithoutTerminationsInput>
    create: XOR<EmployeeCreateWithoutTerminationsInput, EmployeeUncheckedCreateWithoutTerminationsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutTerminationsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutTerminationsInput, EmployeeUncheckedUpdateWithoutTerminationsInput>
  }

  export type EmployeeUpdateWithoutTerminationsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    maritalStatus?: MaritalStatusUpdateOneWithoutEmployeesNestedInput
    employmentType?: EmploymentTypeUpdateOneWithoutEmployeesNestedInput
    jobStatus?: JobStatusUpdateOneWithoutEmployeesNestedInput
    agreementStatus?: AgreementStatusUpdateOneWithoutEmployeesNestedInput
    createdMeetings?: MeetingUpdateManyWithoutCreatorNestedInput
    shifts?: EmployeeShiftUpdateManyWithoutEmployeeNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutTerminationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdMeetings?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    shifts?: EmployeeShiftUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type UserRoleCreateManyRoleInput = {
    userId: number
  }

  export type UserRoleUpdateWithoutRoleInput = {
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutRoleInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleInput = {
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type UserRoleCreateManyUserInput = {
    roleId: number
  }

  export type EmployeeCreateManyUserInput = {
    id?: number
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    subDepartmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveCreateManyApproverInput = {
    id?: number
    employeeId: number
    leaveType: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.LeaveStatus
    reason?: string | null
    requestedAt?: Date | string
    updatedAt?: Date | string
  }

  export type OvertimeLogCreateManyApproverInput = {
    id?: number
    employeeId: number
    date: Date | string
    hours?: Decimal | DecimalJsLike | number | string | null
    startTime: Date | string
    endTime: Date | string
    reason?: string | null
    approvalStatus?: $Enums.OvertimeApprovalStatus
    compensationMethod?: $Enums.CompensationMethod
  }

  export type UserRoleUpdateWithoutUserInput = {
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutUserInput = {
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type UserRoleUncheckedUpdateManyWithoutUserInput = {
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type EmployeeUpdateWithoutUserInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    maritalStatus?: MaritalStatusUpdateOneWithoutEmployeesNestedInput
    employmentType?: EmploymentTypeUpdateOneWithoutEmployeesNestedInput
    jobStatus?: JobStatusUpdateOneWithoutEmployeesNestedInput
    agreementStatus?: AgreementStatusUpdateOneWithoutEmployeesNestedInput
    createdMeetings?: MeetingUpdateManyWithoutCreatorNestedInput
    shifts?: EmployeeShiftUpdateManyWithoutEmployeeNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdMeetings?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    shifts?: EmployeeShiftUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUncheckedUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveUpdateWithoutApproverInput = {
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutLeavesNestedInput
  }

  export type LeaveUncheckedUpdateWithoutApproverInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveUncheckedUpdateManyWithoutApproverInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OvertimeLogUpdateWithoutApproverInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumOvertimeApprovalStatusFieldUpdateOperationsInput | $Enums.OvertimeApprovalStatus
    compensationMethod?: EnumCompensationMethodFieldUpdateOperationsInput | $Enums.CompensationMethod
    employee?: EmployeeUpdateOneRequiredWithoutOvertimesNestedInput
  }

  export type OvertimeLogUncheckedUpdateWithoutApproverInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumOvertimeApprovalStatusFieldUpdateOperationsInput | $Enums.OvertimeApprovalStatus
    compensationMethod?: EnumCompensationMethodFieldUpdateOperationsInput | $Enums.CompensationMethod
  }

  export type OvertimeLogUncheckedUpdateManyWithoutApproverInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumOvertimeApprovalStatusFieldUpdateOperationsInput | $Enums.OvertimeApprovalStatus
    compensationMethod?: EnumCompensationMethodFieldUpdateOperationsInput | $Enums.CompensationMethod
  }

  export type DepartmentCreateManyParentInput = {
    id?: number
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeCreateManyDepartmentInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    maritalStatusId?: number | null
    subDepartmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceSummaryCreateManyDepartmentInput = {
    id?: number
    employeeId: number
    date: Date | string
    status: $Enums.SummaryStatus
    lateArrival?: boolean
    earlyDeparture?: boolean
    unplannedAbsence?: boolean
    totalWorkHours?: Decimal | DecimalJsLike | number | string | null
    remarks?: string | null
  }

  export type DepartmentUpdateWithoutParentInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subDepartments?: DepartmentUpdateManyWithoutParentNestedInput
    employees?: EmployeeUpdateManyWithoutDepartmentNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subDepartments?: DepartmentUncheckedUpdateManyWithoutParentNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUpdateWithoutDepartmentInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    maritalStatus?: MaritalStatusUpdateOneWithoutEmployeesNestedInput
    employmentType?: EmploymentTypeUpdateOneWithoutEmployeesNestedInput
    jobStatus?: JobStatusUpdateOneWithoutEmployeesNestedInput
    agreementStatus?: AgreementStatusUpdateOneWithoutEmployeesNestedInput
    createdMeetings?: MeetingUpdateManyWithoutCreatorNestedInput
    shifts?: EmployeeShiftUpdateManyWithoutEmployeeNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdMeetings?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    shifts?: EmployeeShiftUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUncheckedUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceSummaryUpdateWithoutDepartmentInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSummaryStatusFieldUpdateOperationsInput | $Enums.SummaryStatus
    lateArrival?: BoolFieldUpdateOperationsInput | boolean
    earlyDeparture?: BoolFieldUpdateOperationsInput | boolean
    unplannedAbsence?: BoolFieldUpdateOperationsInput | boolean
    totalWorkHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    employee?: EmployeeUpdateOneRequiredWithoutAttendanceSummariesNestedInput
  }

  export type AttendanceSummaryUncheckedUpdateWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSummaryStatusFieldUpdateOperationsInput | $Enums.SummaryStatus
    lateArrival?: BoolFieldUpdateOperationsInput | boolean
    earlyDeparture?: BoolFieldUpdateOperationsInput | boolean
    unplannedAbsence?: BoolFieldUpdateOperationsInput | boolean
    totalWorkHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceSummaryUncheckedUpdateManyWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSummaryStatusFieldUpdateOperationsInput | $Enums.SummaryStatus
    lateArrival?: BoolFieldUpdateOperationsInput | boolean
    earlyDeparture?: BoolFieldUpdateOperationsInput | boolean
    unplannedAbsence?: BoolFieldUpdateOperationsInput | boolean
    totalWorkHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeCreateManyPositionInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    subDepartmentId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateWithoutPositionInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    maritalStatus?: MaritalStatusUpdateOneWithoutEmployeesNestedInput
    employmentType?: EmploymentTypeUpdateOneWithoutEmployeesNestedInput
    jobStatus?: JobStatusUpdateOneWithoutEmployeesNestedInput
    agreementStatus?: AgreementStatusUpdateOneWithoutEmployeesNestedInput
    createdMeetings?: MeetingUpdateManyWithoutCreatorNestedInput
    shifts?: EmployeeShiftUpdateManyWithoutEmployeeNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutPositionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdMeetings?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    shifts?: EmployeeShiftUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUncheckedUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutPositionInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateManyMaritalStatusInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    departmentId?: number | null
    subDepartmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateWithoutMaritalStatusInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    employmentType?: EmploymentTypeUpdateOneWithoutEmployeesNestedInput
    jobStatus?: JobStatusUpdateOneWithoutEmployeesNestedInput
    agreementStatus?: AgreementStatusUpdateOneWithoutEmployeesNestedInput
    createdMeetings?: MeetingUpdateManyWithoutCreatorNestedInput
    shifts?: EmployeeShiftUpdateManyWithoutEmployeeNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutMaritalStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdMeetings?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    shifts?: EmployeeShiftUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUncheckedUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutMaritalStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateManyEmploymentTypeInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    subDepartmentId?: number | null
    positionId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateWithoutEmploymentTypeInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    maritalStatus?: MaritalStatusUpdateOneWithoutEmployeesNestedInput
    jobStatus?: JobStatusUpdateOneWithoutEmployeesNestedInput
    agreementStatus?: AgreementStatusUpdateOneWithoutEmployeesNestedInput
    createdMeetings?: MeetingUpdateManyWithoutCreatorNestedInput
    shifts?: EmployeeShiftUpdateManyWithoutEmployeeNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutEmploymentTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdMeetings?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    shifts?: EmployeeShiftUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUncheckedUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutEmploymentTypeInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateManyJobStatusInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    subDepartmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    agreementStatusId?: number | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateWithoutJobStatusInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    maritalStatus?: MaritalStatusUpdateOneWithoutEmployeesNestedInput
    employmentType?: EmploymentTypeUpdateOneWithoutEmployeesNestedInput
    agreementStatus?: AgreementStatusUpdateOneWithoutEmployeesNestedInput
    createdMeetings?: MeetingUpdateManyWithoutCreatorNestedInput
    shifts?: EmployeeShiftUpdateManyWithoutEmployeeNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutJobStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdMeetings?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    shifts?: EmployeeShiftUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUncheckedUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutJobStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    agreementStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateManyAgreementStatusInput = {
    id?: number
    userId?: number | null
    firstName: string
    lastName: string
    baptismalName?: string | null
    dateOfBirth?: Date | string | null
    sex: $Enums.Sex
    nationality?: string | null
    maritalStatusId?: number | null
    departmentId?: number | null
    subDepartmentId?: number | null
    positionId?: number | null
    employmentTypeId?: number | null
    employmentDate?: Date | string | null
    jobStatusId?: number | null
    phone?: string | null
    address?: string | null
    subCity?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    repentanceFatherName?: string | null
    repentanceFatherChurch?: string | null
    repentanceFatherPhone?: string | null
    academicQualification?: string | null
    educationalInstitution?: string | null
    salary?: Decimal | DecimalJsLike | number | string
    bonusSalary?: Decimal | DecimalJsLike | number | string
    accountNumber?: string | null
    photo?: string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateWithoutAgreementStatusInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    maritalStatus?: MaritalStatusUpdateOneWithoutEmployeesNestedInput
    employmentType?: EmploymentTypeUpdateOneWithoutEmployeesNestedInput
    jobStatus?: JobStatusUpdateOneWithoutEmployeesNestedInput
    createdMeetings?: MeetingUpdateManyWithoutCreatorNestedInput
    shifts?: EmployeeShiftUpdateManyWithoutEmployeeNestedInput
    attendanceLogs?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutAgreementStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdMeetings?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    shifts?: EmployeeShiftUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceLogs?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    attendanceSummaries?: AttendanceSummaryUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutEmployeeNestedInput
    performanceReviews?: PerformanceReviewUncheckedUpdateManyWithoutEmployeeNestedInput
    terminations?: TerminationUncheckedUpdateManyWithoutEmployeeNestedInput
    salaries?: SalaryUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutAgreementStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    baptismalName?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sex?: EnumSexFieldUpdateOperationsInput | $Enums.Sex
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
    subDepartmentId?: NullableIntFieldUpdateOperationsInput | number | null
    positionId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employmentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jobStatusId?: NullableIntFieldUpdateOperationsInput | number | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    subCity?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherName?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherChurch?: NullableStringFieldUpdateOperationsInput | string | null
    repentanceFatherPhone?: NullableStringFieldUpdateOperationsInput | string | null
    academicQualification?: NullableStringFieldUpdateOperationsInput | string | null
    educationalInstitution?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bonusSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingCreateManyCreatorInput = {
    id?: number
    title: string
    description?: string | null
    date: string
    time: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeShiftCreateManyEmployeeInput = {
    id?: number
    shiftId: number
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
  }

  export type AttendanceLogCreateManyEmployeeInput = {
    id?: number
    date: Date | string
    sessionId: number
    actualClockIn?: Date | string | null
    actualClockOut?: Date | string | null
    status: $Enums.AttendanceStatus
    createdAt?: Date | string
  }

  export type AttendanceSummaryCreateManyEmployeeInput = {
    id?: number
    date: Date | string
    status: $Enums.SummaryStatus
    lateArrival?: boolean
    earlyDeparture?: boolean
    unplannedAbsence?: boolean
    totalWorkHours?: Decimal | DecimalJsLike | number | string | null
    remarks?: string | null
    departmentId?: number | null
  }

  export type LeaveCreateManyEmployeeInput = {
    id?: number
    leaveType: $Enums.LeaveType
    startDate: Date | string
    endDate: Date | string
    status?: $Enums.LeaveStatus
    reason?: string | null
    approvedBy?: number | null
    requestedAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplaintCreateManyEmployeeInput = {
    id?: number
    subject: string
    description: string
    status?: $Enums.ComplaintStatus
    response?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceReviewCreateManyEmployeeInput = {
    id?: number
    reviewDate: Date | string
    reviewerName?: string | null
    score?: number | null
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TerminationCreateManyEmployeeInput = {
    id?: number
    terminationDate: Date | string
    reason?: string | null
    status: $Enums.TerminationStatus
    workflowStatus?: $Enums.WorkflowStatus
    remarks?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalaryCreateManyEmployeeInput = {
    id?: number
    salaryMonth: Date | string
    amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.SalaryStatus
    overtimeHours?: Decimal | DecimalJsLike | number | string
    overtimePay?: Decimal | DecimalJsLike | number | string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OvertimeLogCreateManyEmployeeInput = {
    id?: number
    date: Date | string
    hours?: Decimal | DecimalJsLike | number | string | null
    startTime: Date | string
    endTime: Date | string
    reason?: string | null
    approvedBy?: number | null
    approvalStatus?: $Enums.OvertimeApprovalStatus
    compensationMethod?: $Enums.CompensationMethod
  }

  export type MeetingUpdateWithoutCreatorInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeShiftUpdateWithoutEmployeeInput = {
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    shift?: ShiftUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type EmployeeShiftUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    shiftId?: IntFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeShiftUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    shiftId?: IntFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceLogUpdateWithoutEmployeeInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    actualClockIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionDefinitionUpdateOneRequiredWithoutLogsNestedInput
  }

  export type AttendanceLogUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: IntFieldUpdateOperationsInput | number
    actualClockIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceLogUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionId?: IntFieldUpdateOperationsInput | number
    actualClockIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceSummaryUpdateWithoutEmployeeInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSummaryStatusFieldUpdateOperationsInput | $Enums.SummaryStatus
    lateArrival?: BoolFieldUpdateOperationsInput | boolean
    earlyDeparture?: BoolFieldUpdateOperationsInput | boolean
    unplannedAbsence?: BoolFieldUpdateOperationsInput | boolean
    totalWorkHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    department?: DepartmentUpdateOneWithoutAttendanceSummariesNestedInput
  }

  export type AttendanceSummaryUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSummaryStatusFieldUpdateOperationsInput | $Enums.SummaryStatus
    lateArrival?: BoolFieldUpdateOperationsInput | boolean
    earlyDeparture?: BoolFieldUpdateOperationsInput | boolean
    unplannedAbsence?: BoolFieldUpdateOperationsInput | boolean
    totalWorkHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AttendanceSummaryUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSummaryStatusFieldUpdateOperationsInput | $Enums.SummaryStatus
    lateArrival?: BoolFieldUpdateOperationsInput | boolean
    earlyDeparture?: BoolFieldUpdateOperationsInput | boolean
    unplannedAbsence?: BoolFieldUpdateOperationsInput | boolean
    totalWorkHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LeaveUpdateWithoutEmployeeInput = {
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approver?: UserUpdateOneWithoutApprovedLeavesNestedInput
  }

  export type LeaveUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    leaveType?: EnumLeaveTypeFieldUpdateOperationsInput | $Enums.LeaveType
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintUpdateWithoutEmployeeInput = {
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumComplaintStatusFieldUpdateOperationsInput | $Enums.ComplaintStatus
    response?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceReviewUpdateWithoutEmployeeInput = {
    reviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewerName?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceReviewUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    reviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewerName?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceReviewUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    reviewDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewerName?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TerminationUpdateWithoutEmployeeInput = {
    terminationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTerminationStatusFieldUpdateOperationsInput | $Enums.TerminationStatus
    workflowStatus?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TerminationUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    terminationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTerminationStatusFieldUpdateOperationsInput | $Enums.TerminationStatus
    workflowStatus?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TerminationUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    terminationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTerminationStatusFieldUpdateOperationsInput | $Enums.TerminationStatus
    workflowStatus?: EnumWorkflowStatusFieldUpdateOperationsInput | $Enums.WorkflowStatus
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryUpdateWithoutEmployeeInput = {
    salaryMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumSalaryStatusFieldUpdateOperationsInput | $Enums.SalaryStatus
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimePay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    salaryMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumSalaryStatusFieldUpdateOperationsInput | $Enums.SalaryStatus
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimePay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    salaryMonth?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumSalaryStatusFieldUpdateOperationsInput | $Enums.SalaryStatus
    overtimeHours?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtimePay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OvertimeLogUpdateWithoutEmployeeInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumOvertimeApprovalStatusFieldUpdateOperationsInput | $Enums.OvertimeApprovalStatus
    compensationMethod?: EnumCompensationMethodFieldUpdateOperationsInput | $Enums.CompensationMethod
    approver?: UserUpdateOneWithoutApprovedOvertimesNestedInput
  }

  export type OvertimeLogUncheckedUpdateWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvalStatus?: EnumOvertimeApprovalStatusFieldUpdateOperationsInput | $Enums.OvertimeApprovalStatus
    compensationMethod?: EnumCompensationMethodFieldUpdateOperationsInput | $Enums.CompensationMethod
  }

  export type OvertimeLogUncheckedUpdateManyWithoutEmployeeInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableIntFieldUpdateOperationsInput | number | null
    approvalStatus?: EnumOvertimeApprovalStatusFieldUpdateOperationsInput | $Enums.OvertimeApprovalStatus
    compensationMethod?: EnumCompensationMethodFieldUpdateOperationsInput | $Enums.CompensationMethod
  }

  export type EmployeeShiftCreateManyShiftInput = {
    id?: number
    employeeId: number
    effectiveFrom: Date | string
    effectiveTo?: Date | string | null
  }

  export type EmployeeShiftUpdateWithoutShiftInput = {
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: EmployeeUpdateOneRequiredWithoutShiftsNestedInput
  }

  export type EmployeeShiftUncheckedUpdateWithoutShiftInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeShiftUncheckedUpdateManyWithoutShiftInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AttendanceLogCreateManySessionInput = {
    id?: number
    employeeId: number
    date: Date | string
    actualClockIn?: Date | string | null
    actualClockOut?: Date | string | null
    status: $Enums.AttendanceStatus
    createdAt?: Date | string
  }

  export type AttendanceLogUpdateWithoutSessionInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    actualClockIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutAttendanceLogsNestedInput
  }

  export type AttendanceLogUncheckedUpdateWithoutSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    actualClockIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceLogUncheckedUpdateManyWithoutSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    employeeId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    actualClockIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualClockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}